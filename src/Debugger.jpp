#include "Global.inc"
#ifndef USE_JAVA_MOBILE
import javax.swing.*;
import javax.swing.event.*;
import java.awt.*;
import java.awt.event.*;
import java.util.LinkedList;
import java.net.*;
import java.awt.image.BufferedImage;
import javax.swing.table.*;
import javax.swing.JTable;
import javax.swing.table.DefaultTableCellRenderer;
import java.io.*;

public class Debugger implements ActionListener, ItemListener, KeyListener, MouseListener, AdjustmentListener { //GUI
	public static boolean RIGHT_TO_LEFT = false;
	private static final int aaarg=650;
	public JTable regs1;
	public JTable regs2;
	public JTable hwregs;
	public JTable mem;
	public boolean memiseditable=true;
	public JTable instrs;
	public JTextField cmds;

	private JScrollBar memScroller;

	private Disassembler deasm;
	private int memaddr=0;
	private Color UpdateColor = new Color(255,200,200);
	public DebugRunner runner;
	swinggui gui;
	private Font MonoFont= FHandler.getVeraMonoFont();
	private RDParser parser;
	private int[] oldRegVal;
	private Writer logwriter;
	private int bpm=-1; //break on memory access
	public Debugger(swinggui gui, String logfilename) {
		this.gui=gui;
		try {
			if (!logfilename.equals(""))
				logwriter = new BufferedWriter( new FileWriter(logfilename) );
		}
		catch (java.io.IOException e) {
			System.out.println("Error opening logfile:" + e.getMessage());
			logwriter = null;
		}
		deasm= new Disassembler(gui.cpu);
		oldRegVal=new int[11];
		parser=new RDParser();

		runner = new DebugRunner(this);
		createAndShowGUI();
		update();
	}

	public class DebugRunner implements Runnable, CPURunner {
		private volatile int threadStatus = 0;
		private Thread cpurunthread;
		// 0 means suspended
		// 1 means suspend->running requested
		// 2 means running
		// 3 means running->suspended requested
		private Debugger dbg;
		private int stopaddr = -1;
		private int watchaddr = -1;
		private int runFor=-1;
		private int instrstop=-1;
		private int breakinstr=-1;

		synchronized public void suspend() {
			while (threadStatus != 0) {
				threadStatus = 3;
				while (threadStatus == 3) { YIELD; };
			}
		}

		synchronized public void resume() {
			if (!CPU.canRun()) return;
			if (threadStatus != 2) {
				threadStatus = 1;
				while (threadStatus == 1) { YIELD; };
			}
		}

		public boolean isRunning() {
			return (threadStatus != 0);
		}

		public void setBreakPoint(int addr) {
			if (threadStatus == 0)
				stopaddr = addr;
		}

		public void setBreakInstr(int instr) {
			if (threadStatus == 0)
				breakinstr = instr;
		}

		public void setWatchPoint(int addr) {
			if (threadStatus == 0)
				watchaddr = addr;
		}

		public void setInstrStop(int instrs) {
			if (threadStatus == 0)
				instrstop = instrs;
		}

		public void setRunFor(int i) {
			if (threadStatus == 0)
				this.runFor=i;
		}

		public int getRunFor() {
				return this.runFor;
		}

		public void decRunFor() {
			this.runFor--;
		}

		public DebugRunner(Debugger tdbg) { //Pass something
			dbg = tdbg;
			cpurunthread = new Thread(this);
			cpurunthread.start();
			while (!cpurunthread.isAlive()) { YIELD; }; // wait for thread to actually start
	 	}

		public void run() {
			while (true) {
				// suspended
				while (threadStatus == 0) { YIELD; };
				// suspend -> running
				if (threadStatus == 1) threadStatus = 2;

				// running..
				int cycling = 69905;
				long curms = System.currentTimeMillis();

				boolean keeprunning = true;
				while ((threadStatus == 2) && keeprunning) {
					int wval = (watchaddr>=0) ? dbg.gui.cpu.read(watchaddr) : 0;
					int OldPC=gui.cpu.PC;
					try {
						cycling -= dbg.gui.cpu.nextinstruction();
						decRunFor();
					}
					catch( Throwable t ) {
						System.out.println("+=================================================+");
						System.out.println("UNHANDLED ERROR:");
						t.printStackTrace();
						System.out.println("+-------------------------------------------------+");
						gui.cpu.PC=OldPC;
						gui.cpu.printCPUstatus();
						System.out.println("+=================================================+");
						keeprunning = false;
					}
					if (logwriter != null) {
						String out = STRFORMAT("PC=$%04x AF=$%02x%02x BC=$%02x%02x DE=$%02x%02x HL=$%02x%02x SP=$%04x\n",
//							gui.cpu.TotalInstrCount,
//							gui.cpu.TotalCycleCount,
							gui.cpu.PC,
							gui.cpu.A,
							gui.cpu.F,
							gui.cpu.B,
							gui.cpu.C,
							gui.cpu.D,
							gui.cpu.E,
							gui.cpu.H,
							gui.cpu.L,
							gui.cpu.SP);
						try {
							logwriter.write(out);
						}
						catch (java.io.IOException e) {
							System.out.println("Error writing logfile:" + e.getMessage());
							logwriter = null;
						}
					}
					if (dbg.gui.cpu.TotalInstrCount == instrstop) {
						keeprunning = false;
					}
					if (dbg.gui.cpu.PC == stopaddr) {
						keeprunning = false;
					}
					if ((watchaddr>=0) && (wval != dbg.gui.cpu.read(watchaddr))) {
						keeprunning = false;
					}
					if (
						(dbg.gui.cpu.B<0) || (dbg.gui.cpu.B>0xff) ||
						(dbg.gui.cpu.C<0) || (dbg.gui.cpu.C>0xff) ||
						(dbg.gui.cpu.D<0) || (dbg.gui.cpu.D>0xff) ||
						(dbg.gui.cpu.E<0) || (dbg.gui.cpu.E>0xff) ||
						(dbg.gui.cpu.F<0) || (dbg.gui.cpu.F>0xff) ||
						(dbg.gui.cpu.H<0) || (dbg.gui.cpu.H>0xff) ||
						(dbg.gui.cpu.L<0) || (dbg.gui.cpu.L>0xff) ||
						(dbg.gui.cpu.SP<0) || (dbg.gui.cpu.SP>0xffff) ||
						(dbg.gui.cpu.PC<0) || (dbg.gui.cpu.PC>0xffff)
					) {
						keeprunning = false;
					}
					if (dbg.gui.cpu.exception() != 0) {
						keeprunning = false;
						gui.cpu.printCPUstatus();
					}
					if (dbg.gui.cpu.read(dbg.gui.cpu.PC) == breakinstr) {
						keeprunning = false;
					}
					if((bpm>=0)&&(bpm==dbg.gui.cpu.last_memory_access)) {
						keeprunning = false;
						PRINTF("Break due to memory access of $%04x\n", dbg.gui.cpu.last_memory_access);
					}
					if (getRunFor()==0)
						keeprunning = false;
				}
				if (threadStatus == 2) threadStatus = 3; // BREAK!
				// running -> suspended
				if (threadStatus == 3) threadStatus = 0;
				// suspended
				dbg.update();
			}
		}
	}

	public class MyCellRenderer extends DefaultTableCellRenderer { //for coloring cells
		private static final long serialVersionUID = 1L; // prevent warning
		private Color[] Colors=null;
		public MyCellRenderer(Color[] c) {
			super();
			Colors=c;
		}

		public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
			setText(String.valueOf(value));
// 			System.out.println("row "+row+"="+this.Colors[row]);
			if((this.Colors!=null)) setBackground(this.Colors[row]);
			else setBackground(Color.WHITE);

			if((table==regs1)||(table==regs2)||(table==hwregs)) {
				String s = (String)table.getValueAt(row, column);
				int i= s.indexOf('$');
				if( i>-1) {
					s=s.substring(i);
					i=parser.StrToInt(s);
					setToolTipText(STRFORMAT("%dd  %04xh  %08db",i,i,parser.StrToInt(Integer.toBinaryString(i))));
				} else setToolTipText("");
			}
			else {
				setToolTipText("");
			}
			setFont(MonoFont);
			return this;
		}
	}

	public class EditMemTableModelListener implements TableModelListener { //for editing the memory
		public void tableChanged(TableModelEvent evt) {
			if(memiseditable) {
				if (evt.getType() == TableModelEvent.UPDATE) {
					int column = evt.getColumn();
					int row = evt.getFirstRow();
	 				System.out.println("row: " + row + " column: " + column);
					int index = (row)*8 + (column-2) + memaddr;
					int i=memaddr; memaddr=index; prepareParser(); memaddr=i; //HAXHAXHAXHAXHAXHAX
					int value = parser.Evaluate(((String)mem.getValueAt(row, column)).trim());
					PRINTF("index=$%04x, value=$%02x\n", index , value);
					gui.cpu.write(index, value);
					update(); //System.out.println("update EditMemTableModelListener");
	/*				mem.setColumnSelectionInterval(column + 1, column + 1);
					mem.setRowSelectionInterval(row, row);*/
				}
			}
		}
	}

	public void mouseExited(MouseEvent e) {
		PRINTLN("MOUSE EXIT");
	}
	public void mouseEntered(MouseEvent e) {
		PRINTLN("MOUSE ENTER");
	}

	public void mouseReleased(MouseEvent e) {
		PRINTLN("MOUSE RELEASE");
	}
	public void mousePressed(MouseEvent e) {
		PRINTLN("MOUSE PRESSED");
	}
	public void mouseClicked(MouseEvent e) {
		PRINTLN("MOUSE CLICKED");
	}

	public void adjustmentValueChanged(AdjustmentEvent e) {
		memaddr = e.getValue();
		update();
	}

	public void addComponentsToPane( Container contentPane ) {
		// Use BorderLayout. Default empty constructor with no horizontal and vertical
		// gaps
		contentPane.setLayout( new BoxLayout( contentPane, BoxLayout.Y_AXIS ) );
		if ( RIGHT_TO_LEFT ) {
			contentPane.setComponentOrientation(
				java.awt.ComponentOrientation.RIGHT_TO_LEFT );
		}
		JScrollPane scroll = new JScrollPane(new JLabel("Registers:"));
		scroll.setMaximumSize(new Dimension(aaarg, Integer.MAX_VALUE));
		scroll.setPreferredSize(new Dimension(aaarg, 19));
		contentPane.add( scroll, BorderLayout.LINE_END );
		regs1 = new JTable(1,8);
		regs1.setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS);
		regs1.setTableHeader(null);
		regs1.setFont(MonoFont);
		scroll = new JScrollPane(regs1);
		scroll.setMaximumSize(new Dimension(aaarg, Integer.MAX_VALUE));
		scroll.setPreferredSize(new Dimension(aaarg, 19));
		contentPane.add( scroll, BorderLayout.NORTH );

		regs2 = new JTable(1,4);
		regs2.setCellSelectionEnabled(false);
		regs2.setColumnSelectionAllowed(false);
		regs2.setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS);
		regs2.setTableHeader(null);
		regs2.setFont(MonoFont);
		scroll = new JScrollPane(regs2);
		scroll.setMaximumSize(new Dimension(aaarg, Integer.MAX_VALUE));
		scroll.setPreferredSize(new Dimension(aaarg, 19));
		contentPane.add( scroll, BorderLayout.NORTH );

		scroll = new JScrollPane(new JLabel("Hardware registers:"));
		scroll.setMaximumSize(new Dimension(aaarg, Integer.MAX_VALUE));
		scroll.setPreferredSize(new Dimension(aaarg, 19));
		contentPane.add( scroll, BorderLayout.LINE_END );

		hwregs = new JTable(5,4);
		hwregs.setCellSelectionEnabled(false);
		hwregs.setColumnSelectionAllowed(false);
		hwregs.setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS);
		hwregs.setTableHeader(null);
		hwregs.setFont(MonoFont);
		scroll = new JScrollPane(hwregs);
		scroll.setMaximumSize(new Dimension(aaarg, Integer.MAX_VALUE));
		scroll.setPreferredSize(new Dimension(aaarg, 19*5));
		contentPane.add( scroll, BorderLayout.NORTH );

		scroll = new JScrollPane(new JLabel("Memory:"));
		scroll.setMaximumSize(new Dimension(aaarg, Integer.MAX_VALUE));
		scroll.setPreferredSize(new Dimension(aaarg, 19));
		contentPane.add( scroll, BorderLayout.LINE_END );

		JPanel memPanel = new JPanel();
		memPanel.setLayout(new BorderLayout());

		DefaultTableModel tableModel = new DefaultTableModel(8,8+2);
		tableModel.addTableModelListener(new EditMemTableModelListener());
		mem = new JTable();
		mem.setModel(tableModel);
#ifndef USE_GCJ
		mem.setSurrendersFocusOnKeystroke(true);
#endif
		mem.setTableHeader(null);
		mem.setFont(MonoFont);
		scroll = new JScrollPane(mem);
		scroll.setMaximumSize(new Dimension(aaarg, Integer.MAX_VALUE));
		scroll.setPreferredSize(new Dimension(aaarg, 131));
		//contentPane.add( scroll, BorderLayout.LINE_END );

		memScroller = new JScrollBar(java.awt.Adjustable.VERTICAL,0,100,0,0xFFFF + 37); // HAXHAXHAXHAXHAXHAXHAXHAXHAX
		memScroller.addAdjustmentListener(this);
		contentPane.add( memScroller, BorderLayout.EAST);

		//memPanel.add(scroll, BorderLayout.CENTER);
		memPanel.add(mem, BorderLayout.CENTER);
		memPanel.add(memScroller, BorderLayout.EAST);

		contentPane.add( memPanel, BorderLayout.LINE_END );

		scroll = new JScrollPane(new JLabel("Instructions:"));
		scroll.setMaximumSize(new Dimension(aaarg, Integer.MAX_VALUE));
		scroll.setPreferredSize(new Dimension(aaarg, 19));
		contentPane.add( scroll, BorderLayout.LINE_END );
		instrs = new JTable(16,1);
		instrs.setTableHeader(null);
		TableColumnModel m = instrs.getColumnModel();
		TableColumn c = m.getColumn(0);
		Color[] ccc=new Color[16];
		for(int i=0; i<16; ++i) ccc[i]=new Color(255,255,255);
		ccc[7]=new Color(222,222,255);
		MyCellRenderer r = new MyCellRenderer(ccc);
		r.setFont(MonoFont);
		c.setCellRenderer(r);

		scroll = new JScrollPane(instrs);
		scroll.setMaximumSize(new Dimension(aaarg, Integer.MAX_VALUE));
		scroll.setPreferredSize(new Dimension(aaarg, 259));
		contentPane.add( scroll, BorderLayout.LINE_END );
		scroll = new JScrollPane(new JLabel("Commands:"));
		scroll.setMaximumSize(new Dimension(aaarg, Integer.MAX_VALUE));
		scroll.setPreferredSize(new Dimension(aaarg, 19));
		contentPane.add( scroll, BorderLayout.LINE_END );
		cmds = new JTextField();
		cmds.addActionListener(this);
		cmds.setFont(MonoFont);
		scroll = new JScrollPane(cmds);
		scroll.setMaximumSize(new Dimension(aaarg, Integer.MAX_VALUE));
		scroll.setPreferredSize(new Dimension(aaarg, 20));
		contentPane.add( scroll, BorderLayout.LINE_END );


/*		regs1.addMouseListener(this);
		regs2.addMouseListener(this);
		mem.addMouseListener(this);*/

	}

	synchronized public void update() {
		if (!runner.isRunning() && CPU.canRun()) {
			updateRegisters();
			updateHWRegs();
			updateMemory();
			updateInstructions();
			memScroller.setValue(Math.min(memaddr, memScroller.getMaximum()));
		}
//  		System.out.println("update all");
	}

	public int[] oldHWRegs=new int[20];
	public int[] watches={-1, -1};
	public void updateHWRegs() {
// Status of VirtualBoy @Return from call at 4003: (Super Mario Land 2: 6 Golden Coins)
// [FF40h] LCDCONT=43h   [FF41h] LCDSTAT=02h
// [FF44h] CURLINE=84h   [FF45h] CMPLINE=00h
// [FF48h] SPR0PAL=D0h   [FF49h] SPR1PAL=38h
// [FF05h] TIMECNT=01h   [FF06h] TIMEMOD=00h
// [FF07h] TIMEFRQ=F8h   [FF04h] DIVREG=7Bh
// [FF02h] SIOCONT=7Eh   [FF01h] SIODATA=00h
// [FFFFh] ISWITCH=01h   [FF0Fh] IFLAGS=00h
// [FF4Bh,FF4Ah] Window Position at 7,136
// [FF43h,FF42h] Scroll Position at 0,0

	TableColumnModel m = hwregs.getColumnModel();
	TableColumn c;
	Color[] colors=new Color[5];
	colors[3]=Color.BLUE;
	int i=0, j=0, k=0;

	i=gui.cpu.read(0xFF40);
	hwregs.setValueAt(STRFORMAT("ff40: LCDC=$%02x",i), k,0);
	colors[k++]=( oldHWRegs[j]==i ? Color.WHITE : UpdateColor ); oldHWRegs[j++]=i;
	i=gui.cpu.read(0xFF48);
	hwregs.setValueAt(STRFORMAT("ff48: OBP0=$%02x",i), k,0);
	colors[k++]=( oldHWRegs[j]==i ? Color.WHITE : UpdateColor ); oldHWRegs[j++]=i;
	i=gui.cpu.read(0xFF07);
	hwregs.setValueAt(STRFORMAT("ff07:  TAC=$%02x",i), k,0);
	colors[k++]=( oldHWRegs[j]==i ? Color.WHITE : UpdateColor ); oldHWRegs[j++]=i;
	i=gui.cpu.read(0xFFFF);
	hwregs.setValueAt(STRFORMAT("ffff:   IE=$%02x",i), k,0);
	colors[k++]=( oldHWRegs[j]==i ? Color.WHITE : UpdateColor ); oldHWRegs[j++]=i;
	i=gui.cpu.read(0xFF43);
	hwregs.setValueAt(STRFORMAT("ff43:  SCX=$%02x",i), k,0);
	colors[k++]=( oldHWRegs[j]==i ? Color.WHITE : UpdateColor ); oldHWRegs[j++]=i;
	c = m.getColumn(0);
	c.setCellRenderer( new MyCellRenderer(colors) );

	colors=new Color[5]; k=0;
	i=gui.cpu.read(0xFF41);
	hwregs.setValueAt(STRFORMAT("ff41: STAT=$%02x",i), k,01);
	colors[k++]=( oldHWRegs[j]==i ? Color.WHITE : UpdateColor ); oldHWRegs[j++]=i;
	i=gui.cpu.read(0xFF49);
	hwregs.setValueAt(STRFORMAT("ff49: OBP1=$%02x",i), k,1);
	colors[k++]=( oldHWRegs[j]==i ? Color.WHITE : UpdateColor ); oldHWRegs[j++]=i;
	i=gui.cpu.read(0xFF04);
	hwregs.setValueAt(STRFORMAT("ff04:  DIV=$%02x",i), k,1);
// 	System.out.println("DIV: i="+i+" old="+oldHWRegs[j]);
	colors[k++]=( oldHWRegs[j]==i ? Color.WHITE : UpdateColor ); oldHWRegs[j++]=i;
	i=gui.cpu.read(0xFF0f);
	hwregs.setValueAt(STRFORMAT("ff0f:   IF=$%02x",i), k,1);
	colors[k++]=( oldHWRegs[j]==i ? Color.WHITE : UpdateColor ); oldHWRegs[j++]=i;
	i=gui.cpu.read(0xFF42);
	hwregs.setValueAt(STRFORMAT("ff42:  SCY=$%02x",i), k,1);
	colors[k++]=( oldHWRegs[j]==i ? Color.WHITE : UpdateColor ); oldHWRegs[j++]=i;
	c = m.getColumn(1);
	c.setCellRenderer( new MyCellRenderer(colors) );

	colors=new Color[5];k=0;
	i=gui.cpu.read(0xFF44);
	hwregs.setValueAt(STRFORMAT("ff44:   LY=$%02x",i), k,2);
	colors[k++]=( oldHWRegs[j]==i ? Color.WHITE : UpdateColor ); oldHWRegs[j++]=i;
	i=gui.cpu.read(0xFF05);
	hwregs.setValueAt(STRFORMAT("ff05: TIMA=$%02x",i), k,2);
	colors[k++]=( oldHWRegs[j]==i ? Color.WHITE : UpdateColor ); oldHWRegs[j++]=i;
	i=gui.cpu.read(0xFF02);
	hwregs.setValueAt(STRFORMAT("ff02:   SC=$%02x",i), k,2);
	colors[k++]=( oldHWRegs[j]==i ? Color.WHITE : UpdateColor ); oldHWRegs[j++]=i;
	i=gui.cpu.read(0xFF4b);
	hwregs.setValueAt(STRFORMAT("ff4b:   WX=$%02x",i), k,2);
	colors[k++]=( oldHWRegs[j]==i ? Color.WHITE : UpdateColor ); oldHWRegs[j++]=i;
	i=0x100;
	if(watches[0]>=0) {
		i=gui.cpu.read(watches[0]);
		hwregs.setValueAt(STRFORMAT("%04x:   w0=$%02x",watches[0],i), k,2);
	} else hwregs.setValueAt("w0 unset", k,2);
	colors[k++]=( oldHWRegs[j]==i ? Color.WHITE : UpdateColor ); oldHWRegs[j++]=i;
	c = m.getColumn(2);
	c.setCellRenderer( new MyCellRenderer(colors) );

	colors=new Color[5];k=0;
	i=gui.cpu.read(0xFF45);
	hwregs.setValueAt(STRFORMAT("ff45:  LYC=$%02x",i), k,3);
	colors[k++]=( oldHWRegs[j]==i ? Color.WHITE : UpdateColor ); oldHWRegs[j++]=i;
	i=gui.cpu.read(0xFF06);
	hwregs.setValueAt(STRFORMAT("ff06:  TMA=$%02x",i), k,3);
	colors[k++]=( oldHWRegs[j]==i ? Color.WHITE : UpdateColor ); oldHWRegs[j++]=i;
	i=gui.cpu.read(0xFF01);
	hwregs.setValueAt(STRFORMAT("ff01:   SB=$%02x",i), k,3);
	colors[k++]=( oldHWRegs[j]==i ? Color.WHITE : UpdateColor ); oldHWRegs[j++]=i;
	i=gui.cpu.read(0xFF4a);
	hwregs.setValueAt(STRFORMAT("ff4a:   WY=$%02x",i), k,3);
	colors[k++]=( oldHWRegs[j]==i ? Color.WHITE : UpdateColor ); oldHWRegs[j++]=i;
	i=0x100;
	if(watches[1]>=0) {
		i=gui.cpu.read(watches[1]);
		hwregs.setValueAt(STRFORMAT("%04x:   w1=$%02x",watches[1],i), k,3);
	} else hwregs.setValueAt("w1 unset", k,3);
	colors[k++]=( oldHWRegs[j]==i ? Color.WHITE : UpdateColor ); oldHWRegs[j++]=i;
	c = m.getColumn(3);
	c.setCellRenderer( new MyCellRenderer(colors) );
	}

	public void updateMemory() {
		memiseditable=false;
		int m=memaddr;
		for(int i=0; i<8; ++i) {
			mem.setValueAt(STRFORMAT("$%04x",m), i,0);
			for(int j=2; j<10; ++j) {
				mem.setValueAt(STRFORMAT("$%02x",(m<=0xffff)?gui.cpu.read(m++):0x1000), i,j);
			}
		}
		memiseditable=true;
	}

	private int seekBackOneInstruction(int pc) {
		int j=Math.max(pc-3,0);
		int i=deasm.instructionLength(j);
		if(i==3) return j;
		j=Math.max(pc-2,0);
		i=deasm.instructionLength(j);
		if(i==2) return j;
		j=Math.max(pc-1,0);
		i=deasm.instructionLength(j);
		if(i==1) return j;
		return j;
	}

	private void updateInstructions() {
		int pc=gui.cpu.PC;
		for(int i=0; i<7; ++i) {
			pc=seekBackOneInstruction(pc);
			instrs.setValueAt(instrs.getValueAt(i+1,0), i,0);
			}
		for(int i=0; i<16; ++i) {
			if (i==7) pc=gui.cpu.PC;
			instrs.setValueAt(deasm.simple_disasm(pc), i,0);
// 			instrs.setValueAt(deasm.disassemble(pc), i,0);
			pc+=deasm.instructionLength(pc);
		}
	}

	private void updateRegisters() { //TODO: Dit moet makkelijker kunnen ...
		TableColumnModel m = regs1.getColumnModel();
		TableColumn c;
//  		DefaultTableCellRenderer normal=new DefaultTableCellRenderer();
		Color[] colorsa = new Color[1];
		Color[] colorsb = new Color[1];
		colorsa[0]=UpdateColor;
		colorsb[0]=Color.WHITE;
		MyCellRenderer colored = new MyCellRenderer(colorsa);
		MyCellRenderer normal = new MyCellRenderer(colorsb);

		regs1.setValueAt(STRFORMAT("A=$%02x",gui.cpu.A), 0,0);
		c = m.getColumn(0);
		c.setCellRenderer( oldRegVal[0]==gui.cpu.A ? normal : colored );
		oldRegVal[0]=gui.cpu.A;

		regs1.setValueAt(STRFORMAT("B=$%02x",gui.cpu.B), 0,1);
		c = m.getColumn(1);
		c.setCellRenderer( oldRegVal[1]==gui.cpu.B ? normal : colored );
		oldRegVal[1]=gui.cpu.B;

		regs1.setValueAt(STRFORMAT("C=$%02x",gui.cpu.C), 0,2);
		c = m.getColumn(2);
		c.setCellRenderer( oldRegVal[2]==gui.cpu.C ? normal : colored );
		oldRegVal[2]=gui.cpu.C;

		regs1.setValueAt(STRFORMAT("D=$%02x",gui.cpu.D), 0,3);
		c = m.getColumn(3);
		c.setCellRenderer( oldRegVal[3]==gui.cpu.D ? normal : colored );
		oldRegVal[3]=gui.cpu.D;

		regs1.setValueAt(STRFORMAT("E=$%02x",gui.cpu.E), 0,4);
		c = m.getColumn(4);
		c.setCellRenderer( oldRegVal[4]==gui.cpu.E ? normal : colored );
		oldRegVal[4]=gui.cpu.E;

		regs1.setValueAt(STRFORMAT("F=$%02x",gui.cpu.F), 0,5);
		c = m.getColumn(5);
		c.setCellRenderer( oldRegVal[5]==gui.cpu.F ? normal : colored );
// 		oldRegVal[5]=gui.cpu.F;

		regs1.setValueAt(STRFORMAT("H=$%02x",gui.cpu.H), 0,6);
		c = m.getColumn(6);
		c.setCellRenderer( oldRegVal[6]==gui.cpu.H ? normal : colored );
		oldRegVal[6]=gui.cpu.H;

		regs1.setValueAt(STRFORMAT("L=$%02x",gui.cpu.L), 0,7);
		c = m.getColumn(7);
		c.setCellRenderer( oldRegVal[7]==gui.cpu.L ? normal : colored );
		oldRegVal[7]=gui.cpu.L;

		m = regs2.getColumnModel();
		regs2.setValueAt(STRFORMAT("PC=$%04x",gui.cpu.PC), 0,0);
		oldRegVal[8]=gui.cpu.PC;

		regs2.setValueAt(STRFORMAT("SP=$%04x",gui.cpu.SP), 0,1);
		c = m.getColumn(1);
		c.setCellRenderer( oldRegVal[9]==gui.cpu.SP ? normal : colored);
		oldRegVal[9]=gui.cpu.SP;

		String flags = "F=";
		flags += (( gui.cpu.F & gui.cpu.ZF_Mask ) == gui.cpu.ZF_Mask )?"Z ":"z ";
		flags += (( gui.cpu.F & gui.cpu.NF_Mask ) == gui.cpu.NF_Mask )?"N ":"n ";
		flags += (( gui.cpu.F & gui.cpu.HC_Mask ) == gui.cpu.HC_Mask )?"H ":"h ";
		flags += (( gui.cpu.F & gui.cpu.CF_Mask ) == gui.cpu.CF_Mask )?"C ":"c ";
		regs2.setValueAt(flags, 0,3);
		c = m.getColumn(3);
		c.setCellRenderer( oldRegVal[5]==gui.cpu.F ? normal : colored);
		oldRegVal[5]=gui.cpu.F;

		/*0=VBlANK
			1=LCD STAT
			2=Timer
			3=Serial
			4=Joypad*/

		//0 98765 43210
		//        4
		int intstat=(gui.cpu.IOP[0x0f]&0x1f)|((gui.cpu.IE&0x1f)<<5)|(gui.cpu.IME?1<<10:0);
		String ime=((intstat&(1<<10))!=0?"I ":"i ");
		ime+=(gui.cpu.IE       &(1<<4))!=0?"J":"j";
		ime+=(gui.cpu.IOP[0x0f]&(1<<4))!=0?"+":"-";
		ime+=" ";
		ime+=(gui.cpu.IE       &(1<<3))!=0?"S":"s";
		ime+=(gui.cpu.IOP[0x0f]&(1<<3))!=0?"+":"-";
		ime+=" ";
		ime+=(gui.cpu.IE       &(1<<2))!=0?"T":"t";
		ime+=(gui.cpu.IOP[0x0f]&(1<<2))!=0?"+":"-";
		ime+=" ";
		ime+=(gui.cpu.IE       &(1<<1))!=0?"L":"l";
		ime+=(gui.cpu.IOP[0x0f]&(1<<1))!=0?"+":"-";
		ime+=" ";
		ime+=(gui.cpu.IE       &(1<<0))!=0?"V":"v";
		ime+=(gui.cpu.IOP[0x0f]&(1<<0))!=0?"+":"-";
 		regs2.setValueAt(ime, 0,2);
 		c = m.getColumn(2);
		c.setCellRenderer( oldRegVal[10]==intstat ? normal : colored);
 		oldRegVal[10]=intstat;
	}

	public void prepareParser(){
					parser.removeVariables();
				parser.addVariable("A", oldRegVal[0]);
				parser.addVariable("B", oldRegVal[1]);
				parser.addVariable("C", oldRegVal[2]);
				parser.addVariable("D", oldRegVal[3]);
				parser.addVariable("E", oldRegVal[4]);
				parser.addVariable("F", oldRegVal[5]);
				parser.addVariable("H", oldRegVal[6]);
				parser.addVariable("L", oldRegVal[7]);
				parser.addVariable("PC", oldRegVal[8]);
				parser.addVariable("SP", oldRegVal[9]);
				parser.addVariable("HL", oldRegVal[7]|(oldRegVal[6]<<8));
				parser.addVariable("M", memaddr);
				parser.addVariable("a", oldRegVal[0]);
				parser.addVariable("b", oldRegVal[1]);
				parser.addVariable("c", oldRegVal[2]);
				parser.addVariable("d", oldRegVal[3]);
				parser.addVariable("e", oldRegVal[4]);
				parser.addVariable("f", oldRegVal[5]);
				parser.addVariable("h", oldRegVal[6]);
				parser.addVariable("l", oldRegVal[7]);
				parser.addVariable("pc", oldRegVal[8]);
				parser.addVariable("sp", oldRegVal[9]);
				parser.addVariable("hl", oldRegVal[7]|(oldRegVal[6]<<8));
				parser.addVariable("m", memaddr);
				parser.addVariable("M", memaddr);
				parser.addVariable("q", gui.cpu.read(memaddr));
				parser.addVariable("Q", gui.cpu.read(memaddr));
	}

	private void createAndShowGUI() {
		JFrame.setDefaultLookAndFeelDecorated( true );
		JFrame frame = new JFrame( "JGameBoy Emulator DEBUGGER" );
		frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
		//Set up the content pane and add swing components to it
		addComponentsToPane( frame.getContentPane() );
		frame.pack();
		frame.setLocation(00, 0);
		frame.setSize(new Dimension(520,720));
		frame.setVisible( true );
		//frame.addKeyListener(this); TODO: Shortcut keys
	}

	public void actionPerformed( ActionEvent e ) {
		JTextField f = ( JTextField )( e.getSource() );
		if(f==cmds) {
			int i=0;
			String s=cmds.getText().trim();
			cmds.selectAll();
			i=s.indexOf("=");
			if(i>-1) { //assignment
				String l = s.substring(0,i).trim();
				updateRegisters(); //sets the variables
				prepareParser();
// 				System.out.println("memaddr="+memaddr);
				int v = parser.Evaluate(s.substring(i+1).trim());
				if(!parser.parseError) {
					if(l.equalsIgnoreCase("a")){
						gui.cpu.A=v&0xFF;
						update();
					}
					else if(l.equalsIgnoreCase("b")){
						gui.cpu.B=v&0xFF;
						update();
					}
					else if(l.equalsIgnoreCase("c")){
						gui.cpu.C=v&0xFF;
						update();
					}
					else if(l.equalsIgnoreCase("d")){
						gui.cpu.D=v&0xFF;
						update();
					}
					else if(l.equalsIgnoreCase("e")){
						gui.cpu.E=v&0xFF;
						update();
					}
					else if(l.equalsIgnoreCase("f")){
						gui.cpu.F=v&0xFF;
						update();
					}
					else if(l.equalsIgnoreCase("h")){
						gui.cpu.H=v&0xFF;
						update();
					}
					else if(l.equalsIgnoreCase("l")){
						gui.cpu.L=v&0xFF;
						update();
					}
					else if(l.equalsIgnoreCase("hl")){
						gui.cpu.H=(v>>8)&0xFF;
						gui.cpu.L=v&0xFF;
						update();
					}
					else if(l.equalsIgnoreCase("pc")){
						gui.cpu.PC=v&0xFFFF;
						update();
					}
					else if(l.equalsIgnoreCase("sp")){
						gui.cpu.SP=v&0xFFFF;
						update();
					}
					else if(l.equalsIgnoreCase("m")){
						memaddr=v&0xFFFF;
						update();
					}
					else if(l.equalsIgnoreCase("af")){
						gui.cpu.A=(v>>8)&0xFF;
						gui.cpu.F=v&0xFF;
						update();
					}
					else if(l.equalsIgnoreCase("bc")){
						gui.cpu.B=(v>>8)&0xFF;
						gui.cpu.C=v&0xFF;
						update();
					}
					else if(l.equalsIgnoreCase("de")){
						gui.cpu.D=(v>>8)&0xFF;
						gui.cpu.E=v&0xFF;
						update();
					}
					else if(l.equalsIgnoreCase("bpi")){ //break on interrupt i
						runner.setBreakPoint(v);
						runner.resume();
					}
					else if(l.equalsIgnoreCase("bpm")){ //break on memory access
						bpm = v;
					}
					else if(l.equalsIgnoreCase("w")) { //break on memory change only
						runner.setWatchPoint(v);
					}
					else if(l.equalsIgnoreCase("w0")){
						watches[0] = v;
						update();
					}
					else if(l.equalsIgnoreCase("w1")){
						watches[1] = v;
						update();
					}
					else {
						System.out.println("Cannot assign `"+v+"' to `"+l+"'");
					}
				}
				s="-";
			}
			if(s.equals("s")) {
				gui.cpu.nextinstruction();
				update();
			}
			if(s.equals("reset")) {
				gui.cpu.reset();
				update();
			}
			if(s.equals("so")) {
				if (!runner.isRunning()) {
					runner.setBreakPoint(gui.cpu.PC + deasm.instructionLength(gui.cpu.PC));
					runner.resume();
				}
			}
#ifdef ENABLE_RECOMPILER
			if(s.equals("rc")) {
				runner.suspend();
				CPURecompiler.testing = 0;
				if (CPU.PC < 0x4000) {
					CPU.rccache0[CPU.PC] = CPURecompiler.doRecompile(CPU.PC);
				}
				else if (CPU.PC < 0x8000) {
					CPU.rccachex[CPU.PC-0x4000] = CPURecompiler.doRecompile(CPU.PC);
				}
			}
#endif
			if(s.charAt(0)=='i') {
				String ss = s.substring( s.lastIndexOf(" ") + 1);
				if( ss.charAt(0)=='$' )
					runner.setBreakInstr(Integer.parseInt( ss.substring(1), 16 ));
			}
			if(s.charAt(0)=='p') {
				runner.setRunFor(parser.StrToInt(s.substring(1)));
				runner.resume();
			}
			if(s.charAt(0)=='g') {
				runner.resume();
			}
			if(s.charAt(0)=='b') {
				if (runner.isRunning()) {
					if (logwriter != null) {
						try {
							logwriter.flush();
						}
						catch (java.io.IOException e2) {
							System.out.println("Error flushing logfile:" + e2.getMessage());
							logwriter = null;
						}
					}
					runner.suspend();
				}
			}
			if(s.charAt(0)=='r') {
				try {
					if (!runner.isRunning()) {
						String ss = s.substring( s.lastIndexOf(" ") + 1);
						if( ss.charAt(0)=='$' ) {
							runner.setBreakPoint(Integer.parseInt( ss.substring(1), 16 ));
							runner.resume();
						}
					}
				}
				catch ( NumberFormatException ee ) {
						System.out.println( ee.getMessage() + " is not a valid format for an integer." );
				}
				//memaddr = Integer.valueOf(s.substring( s.lastIndexOf(" "))).intValue();
			}
			if(s.charAt(0)=='c') {
				try {
					if (!runner.isRunning()) {
						String ss = s.substring( s.lastIndexOf(" ") + 1);
						runner.setInstrStop(Integer.parseInt( ss.substring(0), 10 ));
					}
				}
				catch ( NumberFormatException ee ) {
						System.out.println( ee.getMessage() + " is not a valid format for an integer." );
				}
				//memaddr = Integer.valueOf(s.substring( s.lastIndexOf(" "))).intValue();
			}
		}
		else {
			System.out.println( "Action event i an instance of " + getClassName( f ));
		}
	}

	public void itemStateChanged( ItemEvent e ) {
		JMenuItem source = ( JMenuItem )( e.getSource() );
		System.out.println("Menu Item source: " + source.getText() + " (an instance of " + getClassName( source ) + ")"	+ "\n"
		                   + "    State of check Box: " + (( e.getStateChange() == ItemEvent.SELECTED ) ? "selected":"unselected" ));
	}

	public void keyTyped(KeyEvent e) {
		System.out.println("keyTyped");
	}

	public void keyPressed(KeyEvent e) {
		System.out.println("DEBUGGER: keyPressed");
	}

	public void keyReleased(KeyEvent e) {
		System.out.println("DEBUGGER: keyReleased" + e.getKeyCode());
	}

	// Returns the class name, no package info
	protected static String getClassName( Object o ) {
		String classString = o.getClass().getName();
		int dotIndex = classString.lastIndexOf( "." );
		return classString.substring( dotIndex+1 );	//Returns only Class name
	}
}
#else
public class Debugger { } //DUMMY CLASS FOR 1.4.2
#endif
