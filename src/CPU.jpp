#include "Global.inc"
#include "SaveLoad.inc"
#include "CPU.inc"

#ifdef USE_JAVA_MOBILE
#define VideoController MobileVideoController
#endif

#ifndef USE_JAVA_MOBILE
import java.net.*;
import java.util.zip.*;
import java.util.ArrayList;
#endif

public final class CPU {
	static class DummyCPURunBlock implements CPURunBlock {
		public int execute() { ASSERT(false); return 0;};
	}
		public static CPU singleton = null;

		//FLAGS
		public static final int ZF_Shift = 7;
		public static final int NF_Shift = ZF_Shift - 1;
		public static final int HC_Shift = NF_Shift - 1;
		public static final int CF_Shift = HC_Shift - 1;
		public static final int ZF_Mask  = 1 << ZF_Shift;
		public static final int NF_Mask  = 1 << NF_Shift;
		public static final int HC_Mask  = 1 << HC_Shift;
		public static final int CF_Mask  = 1 << CF_Shift;

		public static long TotalInstrCount = 0;
		public static long TotalCycleCount = 0;

		public static int A = 0;
		public static int B = 1;
		public static int C = 2;
		public static int D = 3;
		public static int E = 4;
		public static int F = 5;
		public static int H = 6;
		public static int L = 7;

		public static int[] IOP = new int[0x80]; //IO Ports
		public static int[] HRAM = new int[0x7f]; //HighRAM
		public static BTYPE[][] WRAM = new BTYPE[0x08][0x1000]; //8x4k InternalRAM
		public static BTYPE[] FWRAM = WRAM[0]; // first WRAM bank
		public static int CurrentWRAMBank=1;

		public static boolean doublespeed = false;
		public static boolean speedswitch = false;

		public static int DIVcntdwn = 0;
		public static int TIMAcntdwn = 0;

		public static int globalPC = 0;
		public static int localPC = 0;

		public static int getPC() {
			return globalPC + localPC;
		}

		public static void setPC(int newPC) {
			globalPC = 0;
			localPC = newPC;
		}

		public static void pushPC() {
			DO_PUSH_OLD(getPC());
			/*
			int pc = globalPC + localPC;
			if (SP > 0xC001 && (SP >> 13) == 6) {
				FWRAM[--SP - 0xC000] = I2B(pc>>8);
				FWRAM[--SP - 0xC000] = I2B(pc&0xff);
			} else {
				SP=(SP-1)&0xffff; write(SP, pc >> 8);
				SP=(SP-1)&0xffff; write(SP, pc&0xff);
			}
			*/
		}

		public static void popPC() {
			setPC(POP);
			/*
			if (SP < 0xCFFF && (SP >> 13) == 6) {
				setPC(
					   B2I(FWRAM[SP++ - 0xC000])
					+ (B2I(FWRAM[SP++ - 0xC000])<<8)
				);
			} else {
				setPC(read(SP++) + (read(SP++) << 8));
			}
			*/
		}

		//public static int PC=0;         ///< Program counter
		public static int SP=0;         ///< Stack Pointer
		public static int IE=0;         ///< Interrupt Enable (allowed interrupts)
		public static boolean IME=true; ///< Interrupt Master Enable
		public static boolean halted=false;
		public static boolean delayed_halt=false;
		public static boolean halt_fail_inc_pc=false;

		//IO
		public static int KeyStatus=0; //bitmask, low 4=direction, upper 4=start,select,a,b, inverted from GameBoy POV
		public static int GUIKeyStatus=0;
		public static int RemoteKeyStatus=0;
		public static boolean useRemoteKeys = false;
		public static int keyBounce = 0;
		public static int keyBounceWaitNext;

		public static boolean keyHistoryEnabled;
		public static IntVector keyHistory;
		public static int lastKeyChange;
		public static int playbackHistoryIndex = -1;

		static boolean BIOS_enabled = false;

		//CPU Class variables
		public static Cartridge cartridge;// = new Cartridge("Pokemon Blue.gb");
		public static int lastException=0;
		#ifndef USE_JAVA_MOBILE
			public static Disassembler deasm;
		#endif
		public static VideoController VC;
		public static AudioController AC;
		static int hblank_dma_state;
		//Debug helpers
		public static int last_memory_access=-1;
		public static int last_memory_access_internal=-1;

		public CPU() {
			PRINTFREEMEM("CPU() - 1");
			if (singleton != null) {
				PRINTLN("WARNING: trying to instantiate second instance of CPU singleton class");
				//int x[]=null;
				//x[0] = 0;
			}
			singleton = this;
			#ifndef USE_JAVA_MOBILE
				deasm = new Disassembler(this, Disassembler.SIMPLE_DISASSEMBLY);
			#endif
			PRINTFREEMEM("CPU() - 2");
			VC = new VideoController(this, 160, 144);
			PRINTFREEMEM("CPU() - 3");
			AC = new AudioController(this);
			PRINTFREEMEM("CPU() - 4");
			keyHistory = new IntVector();
			PRINTFREEMEM("CPU() - 5");
			cartridge = null;
			PRINTFREEMEM("CPU() - 6");
			//CPU.rccache[0x2cbb] = CPURecompiler.Recompile(0x2cbb);
		}

		public static void loadCartridge(Cartridge acartridge) {
			cartridge = acartridge;

			reset(false);

			//for (int i = 0; i < 0x4000; ++i)
			//	rccachea[0][i] = CPURecompiler.doRecompile(i);
		}

		public static boolean canRun() {
			return (cartridge != null);
		}

		public static String first_save_string = new String();
		public static String last_save_string = new String();

		static SAVELOAD_FUNCTION {
			SL_IF_VERSION( 0,  9) first_save_string = "unknown";
			SL_IF_VERSION( 0,  9) last_save_string = "unknown";
			SL_IF_VERSION(10, -1) SL_STRING(first_save_string);
			if (SL_SAVE) last_save_string = Version.str;
			SL_IF_VERSION(10, -1) SL_STRING(last_save_string);

			SL_IF_VERSION( 1, -1) {
				SL_UINT8(B);
				SL_UINT8(C);
				SL_UINT8(D);
				SL_UINT8(E);
			}
			SL_UINT8(H);
			SL_UINT8(L);
			SL_UINT8(F);
			SL_UINT8(A);
			SL_ARR(UINT8, IOP, 0x80);
			SL_ARR(UINT8, HRAM, 0x7f);
			SL_IF_VERSION( 0,  0) {
				for (int i = 0; i < 8; ++i) {
					SL_ARR(UINT8B, WRAM[i], 0x1000);
					//SL_SKIP(UINT8, 0x10000 - 0x1000);
				}
			}
			SL_IF_VERSION( 1, -1) SL_ARR_2D(UINT8B, WRAM, 0x08, 0x1000);
			SL_INT(CurrentWRAMBank);
			SL_BOOL(doublespeed);
			SL_BOOL(speedswitch);
			SL_INT(DIVcntdwn);
			SL_INT(TIMAcntdwn);
			SL_IF_VERSION( -1, 14) SL_SKIP(INT, 1); //SL_INT(LCDCcntdwn);
			int pc = getPC();
			SL_UINT16(pc);
			setPC(pc);
			SL_UINT16(SP);
			SL_UINT8(IE);
			SL_BOOL(IME);
			SL_BOOL(halted);
			SL_IF_VERSION(16, -1) SL_BOOL(delayed_halt);
			SL_IF_VERSION(16, -1) SL_BOOL(halt_fail_inc_pc);
			SL_IF_VERSION( 0,  2) SL_SKIP(UINT8, 1); //SL_UINT8(DirectionKeyStatus);
			SL_IF_VERSION( 0,  2) SL_SKIP(UINT8, 1); //SL_UINT8(ButtonKeyStatus);
			SL_IF_VERSION(11, -1) SL_UINT8(KeyStatus);
			SL_IF_VERSION(12, -1) SL_INT(keyBounce);
			SL_IF_VERSION(12, -1) SL_INT(keyBounceWaitNext);
			SL_INT(lastException);
			SL_BOOL(BIOS_enabled);

			SL_OBJ(cartridge);
			SL_OBJ(VC);
			SL_IF_VERSION( 2, -1) SL_OBJ(AC);

			SL_IF_VERSION( 3, 13) SL_SKIP(UINT8, 1); // vcmode

			SL_IF_VERSION( 0,  8) SL_INT(TotalInstrCount);
			SL_IF_VERSION( 0,  8) SL_INT(TotalCycleCount);
			SL_IF_VERSION( 9, -1) SL_LONG(TotalInstrCount);
			SL_IF_VERSION( 9, -1) SL_LONG(TotalCycleCount);

			SL_IF_VERSION( 4, 16) SL_SKIP(UINT8, 1); //SL_UINT8(hw_ilines);

			SL_IF_VERSION( 7, -1) SL_UINT8(hblank_dma_state);

			SL_IF_VERSION(13, -1) {
				if (SL_SAVE && playbackHistoryIndex != -1) {
					boolean t = true;
					SL_BOOL(t);
					SL_INT(lastKeyChange);
					int olen = keyHistory.size();
					keyHistory.setSize(playbackHistoryIndex);
					SL_OBJ(keyHistory);
					keyHistory.setSize(olen);
				} else {
					SL_BOOL(keyHistoryEnabled);
					if (keyHistoryEnabled) {
						SL_INT(lastKeyChange);
						SL_OBJ(keyHistory);
					}
				}
				if (SL_LOAD) playbackHistoryIndex = -1;
			} else
				keyHistoryEnabled = false;

			if (SL_LOAD) {
				refreshMemMap();
			}
		}

		public static void saveState(DataOutputStream dostream)
		throws IOException
		{
#ifndef USE_JAVA_MOBILE
			int saveversion = SL_SAVE_VERSION; //change when changing savestate format
			dostream.writeInt(SL_MAGIX);
			dostream.writeInt(saveversion);
			int compressionmethod = 1; // GZIP compression
			dostream.writeInt(compressionmethod);
			DeflaterOutputStream zostream = null;
			switch (compressionmethod) {
				// no compression
				case 0: break;
				// GZIP compression
				case 1: {
					zostream = new GZIPOutputStream(dostream);
					dostream = new DataOutputStream(zostream);
				}; break;
			}
			stateSaveLoad(true, saveversion, dostream, null);
			if (zostream != null) {
				dostream.flush();
				zostream.finish();
			}
#endif
		}

		public static void loadState(DataInputStream distream)
		throws IOException
		{
#ifndef USE_JAVA_MOBILE
			int loadversion;
			int magix = distream.readInt();
			if (magix != SL_MAGIX) {
				// throw new IOException("save state not valid");
				// hax! 1 in 0xffffffff chance this goes wrong!
				loadversion = 0;
				B = (magix >> 24) & 0xff;
				C = (magix >> 16) & 0xff;
				D = (magix >>  8) & 0xff;
				E = (magix >>  0) & 0xff;
			}
			else
				loadversion = distream.readInt();
			if (loadversion < SL_LOAD_MIN_VERSION)
				throw new IOException("save state too old");
			if (loadversion > SL_LOAD_MAX_VERSION)
				throw new IOException("save state too new");
			if (loadversion != SL_SAVE_VERSION)
				PRINTLN("loading state with old version:"+loadversion);

			int compressionmethod = 0;
			if (loadversion >= SL_LOAD_COMPRESS_VERSION)
				compressionmethod = distream.readInt();
			switch (compressionmethod) {
				// no compression
				case 0: break;
				// GZIP compression
				case 1: distream = new DataInputStream(new GZIPInputStream(distream)); break;
			}
			stateSaveLoad(false, loadversion, null, distream);
#endif
		}

		public static BTYPE[][] rMemMap = new BTYPE[0x10][];
		public static BTYPE[][] wMemMap = new BTYPE[0x10][];

		public static boolean isCGB() {
			//PRINTLN("** <INSERT DESCRIPTIVE TEXT HERE> ** [0x0143] = " + read(0x0143));
			if(cartridge==null) return false;
			return (read(0x0143) == 0x80) || (read(0x0143) == 0xC0);
		}

		public static int hblank_dma() {
			ASSERT((VC.STAT&2)==0);
			if (hblank_dma_state < (1<<7)) return 0;

			int src = ((IOP[0x51]<<8)|IOP[0x52]) & 0xfff0;
			int dst = (((IOP[0x53]<<8)|IOP[0x54]) & 0x1ff0) | 0x8000;
			int len = 16;

			for (int i = 0; i < len; ++i)
				VC.write(dst++, read(src++));

			IOP[0x51] = src >> 8;
			IOP[0x52] = src & 0xF0;
			IOP[0x53] = 0x1F & (dst >> 8);
			IOP[0x54] = dst & 0xF0;
			--IOP[0x55];
			--hblank_dma_state;

			return 8;
		}

		public static void refreshMemMap() {
			if (BIOS_enabled)
				rMemMap[0x0] = null;
			else
				rMemMap[0x0] = cartridge.MM_ROM[0];
			// cartridge ROM bank 0 (read only, write has special functions)
			rMemMap[0x1] = cartridge.MM_ROM[1];
			rMemMap[0x2] = cartridge.MM_ROM[2];
			rMemMap[0x3] = cartridge.MM_ROM[3];

#ifdef ENABLE_RECOMPILER
			rccachex = rccachea[cartridge.CurrentROMBank];
#endif

			// cartridge ROM switchable bank (read only, write has special functions)
			rMemMap[0x4] = cartridge.MM_ROM[(cartridge.CurrentROMBank<<2)|0];
			rMemMap[0x5] = cartridge.MM_ROM[(cartridge.CurrentROMBank<<2)|1];
			rMemMap[0x6] = cartridge.MM_ROM[(cartridge.CurrentROMBank<<2)|2];
			rMemMap[0x7] = cartridge.MM_ROM[(cartridge.CurrentROMBank<<2)|3];

			// 0x8 // TODO: somehow fit VRAM in here, difficult cause its
			// 0x9 //       not in 0xFFF chunks (and VC doesnt want it that way)

			// cartridge RAM (can be switchable)
			if(cartridge.MBC!=2) { //MBC2 should not have any RAM (except built in 512x4bits)
				rMemMap[0xA] = wMemMap[0xA] = cartridge.MM_RAM[(cartridge.CurrentRAMBank<<1)|0];
				rMemMap[0xB] = wMemMap[0xB] = cartridge.MM_RAM[(cartridge.CurrentRAMBank<<1)|1];
			}
			else { //force reading through Cartridge
				rMemMap[0xA] = wMemMap[0xA] = null;
				rMemMap[0xB] = wMemMap[0xB] = null;
			}

			// WRAM, bank 0 and a switchable bank
			rMemMap[0xC] = wMemMap[0xC] = WRAM[0];
			rMemMap[0xD] = wMemMap[0xD] = WRAM[CurrentWRAMBank];

			// echo..
			rMemMap[0xE] = wMemMap[0xE] = rMemMap[0xC];

			// 0xF // lots of special stuff here...
		}

		public static int read(int index) {
			last_memory_access_internal=index;
			BTYPE mm[]=rMemMap[index>>12];
			if (mm!=null)
				return B2I(mm[index&0x0FFF]);
			return read_slow(index);
		}

		public static int read_slow(int index) {
			/* Memorymap:
			 * 0000-3FFF   16KB ROM Bank 00     (in cartridge, fixed at bank 00)
			 * 4000-7FFF   16KB ROM Bank 01..NN (in cartridge, switchable bank number)
			 * 8000-9FFF   8KB Video RAM (VRAM) (switchable bank 0-1 in CGB Mode)
			 * A000-BFFF   8KB External RAM     (in cartridge, switchable bank, if any)
			 * C000-CFFF   4KB Work RAM Bank 0 (WRAM)
			 * D000-DFFF   4KB Work RAM Bank 1 (WRAM)  (switchable bank 1-7 in CGB Mode)
			 * E000-FDFF   Same as C000-DDFF (ECHO)    (typically not used)
			 * FE00-FE9F   Sprite Attribute Table (OAM)
			 * FEA0-FEFF   Not Usable
			 * FF00-FF7F   I/O Ports
			 * FF80-FFFE   High RAM (HRAM)
			 * FFFF        Interrupt Enable Register
			 */

			int b;
			last_memory_access_internal=index;
			ASSERT(index>=0 && index <=0xffff);

			if (index < 0x4000) { //16KB ROM Bank 00     (in cartridge, fixed at bank 00)
				if (index < 0x100) {
			PRINTLN("read_slow:"+index);
					b = cartridge.BIOS_ROM[index];
				    //PRINTLN("reading from BIOS rom");
				}
				else if (index == 0x100) {
// 					PRINTLN("reading from 0x100, disableing BIOS rom (PC="+PC+")");
					BIOS_enabled = false;
					//reset(false); // reset without forcing mono mode
					refreshMemMap();
					VC.isCGB = BIOS_enabled?false:isCGB();
					A=VC.isCGB?0x11:0x01; // CGB sets this to 0x11 instead of 0x01 for GB
					b = read(index);
				}
				else {
					b = cartridge.MM_ROM[0][index];
					//PRINTLN("reading from non-BIOS rom");
				}
			}
			else if(index < 0x8000) { //16KB ROM Bank 01..NN (in cartridge, switchable bank number)
				b=cartridge.read(index);
			}
			else if(index < 0xa000) { //8KB Video RAM (VRAM) (switchable bank 0-1 in CGB Mode)
				b=VC.read(index);
			}
			else if(index < 0xc000) { //8KB External RAM     (in cartridge, switchable bank, if any)
				b=cartridge.read(index);
			}
			else if(index < 0xd000) { //4KB Work RAM Bank 0 (WRAM)
				b=B2I(WRAM[0][index-0xc000]);
			}
			else if(index < 0xe000) { //4KB Work RAM Bank 1 (WRAM)  (switchable bank 1-7 in CGB Mode)
				b=B2I(WRAM[CurrentWRAMBank][index-0xd000]);
			}
			else if(index < 0xfe00) { //Same as C000-DDFF (ECHO)    (typically not used)
				b=read(index-0x2000);
			}
			else if(index < 0xfea0) { //Sprite Attribute Table (OAM)
				b=VC.read(index);
			}
			else if(index < 0xff00) { //Not Usable
				PRINTLN("WARNING: CPU.read(): Read from unusable memory (0xfea0-0xfeff)");
				b=0;
			}
			else if(index < 0xff80) { //I/O Ports
				switch(index) {
					case 0xff00: // FF00 - P1/JOYP - Joypad (R/W)
						b=(IOP[index-0xff00]&0x30)|0xc0;
						if((b&(1<<4))==0) { // Direction keys, 0=select
							b|=(KeyStatus&0x0f);
						}
						if((b&(1<<5))==0) { // Buttons, 0=select
							b|=(KeyStatus>>4);
						}
						b^=0x0f;
						break;
					case 0xff01: // SB - Serial transfer data (R/W)
					case 0xff02: // SC - Serial Transfer Control (R/W)
						//yes fallthrough works here
					//case 0xff03 ! dont break above ports
					case 0xff04: // DIV
					case 0xff05: // TIMA
					case 0xff06: // TMA
					case 0xff07: // TAC
						b = IOP[index-0xff00];
						break;
					case 0xff0f: // FF0F - IF - Interrupt Flag (R/W)
						b = IOP[0x0f];
						break;
					/* AUDIO IO PORTS */
					case 0xff10: case 0xff11: case 0xff12: case 0xff13: case 0xff14: case 0xff15: case 0xff16: case 0xff17:
					case 0xff18: case 0xff19: case 0xff1a: case 0xff1b: case 0xff1c: case 0xff1d: case 0xff1e: case 0xff1f:
					case 0xff20: case 0xff21: case 0xff22: case 0xff23: case 0xff24: case 0xff25: case 0xff26: case 0xff27:
					case 0xff28: case 0xff29: case 0xff2a: case 0xff2b: case 0xff2c: case 0xff2d: case 0xff2e: case 0xff2f:
					case 0xff30: case 0xff31: case 0xff32: case 0xff33: case 0xff34: case 0xff35: case 0xff36: case 0xff37:
					case 0xff38: case 0xff39: case 0xff3a: case 0xff3b: case 0xff3c: case 0xff3d: case 0xff3e: case 0xff3f:
						b = AC.read(index);
						break;
					case 0xff40: // LCDC register
						b = VC.LCDC;
						break;
					case 0xff41: // FF41 - STAT - LCDC Status (R/W)
						//FIXME: Needs verification: (see VC.render() notes on disabling the LCD)
						//       (I don't really believe this though ...)
						b = ((VC.LCDC&0x80)==0) ? (VC.STAT&0x7c)|0x00 : VC.STAT; //Stay in hblank when disabled
						b = VC.STAT;
						break;
					case 0xff42: // SCY
						b = VC.SCY;
						break;
					case 0xff43: // SCX// 			PRINTLN("ERROR: not using memmap "+ index);
						b = VC.SCX;
						break;
					case 0xff44: // LY
						/* FIXME: Needs verification: (see VC.render() notes on disabling the LCD)
						 *       (I don't really believe this though as it appears to break at least
						 *       Escape From Camp Deadly and Street Fighter II ...)
						 */
						b = ((VC.LCDC&0x80)==0) ? 0 : VC.LY; //Stay on scanline 0 when disabled
// 						b = VC.LY;
						break;
					case 0xff45: // LYC
						b = VC.LYC;
						break;
					case 0xff47: // BGP - BG Palette Data (R/W) - Non CGB Mode Only
					case 0xff48: // OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only
					case 0xff49: // OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only
						b = IOP[index-0xff00];
						break;
					case 0xff4a: // WY
						b = VC.WY;
						break;
					case 0xff4b: // WX
						b = VC.WX;
						break;
					case 0xff4d: // KEY1 - CGB Mode Only - Prepare Speed Switch
						b = doublespeed ? (1<<7) : 0;
						break;
					case 0xff4f: // VRAM bank nr
						b = VC.getcurVRAMBank();
						break;
					case 0xff51: // FF51 - HDMA1 - CGB Mode Only - New DMA Source, High
					case 0xff52: // FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low
					case 0xff53: // FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High
					case 0xff54: // FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low
					case 0xff55: // FF55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start
						b = IOP[index-0xff00];
						break;
					case 0xff68: // BGPI
						b = VC.BGPI;
						break;
					case 0xff69: // BGPD
						b = VC.getBGColData();
						break;
					case 0xff6a: // OBPI
						b = VC.OBPI;
						break;
					case 0xff6b: // OBPD
						b = VC.getOBColData();
						break;
					case 0xff70: // SVBK - CGB Mode Only - WRAM Bank
						b = CurrentWRAMBank;
						break;
					/** some 'undocumented' stuff... */
					case 0xff6c: // Undocumented (FEh) - bit 0 (Read/Write)
						PRINTF("WARNING: CPU.read(): Read from *undocumented* IO port $%04x\n",index);
						b = IOP[index-0xff00] | 0xfe;
						break;
					case 0xff72: // Undocumented (00h) - Bit 0-7 (Read/Write)
					case 0xff73: // Undocumented (00h) - Bit 0-7 (Read/Write)
					case 0xff74: // Undocumented (00h) - Bit 0-7 (Read/Write)
						b = IOP[index-0xff00];
						break;
					case 0xff75: // Undocumented (8Fh) - Bit 4-6 (Read/Write)
						PRINTF("WARNING: CPU.read(): Read from *undocumented* IO port $%04x\n",index);
						b = IOP[index-0xff00] | 0x8f;
						break;
					case 0xff76: // Undocumented (00h) - Always 00h (Read Only)
					case 0xff77: // Undocumented (00h) - Always 00h (Read Only)
						PRINTF("WARNING: CPU.read(): Read from *undocumented* IO port $%04x\n",index);
						b = 0;
						break;
					default:
						PRINTF("TODO: CPU.read(): Read from IO port $%04x\n",index);
						b=0xff; // GnuBoy compat
						break;
				}
			}
			else if(index < 0xffff) { //High RAM (HRAM)
				b = HRAM[index-0xff80];
			}
			else if(index < 0x10000) { // Interrupt Enable Register (0xffff)
				b=IE;
			}
			else {
				PRINTLN("ERROR: CPU.read(): Out of range memory access: $"+index);
				b=0;
			}
			return b;
		}

		// has arguments swapped for recompiler use (stack order and stuff)
		public static void write_fast1(int value, int index) {
			last_memory_access_internal=index;
			BTYPE mm[]=wMemMap[index>>12];
			if (mm!=null) {
				mm[index&0x0FFF] = I2B(value);
				return;
			}
			write_slow(index, value);
		}

		public static void write(int index, int value) {
			last_memory_access_internal=index;
			BTYPE mm[]=wMemMap[index>>12];
			if (mm!=null) {
				mm[index&0x0FFF] = I2B(value);
				return;
			}
			write_slow(index, value);
		}

		public static void write_slow(int index, int value) {
			/* Memorymap:
			 * 0000-3FFF   16KB ROM Bank 00     (in cartridge, fixed at bank 00)
			 * 4000-7FFF   16KB ROM Bank 01..NN (in cartridge, switchable bank number)
			 * 8000-9FFF   8KB Video RAM (VRAM) (switchable bank 0-1 in CGB Mode)
			 * A000-BFFF   8KB External RAM     (in cartridge, switchable bank, if any)
			 * C000-CFFF   4KB Work RAM Bank 0 (WRAM)
			 * D000-DFFF   4KB Work RAM Bank 1 (WRAM)  (switchable bank 1-7 in CGB Mode)
			 * E000-FDFF   Same as C000-DDFF (ECHO)    (typically not used)
			 * FE00-FE9F   Sprite Attribute Table (OAM)
			 * FEA0-FEFF   Not Usable
			 * FF00-FF7F   I/O Ports
			 * FF80-FFFE   High RAM (HRAM)
			 * FFFF        Interrupt Enable Register
			 */
			last_memory_access_internal=index;
			ASSERT(wMemMap[index>>12] == null); // remove when not triggered for some time...

			ASSERT(index>=0 && index <=0xffff);

			if(index < 0x8000) { //cartridge ROM
				cartridge.write(index, value);

				refreshMemMap();
			}
			else if(index < 0xa000) { //8KB Video RAM (VRAM) (switchable bank 0-1 in CGB Mode)
				VC.write(index, value);
			}
			else if(index < 0xc000) { //8KB External RAM     (in cartridge, switchable bank, if any)
				cartridge.write(index, value);
			}
			else if(index < 0xd000) { //4KB Work RAM Bank 0 (WRAM)
				WRAM[0][index-0xc000]=I2B(value);
			}
			else if(index < 0xe000) { //4KB Work RAM Bank 1 (WRAM)  (switchable bank 1-7 in CGB Mode)
				WRAM[CurrentWRAMBank][index-0xd000]=I2B(value);
			}
			else if(index < 0xfe00) { //Same as C000-DDFF (ECHO)    (typically not used)
				write(index-0x2000, value);
			}
			else if(index < 0xfea0) { //Sprite Attribute Table (OAM)
				VC.write(index, value);
			}
			else if(index < 0xff00) { //Not Usable
				/* Silenced since a lot of games seem to write to here anyway
				 * PRINTF("WARNING: CPU.write(): Write to unusable memory (0xfea0-0xfeff) index=$%04x, value=$%02x\n",index,value);
				 */
			}
			else if(index < 0xff80) { //I/O Ports
				switch(index) {
					case 0xff00: // FF00 - P1/JOYP - Joypad (R/W)
						IOP[index&0xff]=value;
						break;
					case 0xff01: // SB - Serial transfer data (R/W)
						IOP[0x01]=value;
						break;
					case 0xff02: // SC - Serial Transfer Control (R/W)
						IOP[0x02]=value;
						if(LinkCableStatus==0) { //Not connected to other emulator
							if ((value&(1<<7))!=0) {
								// transfer! (we do it instantly...)
								if ((value&(1<<0))!=0) {
									// internal clock, this 'works' without other GB
									IOP[0x01] = 0xFF; // 'works'
									IOP[0x02] &= ~(1<<7); // 'transfer' finished
									triggerInterrupt(3);
								}
								else {
									// external clock, nothing will happen
								}
							}
						}
						break;
					case 0xff04: // DIV
						IOP[0x04] = 0;
						break;
					case 0xff05: // TIMA
					case 0xff06: // TMA
					case 0xff07: // TAC
						IOP[index-0xff00] = value;
						switch(value&3) {
							case 0:
								TIMAcntdwn = 1024; // == 4194304/4096
								break;
							case 1:
								TIMAcntdwn = 16; // == 4194304/262144
								break;
							case 2:
								TIMAcntdwn = 64; // == 4194304/65536
								break;
							case 3:
								TIMAcntdwn = 256; // == 4194304/16384
								break;
							}
						break;
					case 0xff0f: // FF0F - IF - Interrupt Flag (R/W) (*Request* interrupts, and *shows* interrupts being queed)
						IOP[0x0f] = value;
						break;
					/* AUDIO IO PORTS */
					case 0xff10: case 0xff11: case 0xff12: case 0xff13: case 0xff14: case 0xff15: case 0xff16: case 0xff17:
					case 0xff18: case 0xff19: case 0xff1a: case 0xff1b: case 0xff1c: case 0xff1d: case 0xff1e: case 0xff1f:
					case 0xff20: case 0xff21: case 0xff22: case 0xff23: case 0xff24: case 0xff25: case 0xff26: case 0xff27:
					case 0xff28: case 0xff29: case 0xff2a: case 0xff2b: case 0xff2c: case 0xff2d: case 0xff2e: case 0xff2f:
					case 0xff30: case 0xff31: case 0xff32: case 0xff33: case 0xff34: case 0xff35: case 0xff36: case 0xff37:
					case 0xff38: case 0xff39: case 0xff3a: case 0xff3b: case 0xff3c: case 0xff3d: case 0xff3e: case 0xff3f:
						AC.write(index, value);
						break;
					case 0xff40: // LCDC register
						if( ((value&0x80)!=0) && ((VC.LCDC&0x80)==0) ) VC.restart();
						VC.LCDC = value;
						break;
					case 0xff41: // FF41 - STAT - LCDC Status (R/W)
						VC.STAT = (VC.STAT&7)|(value&0x78); //lower 3bits are readonly
						if (!VC.isCGB && ((VC.STAT & 2)==0) && ((VC.LCDC&0x80)!=0)) {
							/* DMG STAT write bug => interrupt
							* In certain situations, writing to the STAT register ($ff41) seems to cause bit 1
							* of the IF register ($ff0f) to be set (and thus cause interrupt $48 to occur, if
							* it is enabled). Due to programming bugs, at least two games (Roadrash, Legend of
							* Zerd) insist on this quirk, and are incompatible with the GBC. As far as has been
							* figured out, the bug happens everytime ANYTHING (including 00) is written to the
							* STAT register ($ff41) while the gameboy is either in HBLANK or VBLANK mode. It
							* doesn't seem to happen when the gameboy is in OAM or VRAM mode, or when the display
							* is disabled. (Info from Martin Korth.)
							*/
							triggerInterrupt(1);
							}
						break;
					case 0xff42: // SCY
						VC.SCY = value;
						break;
					case 0xff43: // SCX
						VC.SCX = value;
						break;
					case 0xff44: // LY
						VC.LY = 0; // can only be set to 0
						break;
					case 0xff45: // LYC
						// We're not sure if this is correct or not, but at least it fixes flickering
						// in donkey kong by allowing to generate an STAT interrupt as soon as LY equals
						// LYC, instead of on the next mode0->mode2 transition.
						// The pandocs state that:
						//   "The gameboy permanently compares the value of the LYC and LY registers.
						//    When both values are identical, the coincident bit in the STAT register
						//    becomes set, and (if enabled) a STAT interrupt is requested."
						// But they make a habit of writing 'permanently' where they mean 'continually'.
						VC.STAT &= ~(1<<2); // Clear Coincidence bit
						if (VC.LYC != value && VC.LY==value && (VC.STAT&(1<<6))!=0) {
							VC.STAT |= (1<<2); // Set Coincidence bit
							CPU.triggerInterrupt(1);
						}
						VC.LYC = value;
						break;
					case 0xff46:{ // FF46 - DMA - DMA Transfer and Start Address (W)
						//NOTE: CPU may only access HRAM during this DMA,
						//      so there is no need to do special timing
						last_memory_access=last_memory_access_internal;
						//ASSERT((VC.STAT&2)==0);
						for(int i=0; i<0xa0; ++i){
							write(0xfe00|i, read(i+(value<<8)));
						}
						last_memory_access_internal=last_memory_access;
						} break;
					case 0xff47: // BGP - BG Palette Data (R/W) - Non CGB Mode Only
					case 0xff48: // OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only
					case 0xff49: // OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only
						IOP[index-0xff00] = value;
						VC.updateMonoColData(index-0xff47);
						break;
					case 0xff4a: // WY
						VC.WY = value;
						break;
					case 0xff4b: // WX
						VC.WX = value;
						break;
					case 0xff4d: // KEY1 - CGB Mode Only - Prepare Speed Switch
						speedswitch = ((value&1)!=0);
						break;
					case 0xff4f: // FF4F - VBK - CGB Mode Only - VRAM Bank
						VC.selectVRAMBank(value&1);
						break;
					case 0xff51: // FF51 - HDMA1 - CGB Mode Only - New DMA Source, High
					case 0xff52: // FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low
					case 0xff53: // FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High
					case 0xff54: // FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low
						IOP[index-0xff00] = value;
						break;
					case 0xff55: // FF55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start
						int mode = ((hblank_dma_state|value) & 0x80);
						if (mode == 0) {
							int src = ((IOP[0x51]<<8)|IOP[0x52]) & 0xfff0;
							int dst = (((IOP[0x53]<<8)|IOP[0x54]) & 0x1ff0) | 0x8000;
							int len = ((value & 0x7f)+1)<<4;
// 							PRINTLN("WARNING: CPU.write(): TODO: Untimed H-DMA Transfer");
							// TODO: this should take more than 4-12 cycles :O
							//PRINTF("DONE: General HDMA transfer src=$%04x dst=$%04x len=$%04x\n", src, dst, len);
							for (int i = 0; i < len; ++i)
								VC.write(dst++, read(src++));
							IOP[0x51] = src >> 8;
							IOP[0x52] = src & 0xF0;
							IOP[0x53] = 0x1F & (dst >> 8);
							IOP[0x54] = dst & 0xF0;
							IOP[0x55] = 0xff; // indicate we have finished
// 							elapseTime();// Add elapsed time to counters (CPU was stalled, not time!) //FIXME:WIP
						} else {
							hblank_dma_state = value;
							IOP[0x55] = value & 0x7f;
						}
						break;
					case 0xff68: // BGPI
						VC.BGPI = value;;
						break;
					case 0xff69: // BGPD
						VC.setBGColData(value);
						break;
					case 0xff6a: // OBPI
						VC.OBPI = value;;
						break;
					case 0xff6b: // OBPD
						VC.setOBColData(value);
						break;
					case 0xff70: //FF70 - SVBK - CGB Mode Only - WRAM Bank
						CurrentWRAMBank=MAX(value&0x07, 1);
						refreshMemMap();
						break;
					/** some 'undocumented' stuff... */
					case 0xff6c: // Undocumented (FEh) - bit 0 (Read/Write)
					case 0xff72: // Undocumented (00h) - Bit 0-7 (Read/Write)
					case 0xff73: // Undocumented (00h) - Bit 0-7 (Read/Write)
					case 0xff74: // Undocumented (00h) - Bit 0-7 (Read/Write)
					case 0xff75: // Undocumented (8Fh) - Bit 4-6 (Read/Write)
						PRINTF("WARNING: CPU.write(): Write to *undocumented* IO port $%04x\n",index);
						IOP[index-0xff00] = value;
						break;
					case 0xff76: // Undocumented (00h) - Always 00h (Read Only)
					case 0xff77: // Undocumented (00h) - Always 00h (Read Only)
						PRINTF("WARNING: CPU.write(): Write to *undocumented* IO port $%04x\n",index);
						break;
					default:
						PRINTF("TODO: CPU.write(): Write %02x to IO port $%04x\n",value, index);
						break;
				}
			}
			else if(index < 0xffff) { //High RAM (HRAM)
				HRAM[index-0xff80] = value;
			}
			else if(index < 0x10000) { // FFFF - IE - Interrupt Enable (R/W)
				IE=value; // Interrupt Enable Register
			}
			else {
				PRINTLN("ERROR: CPU.write(): Out of range memory access: $"+index);
			}
		}


		public static void reset() {
			reset(true);
		}

		public static void reset(boolean bios) {
			if(cartridge == null) return; //Do nothing if no cartridge is inserted
			BIOS_enabled = bios; // NOTE: bios parameter is not used anymore
			VC.reset();
			cartridge.CurrentRAMBank=0;
			cartridge.CurrentROMBank=1;
			refreshMemMap();

			setPC(BIOS_enabled?0x00:0x100); // Right... perhaps we should re-evaluate BIOS_enabled...
			VC.isCGB = BIOS_enabled?false:isCGB();

			//AF=$01B0
			A=BIOS_enabled ? 0x00 : (VC.isCGB?0x11:0x01); // CGB sets this to 0x11 instead of 0x01 for GB
			F=BIOS_enabled ? 0x00 : 0xb0;
			//BC=$0013
			B=0x00;
			C=BIOS_enabled ? 0x00 : 0x13;
			//DE=$00D8
			D=0x00;
			E=BIOS_enabled ? 0x00 : 0xd8;
			//HL=$014D
			H=BIOS_enabled ? 0x00 : 0x01;
			L=BIOS_enabled ? 0x00 : 0x4d;
			TotalInstrCount=0;
			TotalCycleCount=0;

			//Stack Pointer=$FFFE
			SP=BIOS_enabled ? 0x0000 : 0xfffe;

			//NOTE: I'm not sure what to init the audiocontroller to when the BIOS is active, so let's leave it like this
			write(0xff05, 0x00); // [$FF05] = $00   ; TIMA
			write(0xff06, 0x00); // [$FF06] = $00   ; TMA
			write(0xff07, 0x00); // [$FF07] = $00   ; TAC
			write(0xff26, 0xf1); // [$FF26] = $F1-GB, $F0-SGB ; NR52
			write(0xff47, 0xfc); // [$FF47] = $FC   ; BGP
			write(0xff48, 0xff); // [$FF48] = $FF   ; OBP0
			write(0xff49, 0xff); // [$FF49] = $FF   ; OBP1
			AC.reset(); // Sets FF11-FF25

			CurrentWRAMBank=1;
			doublespeed = false;
			speedswitch = false;
			DIVcntdwn = 0; //FIXME: Possibly set to initial value
			TIMAcntdwn = 0;//This should get set with the proper value as soon as TIMA is activated

			IE=0;         ///< Interrupt Enable (allowed interrupts)
			IME=true; ///< Interrupt Master Enable
			halted=false;
			KeyStatus=0; //bitmask
			keyBounce=0;
			keyBounceWaitNext=0;
			lastKeyChange = 0;
			keyHistory.clear();
			lastException=0;
			hblank_dma_state = 0;
			playbackHistoryIndex = -1;
			keyHistoryEnabled = false;
			first_save_string = Version.str;
			delayed_halt = false;
			halt_fail_inc_pc = false;

			for (int i = 0; i < 0x80; ++i) IOP[i] = 0;
			for (int i = 0; i < 0x7f; ++i) HRAM[i] = 0;
			for (int i = 0; i < 0x08; ++i)
				for (int j = 0; j < 0x1000; ++j)
					WRAM[i][j] = 0;
		}

		public static long cycles() {
			return TotalInstrCount;
		}

		public static void printCPUstatus() {
			String flags = "";
			flags += (( F & ZF_Mask ) == ZF_Mask )?"Z ":"z ";
			flags += (( F & NF_Mask ) == NF_Mask )?"N ":"n ";
			flags += (( F & HC_Mask ) == HC_Mask )?"H ":"h ";
			flags += (( F & CF_Mask ) == CF_Mask )?"C ":"c ";
			flags += (( F & ( 1 <<3 ) ) == ( 1 <<3 ) )?"1 ":"0 ";
			flags += (( F & ( 1 <<2 ) ) == ( 1 <<2 ) )?"1 ":"0 ";
			flags += (( F & ( 1 <<1 ) ) == ( 1 <<1 ) )?"1 ":"0 ";
			flags += (( F & ( 1 <<0 ) ) == ( 1 <<0 ) )?"1 ":"0 ";
			PRINTLN( "---CPU Status for cycle "+TotalCycleCount+" , instruction "+TotalInstrCount+"---" );
			PRINTF( "   A=$%02x    B=$%02x    C=$%02x    D=$%02x   E=$%02x   F=$%02x   H=$%02x   L=$%02x\n", A, B, C, D, E, F, H,L );
			PRINTF( "  PC=$%04x SP=$%04x                           flags="+flags+"\n",getPC(),SP );
			#ifndef USE_JAVA_MOBILE
				PRINTLN( "  "+deasm.disassemble( getPC() ) );
			#endif
		}

		public static int checkInterrupts() { //handle interrupt priorities
			if(IME) { // If interrupts enabled
				int ir = IOP[0x0f]&IE; //First Requested interrupts
				if((ir&(1<<0))!=0) { //VBlANK
					IOP[0x0f] &= ~(1<<0);
					interrupt(0x40);
					return 1;
				}
				else if ((ir&(1<<1))!=0) { //LCD STAT
					IOP[0x0f] &= ~(1<<1);
					interrupt(0x48);
					return 1;
				}
				else if ((ir&(1<<2))!=0) { //Timer
					IOP[0x0f] &= ~(1<<2);
					interrupt(0x50);
					return 1;
				}
				else if ((ir&(1<<3))!=0) { //Serial
					IOP[0x0f] &= ~(1<<3);
					interrupt(0x58);
					return 1;
				}
				else if ((ir&(1<<4))!=0) { //Joypad
					IOP[0x0f] &= ~(1<<4);
					interrupt(0x60);
					return 1;
				}
			}
			return 0; // No interrupts to service
		}

		public static void interrupt(int i) { //execute interrupt #i
			IME = false;
			pushPC();
			setPC(i);
			IOP[0x0f] &= ~i;
		}

		public static void triggerInterrupt(int i) { // request interrupt with bit nr #i
			IOP[0x0f] |= (1<<i);

			if (halted && IME && ((1<<i) & IE) != 0) halted = false;
		}

		public static void pressButton(int i) {
			if ((GUIKeyStatus&i) != 0) return;
			GUIKeyStatus |= i;
		}

		public static void releaseButton(int i) {
			if ((GUIKeyStatus&i) == 0) return;
			GUIKeyStatus&=~i;
		}

		public static void pressRemoteButton(int i) {
			RemoteKeyStatus |= i;
		}

		public static void releaseRemoteButton(int i) {
			RemoteKeyStatus &= ~i;
		}

		/** Performs a read of a register by internal register number */
		private static final int registerRead(int regNum) {
			switch (regNum) {
				case 0:
					return B;
				case 1:
					return C;
				case 2:
					return D;
				case 3:
					return E;
				case 4:
					return H;
				case 5:
					return L;
				case 6:
					return read(H<<8 | L);
				case 7:
					return A;
				default:
					return -1;
			}
		}

		public static void executeALU(int b1) {
			int operand = registerRead(b1 & 0x07);
			switch ((b1 & 0x38) >> 3) {
				case 1: // ADC A, r
					if ((F & CF_Mask) != 0) {
						operand++;
					}
					// Note!  No break!
				case 0: // ADD A, r

					if ((A & 0x0F) + (operand & 0x0F) >= 0x10) {
						F = HC_Mask;
					} else {
						F = 0;
					}

					A += operand;

					if (A > 0xff) {
						F |= CF_Mask;
						A &= 0xff;
					}

					if (A == 0) {
						F |= ZF_Mask;
					}
					break;
				case 3: // SBC A, r
					if ((F & CF_Mask) != 0) {
						operand++;
					}
					// Note! No break!
				case 2: // SUB A, r

					F = NF_Mask;

					if ((A & 0x0F) < (operand & 0x0F)) {
						F |= HC_Mask;
					}

					A -= operand;

					if (A < 0) {
						F |= CF_Mask;
						A &= 0xff;
					}
					if (A == 0) {
						F |= ZF_Mask;
					}

					break;
				case 4: // AND A, r
					A &= operand;
					if (A == 0) {
						F = HC_Mask + ZF_Mask;
					} else {
						F = HC_Mask;
					}
					break;
				case 5: // XOR A, r
					A ^= operand;
					F = (A == 0) ? ZF_Mask : 0;
					break;
				case 6: // OR A, r
					A |= operand;
					F = (A == 0) ? ZF_Mask : 0;
					break;
				case 7: // CP A, r (compare)
					F = NF_Mask;
					if (A == operand) {
						F |= ZF_Mask;
					} else if (A < operand) {
						F |= CF_Mask;
					}
					if ((A & 0x0F) < (operand & 0x0F)) {
						F |= HC_Mask;
					}
					break;
			}
		}

		public static int execute() {
			int op, imm8a, imm8b;
			int cycles;
			TVARS;

			if (CHECK_INTS) {
				checkInterrupts();
				halted = false;
				//return 4;/* FIXME(?) For break on interrupt *//* note: 4 should be allright. RST takes 16 cycles */
				return 5; //According to MESS "Taking an interrupt seems to take around 20 clock cycles."
			}

			if (delayed_halt && IME) {
				delayed_halt = false;
				halted = true;
			}

			if (halted) return 1; //Halt duration is a multiple of 4 cycles, so return 1 here

			if (keyBounce > 0) {
				--keyBounceWaitNext;
				if(keyBounceWaitNext < 0) {//wait some instructions
					keyBounceWaitNext=1000;
					triggerInterrupt(4);
					--keyBounce;
				}
			}

			if (halt_fail_inc_pc) {
				// failed to increment PC after halt
				halt_fail_inc_pc = false;
				--localPC;
			}

			if (false) {
			} else {
				int pc = localPC + globalPC;
				op=read(pc++);
				imm8a = read(pc);
				imm8b = read(pc+1);
				setPC(pc);
			}
			cycles = Tables.cycles[op];

//#define break return cycles
			switch ( op ) {
				case 0x00: break;                                   // NOP
				case 0xf3: IME=false; break;                        // DI
				case 0xfb: IME=true; break;                         // IE
				case 0xea: localPC+=2; WRITE_V(IMM16, A); break;                // LD   (nn), A
				case 0xfa: localPC+=2; A = READ_V(IMM16); break;                // LD   A   , (nn)
				case 0xe0: ++localPC; WRITE_S(IMM8a | 0xff00, A); break;        // LDH  (n) , A
				case 0xf0: ++localPC; A = READ_S(IMM8a | 0xff00); break;        // LDH  A   , (n)
				case 0xe2: WRITE_S(C | 0xff00, A); break;           // LDH  (C) , A
				case 0xf2: A = READ_S(C | 0xff00); break;           // LDH  A   , (C)
				case 0xf9: SP = R16RHL; break;                      // LD   SP  , HL
				case 0x22: WRITE_V(R16RHL, A); DO_INC16(HL); break; // LDI  (HL), A
				case 0x2a: A = READ_V(R16RHL); DO_INC16(HL); break; // LDI  A   , (HL)
				case 0x32: WRITE_V(R16RHL, A); DO_DEC16(HL); break; // LDD  (HL), A
				case 0x3a: A = READ_V(R16RHL); DO_DEC16(HL); break; // LDD  A   , (HL)
				case 0xc3: DO_JP_NN; break;                         // JP   (nn)
				case 0xc2: DO_JP_COND((F&FZ)==0); break;            // JP   NZ  , (nn)
				case 0xca: DO_JP_COND((F&FZ)!=0); break;            // JP   Z   , (nn)
				case 0xd2: DO_JP_COND((F&FC)==0); break;            // JP   NC  , (nn)
				case 0xda: DO_JP_COND((F&FC)!=0); break;            // JP   C   , (nn)
				case 0xcd: DO_CALL_NN; break;                       // CALL (nn)
				case 0xc4: DO_CALL_COND((F&FZ)==0); break;          // CALL NZ  , (nn)
				case 0xcc: DO_CALL_COND((F&FZ)!=0); break;          // CALL Z   , (nn)
				case 0xd4: DO_CALL_COND((F&FC)==0); break;          // CALL NC  , (nn)
				case 0xdc: DO_CALL_COND((F&FC)!=0); break;          // CALL C   , (nn)
				case 0x18: DO_JR_D; break;                          // JR   (d)
				case 0x20: DO_JR_COND((F&FZ)==0); break;            // JR   NZ  , (d)
				case 0x28: DO_JR_COND((F&FZ)!=0); break;            // JR   Z   , (d)
				case 0x30: DO_JR_COND((F&FC)==0); break;            // JR   NC  , (d)
				case 0x38: DO_JR_COND((F&FC)!=0); break;            // JR   C   , (d)
				case 0xc9: DO_RET; break;                           // RET
				case 0xc0: DO_RET_COND((F&FZ)==0); break;           // RET  NZ
				case 0xc8: DO_RET_COND((F&FZ)!=0); break;           // RET  Z
				case 0xd0: DO_RET_COND((F&FC)==0); break;           // RET  NC
				case 0xd8: DO_RET_COND((F&FC)!=0); break;           // RET  C
				case 0x02: WRITE_V(R16RBC, A); break;               // LD   (BC), A
				case 0x0A: A = READ_V(R16RBC); break;               // LD   A   , (BC)
				case 0x12: WRITE_V(R16RDE, A); break;               // LD   (DE), A
				case 0x1A: A = READ_V(R16RDE); break;               // LD   A   , (DE)
				case 0x70: WRITE_V(R16RHL, B); break;               // LD   (HL), B
				case 0x71: WRITE_V(R16RHL, C); break;               // LD   (HL), C
				case 0x72: WRITE_V(R16RHL, D); break;               // LD   (HL), D
				case 0x73: WRITE_V(R16RHL, E); break;               // LD   (HL), E
				case 0x74: WRITE_V(R16RHL, H); break;               // LD   (HL), H
				case 0x75: WRITE_V(R16RHL, L); break;               // LD   (HL), L
				case 0x77: WRITE_V(R16RHL, A); break;               // LD   (HL), A
				case 0x36: ++localPC; WRITE_V(R16RHL, IMM8a); break;            // LD   (HL), n
				case 0x76: {                                        // HALT
					if (IME) {
						halted = true;
					} else {
						delayed_halt = true;
						if (!isCGB() && (IOP[0x0f]&IE) > 0)
							halt_fail_inc_pc = true;
					}
				}; break;
				case 0xd9: IME = true; DO_RET; break;               // RETI
				case 0xc1: R16WBC_V(POP); break;                    // POP  BC
				case 0xd1: R16WDE_V(POP); break;                    // POP  DE
				case 0xe1: R16WHL_V(POP); break;                    // POP  HL
				case 0xf1: R16WAF_V(POP); break;                    // POP  AF
				case 0xc5: DO_PUSH_V(R16RBC); break;                // PUSH BC
				case 0xd5: DO_PUSH_V(R16RDE); break;                // PUSH DE
				case 0xe5: DO_PUSH_V(R16RHL); break;                // PUSH HL
				case 0xf5: DO_PUSH_V(R16RAF); break;                // PUSH AF
				case 0x09: DO_ADD_HL(B, C); break;                  // ADD  HL  , BC
				case 0x19: DO_ADD_HL(D, E); break;                  // ADD  HL  , DE
				case 0x29: DO_ADD_HL(H, L); break;                  // ADD  HL  , HL
				case 0x39: DO_ADD_HL((SP>>8), (SP&0xff)); break;    // ADD  HL  , SP
				case 0xe9: setPC(R16RHL); break;                      // JP   HL
				case 0x2f: A ^= 0xff; F |= (FN|FH); break;          // CPL
				case 0x07: DO_SHOP_R(RLC, A); F &= FC; break;       // RLA
				case 0x17: DO_SHOP_R(RL, A); F &= FC; break;        // RL
				case 0x0f: DO_SHOP_R(RRC, A); F &= FC; break;       // RRA
				case 0x1f: DO_SHOP_R(RR, A); F &= FC; break;        // RR
				case 0xc7: pushPC(); setPC(0x00); break;           // RST  &0
				case 0xcf: pushPC(); setPC(0x08); break;           // RST  &8
				case 0xd7: pushPC(); setPC(0x10); break;           // RST  &10
				case 0xdf: pushPC(); setPC(0x18); break;           // RST  &18
				case 0xe7: pushPC(); setPC(0x20); break;           // RST  &20
				case 0xef: pushPC(); setPC(0x28); break;           // RST  &28
				case 0xf7: pushPC(); setPC(0x30); break;           // RST  &30
				case 0xff: pushPC(); setPC(0x38); break;           // RST  &38
				case 0x37: F &= FZ; F |= FC; break;                 // SCF
				case 0x3f: F &= (FZ|FC); F ^= FC; break;            // CCF
				case 0x08: {                                        // LD   (nn), SP
					localPC+=2;
					t_acc = IMM16;
					WRITE_V(t_acc, SP&0xff);
					WRITE_F((t_acc+1)&0xffff , SP>>8);
				}; break;
				case 0xf8:{                                         // LD  HL, SP+dd
					++localPC;
					R16WHL(SP);
					L += IMM8OFS;
					F = 0;
					if (L > 0xff) {
						L &= 0xff;
						F |= FH;
						++H;
						if (H > 0xff) {
							H &= 0xff;
							F |= FC;
						}
					}
					else if (L < 0) {
						L &= 0xff;
						F |= FH;
						--H;
						if (H < 0) {
							H &= 0xff;
							F |= FC;
						}
					}
				};break;
				case 0x27:{                                         // DAA
					t_acc = Tables.daa[(((F)&0x70)<<4) | A];
					A += t_acc;
					F = (F & (FN)) | ((A==0)?FZ:0) | Tables.daa_carry[t_acc>>2];
					A &= 0xff;
				};break;
				case 0xe8:{
					++localPC;
					t_acc = SP;
					SP += IMM8OFS;
					F = ((SP >> 8) != (t_acc >> 8)) ? FH : 0;
					if ((SP & ~0xffff) != 0) {
						SP &= 0xffff;
						F |= CF_Mask;
					}
				};break;
				case 0x10: if (speedswitch) {                       // STOP
					PRINTLN("Speed switch!");
					doublespeed = !doublespeed;
					++localPC; // debuggin hax! gnuboy does this too! (fix?)
					speedswitch = false;
				}; break;
				CASES_ALU_OP(0xb8, 0xfe, CP)                        // CP   x            x = r, imm8, (HL)
				CASES_ALU_OP(0xa0, 0xe6, AND)                       // AND  x            x = r, imm8, (HL)
				CASES_ALU_OP(0xa8, 0xee, XOR)                       // XOR  x            x = r, imm8, (HL)
				CASES_ALU_OP(0xb0, 0xf6, OR)                        // OR   x            x = r, imm8, (HL)
				CASES_ALU_OP(0x80, 0xC6, ADD)
				CASES_ALU_OP(0x88, 0xCE, ADC)
				CASES_ALU_OP(0x90, 0xD6, SUB)
				CASES_ALU_OP(0x98, 0xDE, SBC)
				CASES_INCDEC8
				CASES_INCDEC16
				CASES_LD_XX
				case 0xcb: // prefix instruction
					++localPC;
					cycles = Tables.cb_cycles[IMM8a];
					switch ( IMM8a ) {
						CASES_CB_BITNUM(0x40, BIT)
						CASES_CB_BITNUM(0x80, RES)
						CASES_CB_BITNUM(0xc0, SET)
						CASES_CB_SHOP(0x00, RLC)
						CASES_CB_SHOP(0x08, RRC)
						CASES_CB_SHOP(0x10, RL)
						CASES_CB_SHOP(0x18, RR)
						CASES_CB_SHOP(0x20, SLA)
						CASES_CB_SHOP(0x28, SRA)
						CASES_CB_SHOP(0x38, SRL)
						CASES_CB_SWAP
						default:
						PRINTF( "UNKNOWN PREFIX INSTRUCTION: $%02x (" + IMM8a + ")\n" , IMM8a );
						localPC -= 2;
						return 0;
					}
					break;
				default:
					if ((op & 0xC0) == 0x80) {
						executeALU(op);
						return cycles;
					} else {
						PRINTF( "UNKNOWN INSTRUCTION: $%02x (" + op + ")\n" , op );
						localPC -= 1; // we failed to execute the instruction, so restore PC
						return 0;
					}
			}
//#undef break
			return cycles;
		}

		static long lastns = 0;
		static long lastuf = 0;
		static int samplesLeft = 0;

#ifdef ENABLE_RECOMPILER

		static CPURunBlock dummyrc = new DummyCPURunBlock();
		static CPURunBlock[][] rccachea =  new CPURunBlock[0xff][0x4000];
		static CPURunBlock[] rccache0 =  rccachea[0];
		static CPURunBlock[] rccachex =  new CPURunBlock[0x4000];
		static int[] rccnt =  new int[0x4000];
#endif

		public static int nextinstruction() {
			if (playbackHistoryIndex == -1) {
				if (KeyStatus != GUIKeyStatus) {
					keyBounce = 1000;
					keyBounceWaitNext = 0;
				}
				if (KeyStatus != GUIKeyStatus || lastKeyChange > 0x3fffffff) {
					KeyStatus = GUIKeyStatus;
					keyHistory.add(lastKeyChange);
					keyHistory.add(KeyStatus);
					lastKeyChange = 0;
				}
			} else if (playbackHistoryIndex < keyHistory.size()) {
				int d = keyHistory.get(playbackHistoryIndex);
				if (d <= lastKeyChange) {
					//PRINTLN("Playback!"+playbackHistoryIndex);
					lastKeyChange = 0;
					++playbackHistoryIndex;
					d = keyHistory.get(playbackHistoryIndex++);
					if (KeyStatus != d)  {
						KeyStatus = d;
						keyBounce = 1000;
						keyBounceWaitNext = 0;
					}
				}
			} else {
				playbackHistoryIndex = -1;
				keyHistoryEnabled = true;
			}
			int res = 4*execute();
			SP &= 0xffff;
			if (getPC() > 0xffff || getPC() < 0) setPC(getPC()&0xffff);
			//PC &= 0xffff;
			++TotalInstrCount;
			lastKeyChange += res;
			TotalCycleCount += res;
			lastException = ((res!=0) ? 0 : 1);
			last_memory_access=last_memory_access_internal;
			elapseTime(res);

			//logState();
			return res;
		}

/*
		static OutputStream statelogger = null;

		static void logState() {
			try {
				if (statelogger == null) statelogger = new FileOutputStream("statelog.txt");
				String msg = "i:" + TotalInstrCount + " c:" + TotalCycleCount + " PC:" + getPC()
					+ " A:" + A
					+ " F:" + F
					+ " B:" + B
					+ " C:" + C
					+ " D:" + D
					+ " E:" + E
					+ " H:" + H
					+ " L:" + L
					+ " SP:" + SP
					+ "\n";
				statelogger.write(msg.getBytes());
			} catch (Throwable e) {
			}
		}
*/
		/* Elapse time should be called whenever an event happens that consumes time.
		 * It will update all relevant timers. Input is the ammount of time that supposedly
		 * has elapsed, in 'real' cpu cycles.
		 */
		public static void elapseTime(int cycles) {
			if (cycles > 0) {
				//clockfreq = 4194304hz
				DIVcntdwn -= cycles;
				if (DIVcntdwn < 0) {
					DIVcntdwn += 256; // == 4194304/16384
					++IOP[0x04];
					IOP[0x04] &= 0xff;
				}
				int tac = IOP[0x07];
				if ((tac&4)!=0) {
					TIMAcntdwn -= cycles;
					while (TIMAcntdwn <= 0) {
						if ((tac&3)==0) TIMAcntdwn += 1024; // == 4194304/4096
						if ((tac&3)==1) TIMAcntdwn +=   16; // == 4194304/262144
						if ((tac&3)==2) TIMAcntdwn +=   64; // == 4194304/65536
						if ((tac&3)==3) TIMAcntdwn +=  256; // == 4194304/16384
						++IOP[0x05];
						if (IOP[0x05] > 0xff) {
							IOP[0x05] = IOP[0x06];
							triggerInterrupt(2);
						}
					}
				}

				if (doublespeed) { // more instrs per vblank int
					AC.render(cycles>>1); //render enough sound bytes for cycles Cycles
					VC.render( cycles>>1 );
				}
				else {
					AC.render(cycles); //render enough sound bytes for cycles Cycles
					VC.render( cycles );
				}
			}

#ifndef USE_JAVA_MOBILE
			if (LinkCableStatus != 0) {
				LINKcntdwn -= cycles;
				if (LINKcntdwn < 0) {
					LINKcntdwn += (4096 / LINKmulti);
					// == 4194304/(1024*LINKmulti) (normal speed 8k bits/sec is 1k bytes/sec)
					//LINKcntdwn += 4096*9; // * 10 tetris hax to get more 'reasonable' speeds...
					try {
						int lstatus = IOP[0x02] | (IOP[0x01] << 8);
						int rstatus = -1;

						LINKbuf[LINKind++] = lstatus;

						lstatus |= RemoteKeyStatus << 16;

						LinkCableOut.writeInt(lstatus);
						LinkCableOut.flush();
						rstatus = LinkCableIn.readInt();

						if (useRemoteKeys) {
							int rkeys = (rstatus >> 16) & 0xff;
							if (GUIKeyStatus != rkeys) {
								GUIKeyStatus = rkeys;
							}
						}

						if (LINKind > LINKdelay) LINKind = 0;
						lstatus = LINKbuf[LINKind];

						int bstatus = (rstatus & 0xff) | ((lstatus & 0xff) << 8);
						bstatus &= 0x8181; // mask out ext/int clk and start transfer bits
															// dont yet care about clockspeed...,
						switch (bstatus) {
							case 0x8080: case 0x8001: case 0x8000: {
								// waiting for external clock that isnt there...
								// PRINTLN("waiting for external clock that isnt there...");
							}; break;
							case 0x8101: case 0x8100: {
								// internal clock timeout
								// PRINTLN("internal clock timeout");
								if (++LINKtimeout > LINKdelay) {
									LINKtimeout = 0;
									IOP[0x01] = 0xff;
									IOP[0x02] &= ~0x80;
									triggerInterrupt(3);
								}
							}; break;
							case 0x8181: {
								// 2 internal clocks! conflict! panic! aargh!
								PRINTLN("Link: clock conflict");
							}; break;
							case 0x8180:   // local clock, swap bytes
							case 0x8081: { // remote clock, swap bytes
								//PRINTF("Link: swapping $%04x: $%02x <-> $%02x\n",bstatus,IOP[0x01] , rstatus >> 8);
								IOP[0x01] = (rstatus >> 8) & 0xff;
								IOP[0x02] &= ~0x80;
								triggerInterrupt(3);
								LINKtimeout = 0;
							}; break;
							default: {
								// no (local) transfer requested
								//PRINTF("Link: no swapping $%04x\n",bstatus);
							}
						}

					}
					catch (IOException e) {
						PRINTLN("Link exception");
						severLink();
					}

				}
			}
#endif
		}

		public int exception() {
			return lastException;
		}

		#include "linkcable.inc"
}
