#include "Global.inc"
#ifndef USE_JAVA_MOBILE
import javax.swing.*;
import javax.swing.event.*;
import java.awt.*;
import java.awt.event.*;
import java.util.Vector;
// import java.util.*;
import java.net.*;
import java.io.*;
import java.awt.image.BufferedImage;

#include "keyConfigDialog.inc"

class SimpleCPURunner implements CPURunner, Runnable {
	private volatile int threadStatus = 0;
	private Thread cpurunthread;
	// 0 means suspended
	// 1 means suspend->running requested
	// 2 means running
	// 3 means running->suspended requested
	synchronized public void suspend() {
		while (threadStatus != 0) {
			threadStatus = 3;
			while (threadStatus == 3) { YIELD; };
		}
	}

	synchronized public void resume() {
		if (!CPU.canRun()) return;
		if (threadStatus != 2) {
			threadStatus = 1;
			while (threadStatus == 1) { YIELD; };
		}
	}

	public boolean isRunning() {
		return (threadStatus != 0);
	}

	SimpleCPURunner() {
		cpurunthread = new Thread(this);
		cpurunthread.start();
		while (!cpurunthread.isAlive()) { YIELD; }; // wait for thread to actually start
	}

	public void run() {
		while (true) {
			// suspended
			while (threadStatus == 0) { YIELD; };
			// suspend -> running
			if (threadStatus == 1) threadStatus = 2;
			// running
			while ((threadStatus == 2) && (CPU.nextinstruction()!=0)) {};

			if (threadStatus == 2) { // CPU returned exception
				threadStatus = 3;
				JOptionPane.showMessageDialog(null,
				                              "Encountered an invalid instruction, perhaps ROM is broken?",
				                              "Invalid Instruction",
				                              JOptionPane.INFORMATION_MESSAGE);
			}
			// running -> suspended
			if (threadStatus == 3) threadStatus = 0;
			// suspended
		}
	}
}

public class swinggui implements ActionListener, ItemListener, KeyListener, ComponentListener {
		public static boolean RIGHT_TO_LEFT = false;
		private static DrawingArea grfx;
		protected VideoController VC;
		protected CPU cpu;
		private int fps;
		private int selectedState = 0;
		private int[] keyMap = new int[16+nrOfShortCuts]; // first 8: player 1, next 8: player 2, etc, last N-4*8 = shortcuts
		VECTOR(String) osdLines = new VECTOR(String)();
		VECTOR(String) rcFiles = new VECTOR(String)();
		int osdTime = 0;
		static public String curcartname;
		//menuitem <-- here for my KDev autocomplete
		JMenuItem menuitemExit;
		JMenuItem menuitemScale1x;
		JMenuItem menuitemScale2x;
		JMenuItem menuitemScale3x;
		JMenuItem menuitemScale4x;
		JMenuItem menuitemOpenROM;
		JMenuItem menuitemSaveState;
		JMenuItem menuitemLoadState;
		JMenuItem menuitemIncFrameSkip;
		JMenuItem menuitemDecFrameSkip;
		JMenuItem menuitemSoundEnable;
		JMenuItem menuitemSoundDisable;
		JMenuItem menuitemSoundToggle;
		JMenuItem[] menuitemSelectState;
		JMenuItem[] menuItems; //Savestates?
		JMenuItem menuitemSeparator;
		JMenuItem menuitemPause;
		JMenuItem menuitemReset;
		JMenu menuColorScheme;
		JMenuItem menuitemColorSchemeOriginalGameboy;
		JMenuItem menuitemColorSchemeBlackAndWhite;
		JMenuItem menuitemColorSchemeGreys;
		JMenuItem menuitemColorSchemeCustom;
		JMenu menuSoundChannels;
		JMenuItem menuitemSoundChannel1;
		JMenuItem menuitemSoundChannel2;
		JMenuItem menuitemSoundChannel3;
		JMenuItem menuitemSoundChannel4;
		JMenu menuOther;
		JMenuItem menuitemCheats;
		JMenuItem menuitemToggleCheats;
		JMenu menuEmuSpeed;
		JMenuItem menuitemEmuSpeedPlus;
		JMenuItem menuitemEmuSpeedMinus;
		JMenuItem menuitemEmuSpeedMul;
		JMenuItem menuitemEmuSpeedDiv;
		JMenuItem menuitemEmuSpeedNormal;
#ifdef SCALEBUILDER
		JMenuItem menuitemScaleBuilder;
#endif
		JMenu menuLink;
		JMenuItem menuitemLinkServe;
		JMenuItem menuitemLinkClient;
		JMenuItem menuitemLinkSever;
		JMenuItem menuitemConfigKeys;
		JMenuItem menuitemToggleRemoteKeys;

		static CheatCodeEditor cheatcodes;
		CPURunner cpuRunner;

		protected ColorSelector cs;

		public void updateCartName(String fname) {
			int slashPos = fname.lastIndexOf(File.separator);
			int dotPos = fname.lastIndexOf(".");
			if (dotPos == -1) dotPos = fname.length()+1;

			curcartname = fname.substring(slashPos+1, dotPos);
			System.out.println("cartname = " + curcartname);

			rcFiles.remove(fname);
			rcFiles.insertElementAt(fname, 0);
			saveRCFiles();
		}

		public class DrawingArea extends JPanel{
			private static final long serialVersionUID = 1L; // prevent warning
			VideoController VC;
			public DrawingArea(VideoController vc) {
			super();
			VC=vc;
			}
			public void paintComponent(Graphics g) {
				super.paintComponent(g);
				g.drawImage(cpu.VC.getImage(),0,0, this);
				if (osdTime > 0) {
					g.setColor(new Color(255,255,255));
					--osdTime;
					if ((osdTime == 0) && (osdLines.size()>0)){
						osdLines.remove(0);
						osdTime = 15;
					}
					for (int i = 0; i < osdLines.size(); ++i) {
						g.drawString((String)osdLines.elementAt(i), 10, 10+10*i);
					}
				}
				++fps;
			}
		}

		public void addOSDLine(String line) {
			osdLines.add(line);
			osdTime = 200;
		}

		public swinggui() {
		}


		private JMenu menuFile;

		private JMenuBar createJMenuBar() {
			JMenuBar mainMenuBar;
			JMenu menuSettings;
			JMenu menuScaling;
			JMenu menuFrameSkip;
			JMenu menuState;
			JMenu menuSound;
			JMenu menuColor;
			mainMenuBar = new JMenuBar();

			menuFile = new JMenu( "File" );
			menuFile.setMnemonic( KeyEvent.VK_F );
			mainMenuBar.add( menuFile );
			menuSettings = new JMenu( "Video" );
			menuSettings.setMnemonic( KeyEvent.VK_S );
			mainMenuBar.add( menuSettings );

			menuitemOpenROM = new JMenuItem("Open ROM", KeyEvent.VK_O);
			menuitemOpenROM.addActionListener( this );
			menuFile.add(menuitemOpenROM);
			menuitemPause=new JMenuItem("Pause", KeyEvent.VK_P);
			menuitemPause.addActionListener(this);
			menuFile.add(menuitemPause);
			menuitemReset=new JMenuItem("Reset", KeyEvent.VK_R);
			menuitemReset.addActionListener(this);
			menuFile.add(menuitemReset);

			menuitemExit = new JMenuItem( "Exit", KeyEvent.VK_X );
			menuitemExit.addActionListener( this );
			menuFile.add( menuitemExit );

			menuScaling = new JMenu( "Scaling");
			menuitemScale1x = new JMenuItem( "Scale 1x", KeyEvent.VK_1 );
			menuitemScale2x = new JMenuItem( "Scale 2x", KeyEvent.VK_2 );
			menuitemScale3x = new JMenuItem( "Scale 3x", KeyEvent.VK_3 );
			menuitemScale4x = new JMenuItem( "Scale 4x", KeyEvent.VK_4 );
			menuitemScale1x.addActionListener( this );
			menuitemScale2x.addActionListener( this );
			menuitemScale3x.addActionListener( this );
			menuitemScale4x.addActionListener( this );
			menuScaling.add( menuitemScale1x );
			menuScaling.add( menuitemScale2x );
			menuScaling.add( menuitemScale3x );
			menuScaling.add( menuitemScale4x );
			menuSettings.add( menuScaling) ;

			menuFrameSkip = new JMenu( "Frame Skipping");
			menuitemIncFrameSkip = new JMenuItem( "Increase Frame Skip", KeyEvent.VK_I );
			menuitemDecFrameSkip = new JMenuItem( "Decrease Frame Skip", KeyEvent.VK_D );
			menuitemIncFrameSkip.addActionListener( this );
			menuitemDecFrameSkip.addActionListener( this );
			menuFrameSkip.add( menuitemIncFrameSkip );
			menuFrameSkip.add( menuitemDecFrameSkip );
			menuSettings.add( menuFrameSkip) ;

			menuColorScheme = new JMenu("Color scheme");
			menuitemColorSchemeOriginalGameboy = new JMenuItem("GameBoy LCD", KeyEvent.VK_L);
			menuitemColorSchemeBlackAndWhite = new JMenuItem("Black and White", KeyEvent.VK_B);
			menuitemColorSchemeGreys = new JMenuItem("Graytones", KeyEvent.VK_G);
			menuitemColorSchemeCustom = new JMenuItem("Custom", KeyEvent.VK_C);
			menuColorScheme.add(menuitemColorSchemeOriginalGameboy);
			menuColorScheme.add(menuitemColorSchemeBlackAndWhite);
			menuColorScheme.add(menuitemColorSchemeGreys);
			menuColorScheme.add(menuitemColorSchemeCustom);
			menuitemColorSchemeOriginalGameboy.addActionListener(this);
			menuitemColorSchemeBlackAndWhite.addActionListener(this);
			menuitemColorSchemeGreys.addActionListener(this);
			menuitemColorSchemeCustom.addActionListener(this);
			menuSettings.add(menuColorScheme);

			menuState = new JMenu("State");
			menuitemSaveState = new JMenuItem( "Save State", KeyEvent.VK_S );
			menuitemLoadState = new JMenuItem( "Load State", KeyEvent.VK_L );

			menuitemSaveState.addActionListener( this );
			menuitemLoadState.addActionListener( this );
			menuState.add( menuitemSaveState );
			menuState.add( menuitemLoadState );
			//menuState.add( menuitemSeparator );
			menuitemSelectState = new JMenuItem[10];
			for (int i = 0; i < 10; ++i) {
				menuitemSelectState[i] = new JMenuItem( "Select State " + i, KeyEvent.VK_0 + i);
				menuitemSelectState[i].setAccelerator( KeyStroke.getKeyStroke( KeyEvent.VK_0 + i, 0));
				menuitemSelectState[i].addActionListener( this );
				menuState.add(menuitemSelectState[i]);
			}
			mainMenuBar.add( menuState) ;

			menuSound = new JMenu( "Sound");
			menuitemSoundEnable = new JMenuItem( "Enable Sound", KeyEvent.VK_E );
			menuitemSoundDisable = new JMenuItem( "Disable Sound", KeyEvent.VK_D );
			menuitemSoundToggle = new JMenuItem( "Toggle Sound", KeyEvent.VK_T );

			menuitemSoundEnable.addActionListener( this );
			menuitemSoundDisable.addActionListener( this );
			menuitemSoundToggle.addActionListener( this );
			menuSound.add( menuitemSoundEnable );
			menuSound.add( menuitemSoundDisable );
			menuSound.add( menuitemSoundToggle );
			menuSoundChannels=new JMenu("Channels");
			menuitemSoundChannel1=new JMenuItem( "Toggle channel 1", KeyEvent.VK_1 );
			menuitemSoundChannel2=new JMenuItem( "Toggle channel 2", KeyEvent.VK_2 );
			menuitemSoundChannel3=new JMenuItem( "Toggle channel 3", KeyEvent.VK_3 );
			menuitemSoundChannel4=new JMenuItem( "Toggle channel 4", KeyEvent.VK_4 );

			menuitemSoundChannel1.addActionListener(this);
			menuitemSoundChannel2.addActionListener(this);
			menuitemSoundChannel3.addActionListener(this);
			menuitemSoundChannel4.addActionListener(this);
			menuSoundChannels.add(menuitemSoundChannel1);
			menuSoundChannels.add(menuitemSoundChannel2);
			menuSoundChannels.add(menuitemSoundChannel3);
			menuSoundChannels.add(menuitemSoundChannel4);
			menuSound.add(menuSoundChannels);
			mainMenuBar.add( menuSound) ;
			menuOther=new JMenu("Other");
			menuitemCheats = new JMenuItem("Edit cheats", KeyEvent.VK_C);
			menuitemCheats.addActionListener(this);
			menuOther.add(menuitemCheats);
			menuitemToggleCheats=new JMenuItem("Toggle cheats on/off", KeyEvent.VK_T);
			menuitemToggleCheats.addActionListener(this);
#ifdef SCALEBUILDER
			menuitemScaleBuilder=new JMenuItem("Built Scale", KeyEvent.VK_S);
			menuitemScaleBuilder.addActionListener(this);
			menuOther.add(menuitemScaleBuilder);
#endif
			menuOther.add(menuitemCheats);
			menuOther.add(menuitemToggleCheats);

			menuLink=new JMenu("Link");
			menuitemLinkServe = new JMenuItem("Start Link Server", KeyEvent.VK_S);
			menuitemLinkClient = new JMenuItem("Start Link Client", KeyEvent.VK_C);
			menuitemLinkSever = new JMenuItem("Stop Link", KeyEvent.VK_L);
			menuitemLinkServe.addActionListener(this);
			menuitemLinkClient.addActionListener(this);
			menuitemLinkSever.addActionListener(this);
			menuLink.add(menuitemLinkServe);
			menuLink.add(menuitemLinkClient);
			menuLink.add(menuitemLinkSever);
			mainMenuBar.add( menuLink ) ;

			menuitemConfigKeys = new JMenuItem("Config keys",KeyEvent.VK_1);
			menuitemConfigKeys.addActionListener(this);
			menuOther.add(menuitemConfigKeys);

			menuitemToggleRemoteKeys = new JMenuItem("Use Remote Keys", KeyEvent.VK_R);
			menuitemToggleRemoteKeys.addActionListener(this);
			menuOther.add(menuitemToggleRemoteKeys);

			menuEmuSpeed = new JMenu("Emulation Speed");
			menuitemEmuSpeedPlus  = new JMenuItem("+25%", KeyEvent.VK_PLUS);
			menuitemEmuSpeedMinus = new JMenuItem("-25%", KeyEvent.VK_MINUS);
			menuitemEmuSpeedMul  = new JMenuItem("*125%", KeyEvent.VK_OPEN_BRACKET);
 			menuitemEmuSpeedDiv = new JMenuItem("*75%", KeyEvent.VK_CLOSE_BRACKET);
			menuitemEmuSpeedNormal= new JMenuItem("100%", KeyEvent.VK_EQUALS);
			menuitemEmuSpeedPlus.addActionListener(this);
			menuitemEmuSpeedMinus.addActionListener(this);
			menuitemEmuSpeedMul.addActionListener(this);
			menuitemEmuSpeedDiv.addActionListener(this);
			menuitemEmuSpeedNormal.addActionListener(this);
			menuEmuSpeed.add(menuitemEmuSpeedPlus);
			menuEmuSpeed.add(menuitemEmuSpeedMinus);
			menuEmuSpeed.add(menuitemEmuSpeedMul);
			menuEmuSpeed.add(menuitemEmuSpeedDiv);
			menuEmuSpeed.add(menuitemEmuSpeedNormal);
			menuOther.add(menuEmuSpeed ) ;
			mainMenuBar.add( menuOther) ;

			return mainMenuBar;
		}

		private void applyAccelerators() {
			int keyMapIndex=16; // Accelerators start at 16
			#define NEXT_KEYSTROKE_FROM_KEYMAP KeyStroke.getKeyStroke( keyMap[keyMapIndex]&0xff, keyMap[keyMapIndex++]>>8 )
			menuitemConfigKeys.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemOpenROM.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemPause.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemReset.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemExit.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemScale1x.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemScale2x.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemScale3x.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemScale4x.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemIncFrameSkip.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemDecFrameSkip.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemColorSchemeOriginalGameboy.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemColorSchemeBlackAndWhite.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemColorSchemeGreys.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemColorSchemeCustom.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemSaveState.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemLoadState.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemSoundToggle.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemSoundChannel1.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemSoundChannel2.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemSoundChannel3.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemSoundChannel4.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemCheats.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemToggleCheats.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemEmuSpeedPlus.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemEmuSpeedMinus.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemEmuSpeedMul.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemEmuSpeedDiv.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);			menuitemEmuSpeedNormal.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
		}
		public void addComponentsToPane( Container contentPane ) {
//      Use BorderLayout. Default empty constructor with no horizontal and vertical
//      gaps
			contentPane.setLayout( new BorderLayout( 5,5 ) );
			if ( !( contentPane.getLayout() instanceof BorderLayout ) ) {
				contentPane.add( new JLabel( "Container doesn't use BorderLayout!" ) );
				return;
			}

			if ( RIGHT_TO_LEFT ) {
				contentPane.setComponentOrientation(
				  java.awt.ComponentOrientation.RIGHT_TO_LEFT );
			}

			grfx=new DrawingArea( cpu.VC ); //doublebuffering
			grfx.setFocusable(true);
			grfx.addKeyListener(this);
			grfx.setDoubleBuffered(false);
			grfx.setPreferredSize( new Dimension( 160*cpu.VC.nscale, 144*cpu.VC.nscale ) ); //quadruple each pixel
			contentPane.add( grfx, BorderLayout.CENTER );
		}

		static JFrame frame;

		private void createAndShowGUI() {
			//JFrame.setDefaultLookAndFeelDecorated( true );

			frame = new JFrame( "JGameBoy Emulator V"+JGBE_VERSION_STRING );
			frame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );
// 			frame.setBounds( 60,60,100,100 );

			//Set up the content pane and add swing components to it
			frame.setJMenuBar( createJMenuBar() );
			addComponentsToPane( frame.getContentPane() );
			Toolkit toolkit = Toolkit.getDefaultToolkit();
			Image image = toolkit.getImage("icon.gif");
			frame.setIconImage(image);

			frame.addComponentListener(this);

			frame.setResizable(false);
			frame.pack();
			Dimension d = Toolkit.getDefaultToolkit().getScreenSize();
			Point     p = new Point();
			p.setLocation((d.getWidth()/2) - (frame.getWidth()/2), (d.getHeight()/2)-(frame.getHeight()/2));
			frame.setLocation(p);
			frame.setVisible( true );
		}

		public void componentHidden(ComponentEvent e) {}
		public void componentMoved(ComponentEvent e) {}
		public void componentShown(ComponentEvent e) {}
		public void componentResized(ComponentEvent e) {}

		public void pauseEmulation(boolean verbose) {
			if(cpuRunner!=null) {
				cpuRunner.suspend();
				if(verbose) addOSDLine("Paused gameboy");
			}
		}

		public void resumeEmulation(boolean verbose) {
			if((cpuRunner!=null)&&(cart!=null)) {
				cpuRunner.resume();
				if(verbose) addOSDLine("Unpaused gameboy");
			}
		}

		public void actionPerformed( ActionEvent e ) {
/*				JMenuItem source = ( JMenuItem )( e.getSource() );
				String s = "Menu Item source: " + source.getText()
			           + " (an instance of " + getClassName( source ) + ")";
				System.out.println(s);*/
			if (e.getSource().equals( menuitemExit)) {
				System.exit(0);
			}
			else if (e.getSource().equals( menuitemScale1x )) {
				addOSDLine("Set scaling: Scale1x");
				VC.nscale = 1;
 				grfx.setPreferredSize( new Dimension( 160*cpu.VC.nscale, 144*cpu.VC.nscale ) ); //quadruple each pixel
				grfx.setSize( new Dimension( 160*cpu.VC.nscale, 144*cpu.VC.nscale ) ); //quadruple each pixel
				frame.pack();
			}
			else if (e.getSource().equals( menuitemScale2x )) {
				addOSDLine("Set scaling: Scale2x");
				VC.nscale = 2;
 				grfx.setPreferredSize( new Dimension( 160*cpu.VC.nscale, 144*cpu.VC.nscale ) ); //quadruple each pixel
				grfx.setSize( new Dimension( 160*cpu.VC.nscale, 144*cpu.VC.nscale ) ); //quadruple each pixel
				frame.pack();
			}
			else if (e.getSource().equals( menuitemScale3x )) {
				addOSDLine("Set scaling: Scale3x");
				VC.nscale = 3;
 				grfx.setPreferredSize( new Dimension( 160*cpu.VC.nscale, 144*cpu.VC.nscale ) ); //quadruple each pixel
				grfx.setSize( new Dimension( 160*cpu.VC.nscale, 144*cpu.VC.nscale ) ); //quadruple each pixel
				frame.pack();
			}
			else if (e.getSource().equals( menuitemScale4x )) {
				addOSDLine("Set scaling: Scale4x");
				VC.nscale = 4;
 				grfx.setPreferredSize( new Dimension( 160*cpu.VC.nscale, 144*cpu.VC.nscale ) ); //quadruple each pixel
				grfx.setSize( new Dimension( 160*cpu.VC.nscale, 144*cpu.VC.nscale ) ); //quadruple each pixel
				frame.pack();
			}
			else if (e.getSource().equals( menuitemIncFrameSkip )) {
				++VC.fskip;
				addOSDLine("Increased frameskip: "+VC.fskip);
			}
			else if (e.getSource().equals( menuitemDecFrameSkip )) {
				if (VC.fskip>1) --VC.fskip;
				addOSDLine("Decreased frameskip: "+VC.fskip);
			}
			else if (e.getSource().equals( menuitemSoundEnable )) {
				cpu.AC.isMuted = false;
				addOSDLine("Enabled sound");
			}
			else if (e.getSource().equals( menuitemSoundDisable )) {
				cpu.AC.isMuted = true;
				addOSDLine("Disabled sound");
			}
			else if (e.getSource().equals( menuitemSoundToggle )) {
				cpu.AC.isMuted = !cpu.AC.isMuted;
				addOSDLine(cpu.AC.isMuted ? "Disabled sound" : "Enabled sound");
			}
			else if (e.getSource().equals( menuitemSoundChannel1)) {
				cpu.AC.toggleChannelOnOff(1);
				addOSDLine(cpu.AC.S1.muted==0 ? "Disabled soundchannel 1" : "Enabled soundchannel 1");
			}
			else if (e.getSource().equals( menuitemSoundChannel2)) {
				cpu.AC.toggleChannelOnOff(2);
				addOSDLine(cpu.AC.S2.muted==0 ? "Disabled soundchannel 2" : "Enabled soundchannel 2");
			}
			else if (e.getSource().equals( menuitemSoundChannel3)) {
				cpu.AC.toggleChannelOnOff(3);
				addOSDLine(cpu.AC.S3.muted==0 ? "Disabled soundchannel 3" : "Enabled soundchannel 3");
			}
			else if (e.getSource().equals( menuitemSoundChannel4)) {
				cpu.AC.toggleChannelOnOff(4);
				addOSDLine(cpu.AC.S4.muted==0 ? "Disabled soundchannel 4" : "Enabled soundchannel 4");
			}
			else if (e.getSource().equals( menuitemToggleCheats)) {
				cheatcodes.ToggleCheats(cart);
				addOSDLine("Toggled cheats " + (cheatcodes.UseCheats?"on":"off") );
			}
			else if (e.getSource().equals( menuitemConfigKeys )) {
				keyConfigDialog k=new keyConfigDialog(frame, keyMap);
				pauseEmulation(false);
				k.getKeyCodes();
				saveKeyBinds();
				applyAccelerators();
				resumeEmulation(false);
			}
#ifdef SCALEBUILDER
			else if (e.getSource().equals( menuitemScaleBuilder)) {
				ScaleBuilder sb = new ScaleBuilder(frame);
				//sb.showOpenDialog();
			}
#endif
			else if (e.getSource().equals( menuitemCheats)) {
				pauseEmulation(false);
				cheatcodes.editCodes();
				cheatcodes.applyCheatCodes(cart);
				resumeEmulation(false);
				addOSDLine("ZOMG CHEATER!!!!");
			}
			else if (e.getSource().equals( menuitemColorSchemeCustom )) {

				if ( !cpu.isCGB() ) {
					cs.setDefault( VC.getGrayShade(0),
					 	             VC.getGrayShade(1),
					 	             VC.getGrayShade(2));
					cs.setVisible( true );
				}
				else {
					JOptionPane.showMessageDialog(frame,
                                        "You are not allowed to change colors",
                                        "color error",
					                              JOptionPane.ERROR_MESSAGE);
				}

			}
			else if(e.getSource().equals( menuitemOpenROM )) {
				JFileChooser fc;
				if (rcFiles.size() > 0) {
					String lastpath = (String)rcFiles.elementAt(0);
					int slashPos = lastpath.lastIndexOf(File.separator);
					lastpath = lastpath.substring(0, slashPos+1);
					fc = new JFileChooser(lastpath);
				}
				else
					fc = new JFileChooser(".");

				// Show open dialog; this method does not return until the dialog is closed
				fc.showOpenDialog(frame);
				File selFile = fc.getSelectedFile();
				if(selFile != null) {
					System.out.println(selFile.getAbsolutePath());

					pauseEmulation(false);
					cart=new Cartridge(selFile.getAbsolutePath());
					CPU.loadCartridge(cart);
					updateCartName(selFile.getAbsolutePath());
					cheatcodes = new CheatCodeEditor(frame, curcartname);
					cheatcodes.applyCheatCodes(cart);
					addOSDLine("loaded Rom: " + curcartname);

					resumeEmulation(false);
				}
			}
			else if(e.getSource().equals( menuitemLinkServe )) {
				try {
					CPU.serveLink();
				}
				catch (IOException ioe) {
					JOptionPane.showMessageDialog(frame, "Failed: " + ioe.getMessage(), "Error!", JOptionPane.ERROR_MESSAGE);
				}
			}
			else if(e.getSource().equals( menuitemLinkSever )) {
				CPU.severLink();
			}
			else if(e.getSource().equals( menuitemLinkClient )) {
				try {
					CPU.clientLink((String)JOptionPane.showInputDialog(frame, (Object)"Enter host address", "Link setup", JOptionPane.QUESTION_MESSAGE, null, null, "localhost"));
				}
				catch (IOException ioe) {
					JOptionPane.showMessageDialog(frame, "Failed: " + ioe.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
				}
			}
			else if(e.getSource().equals( menuitemSaveState )) {
				if (!CPU.canRun()) return;
				pauseEmulation(false);
				String stname = System.getProperty("user.home")+File.separator+ ".jgbe"+File.separator;
				File jgbedir=new File(stname);
				if(!jgbedir.exists()) if(!jgbedir.mkdir()) PRINTF("failed!\n");
				stname += "savestates"+File.separator;
				File sstatedir=new File(stname);
				if(!sstatedir.exists()) if(!sstatedir.mkdir()) PRINTF("failed!\n");
				if(sstatedir.exists()) {
					stname += curcartname + ".st" + selectedState;
					addOSDLine("Saving State "+selectedState);
					try {
						DataOutputStream dostream = FHandler.getDataOutputStream(stname);
						CPU.saveState(dostream);
						dostream.close();
					}
					catch (java.io.IOException ioe) {
						System.out.println("Error saving state! ");
					};
				}
				resumeEmulation(false);
			}
			else if(e.getSource().equals( menuitemLoadState )) {
				if (!CPU.canRun()) return;
				pauseEmulation(false);
				String stname = System.getProperty("user.home")+File.separator+".jgbe"+File.separator+"savestates"+File.separator + curcartname + ".st" + selectedState;
				addOSDLine("Loading State "+selectedState);
				try {
					DataInputStream distream = FHandler.getDataInputStream(stname);
					CPU.loadState(distream);
					distream.close();
				}
				catch (java.io.IOException ioe) {
					System.out.println("Error loading state! " + ioe.getMessage());
				};
				resumeEmulation(false);
			}
			else if(e.getSource().equals( menuitemPause )) {
				if(cpuRunner.isRunning())
					pauseEmulation(true);
				else
					resumeEmulation(true);
			}
			else if(e.getSource().equals( menuitemReset )) {
				pauseEmulation(false);
				cpu.reset();
				resumeEmulation(false);
				addOSDLine("Reset gameboy");
			}
			else if(e.getSource().equals( menuitemEmuSpeedPlus )) {
				double cs = CPU.AC.currentEmulationSpeed;
				double ns = 0.25 + cs;
				CPU.AC.setSpeed(ns);
				addOSDLine("EmuSpeed: "+(int)(ns*100.0)+"."+(int)( (ns*100.0-(int)(ns*100.0)) )+"%");
			}
			else if(e.getSource().equals( menuitemEmuSpeedMinus )) {
				double cs = CPU.AC.currentEmulationSpeed;
				double ns = Math.max(cs-0.25,0);
				CPU.AC.setSpeed(ns);
				addOSDLine("EmuSpeed: "+(int)(ns*100.0)+"."+(int)( (ns*100.0-(int)(ns*100.0)) )+"%");
			}
			else if(e.getSource().equals( menuitemEmuSpeedMul )) {
				double cs = CPU.AC.currentEmulationSpeed;
				double ns = 1.25 * cs;
				CPU.AC.setSpeed(ns);
				addOSDLine("EmuSpeed: "+(int)(ns*100.0)+"."+(int)( (ns*100.0-(int)(ns*100.0)) )+"%");
			}
			else if(e.getSource().equals( menuitemEmuSpeedDiv )) {
				double cs = CPU.AC.currentEmulationSpeed;
				double ns = 0.75 * cs;
				CPU.AC.setSpeed(ns);
				addOSDLine("EmuSpeed: "+(int)(ns*100.0)+"."+(int)( (ns*100.0-(int)(ns*100.0)) )+"%");
			}
			else if(e.getSource().equals( menuitemEmuSpeedNormal )) {
				CPU.AC.setSpeed(1.0);
				addOSDLine("EmuSpeed: 100%");
			}
			else if(e.getSource().equals( menuitemColorSchemeOriginalGameboy )) {
				int[][] c={ {0xa0, 0xe0, 0x20},	// WHITE
										{0x70, 0xb0, 0x40},  // LIGHTGRAY
										{0x40, 0x70, 0x32},  // DARKGRAY
										{0x10, 0x50, 0x26}}; // BLACK
				cpu.VC.setGrayShades(c);
			}
			else if(e.getSource().equals( menuitemColorSchemeBlackAndWhite )) {
				int[][] c={ {0xf8, 0xf8, 0xf8},	// WHITE
										{0xa8, 0xa8, 0xa8},  // LIGHTGRAY
										{0x60, 0x60, 0x60},  // DARKGRAY
										{0x00, 0x00, 0x00}}; // BLACK
				cpu.VC.setGrayShades(c);
			}
			else if(e.getSource().equals( menuitemColorSchemeGreys )) {
				int[][] c={ {0xc5, 0xc5, 0xc5},	// WHITE
										{0x9a, 0x9a, 0x9a},  // LIGHTGRAY
										{0x61, 0x61, 0x61},  // DARKGRAY
										{0x3f, 0x3f, 0x3f}}; // BLACK
				cpu.VC.setGrayShades(c);
			}
			else if(e.getSource().equals( menuitemToggleRemoteKeys )) {
				cpu.useRemoteKeys = !cpu.useRemoteKeys;
				addOSDLine("Remote Keys: "+(cpu.useRemoteKeys?"Enabled":"Disabled"));
			}
			else { //timer?
				for (int i = 0; i < 10; ++i) {
					if (e.getSource().equals(menuitemSelectState[i])) {
						selectedState = i;
						addOSDLine("Selected State "+selectedState);
						return;
					}
				}
				if(menuItems!=null)
					for (int i = 0; i < menuItems.length; ++i) {
						if (e.getSource().equals(menuItems[i])) {
							//System.out.println(menuItems[i].getText());

						pauseEmulation(false);
						cart=new Cartridge((String)rcFiles.elementAt(i));
						CPU.loadCartridge(cart);
						updateCartName((String)rcFiles.elementAt(i));
						cheatcodes = new CheatCodeEditor(frame, curcartname);
						cheatcodes.applyCheatCodes(cart);
						addOSDLine("loaded Rom: " + curcartname);

						resumeEmulation(false);
					}
				}
				//System.out.println("timer!");
				long ctime = System.nanoTime();
				long timeLapse =  ctime - FPSTimeMillis;
				FPSTimeMillis = ctime;
				double afps=fps/(timeLapse/1000000000.0);
				double emuspeed = ((int)(afps/(4194304.0/702240000.0)))/100.0;
				frame.setTitle("JGBE V"+JGBE_VERSION_STRING+" - "+((int)(afps*100))/100.0+" fps / "+emuspeed+"%");
				//cpu.AC.srendered = 0;
				fps = 0;
			}
		}
		long FPSTimeMillis = System.nanoTime();

		public void itemStateChanged( ItemEvent e ) {
			JMenuItem source = ( JMenuItem )( e.getSource() );
			String s = "Menu Item source: " + source.getText()
			           + " (an instance of " + getClassName( source ) + ")"
			           + "\n"
			           + "    State of check Box: "
			           + (( e.getStateChange() == ItemEvent.SELECTED ) ?
			              "selected":"unselected" );
			System.out.println( s );
		}

		public void keyTyped(KeyEvent e) {
			//System.out.println("keyTyped");
		}

		static final int[] keyMasks = {
			BUTTON_UP,
			BUTTON_DOWN,
			BUTTON_LEFT,
			BUTTON_RIGHT,
			BUTTON_A,
			BUTTON_B,
			BUTTON_START,
			BUTTON_SELECT,
		};

		public void keyReleased(KeyEvent e) {
			int keyCode = e.getKeyCode();
			int keyModifiers = e.getModifiers();
			int keyState = keyCode | (keyModifiers << 8);

			for(int i=0; i<8; ++i) {
				if((keyMap[i]&0xff)==keyCode) { //Check just the keycode, modifiers don't matter for release
					cpu.releaseButton(keyMasks[i]);
					return;
				}
			}
			for(int i=8; i<16; ++i) {
				if(keyMap[i]==keyState) {
					cpu.releaseRemoteButton(keyMasks[i&7]);
					return;
				}
			}
		}

		public void keyPressed(KeyEvent e) {
			int keyCode = e.getKeyCode();
			int keyModifiers = e.getModifiers();
			int keyState = keyCode | (keyModifiers << 8);

			for(int i=0; i<8; ++i) {
				if(keyMap[i]==keyState) {
					cpu.pressButton(keyMasks[i]);
					return;
				}
			}
			for(int i=8; i<16; ++i) {
				if(keyMap[i]==keyState) {
					cpu.pressRemoteButton(keyMasks[i&7]);
					return;
				}
			}
		}

		public void makeRcFilesMenuItems() {
			int staticMenuItems = 4;

			if (menuFile != null) {
				while (menuFile.getItemCount() > staticMenuItems) {
					menuFile.remove(staticMenuItems);
				}

				menuItems = new JMenuItem[rcFiles.size()];

				menuFile.addSeparator();

				for (int i = 0; i < rcFiles.size(); ++i) {
					String lname = (String)rcFiles.get(i);
					String name = lname.substring(lname.lastIndexOf(File.separator) + 1);
					menuItems[i] = new JMenuItem(name);
					menuFile.add(menuItems[i]);
					menuItems[i].addActionListener(this);
				}
			}

		}


		// Returns the class name, no package info
		protected static String getClassName( Object o ) {
			String classString = o.getClass().getName();
			int dotIndex = classString.lastIndexOf( "." );
			return classString.substring( dotIndex+1 );	//Returns only Class name
		}

		public void loadRCFiles() {
			try {
				String rcfilename = System.getProperty("user.home")+File.separator+".jgbe"+File.separator+"rcfiles.log";
				BufferedReader in = new BufferedReader(new FileReader(rcfilename));
				String str;
				rcFiles.clear();
				while ((str = in.readLine()) != null) {
						rcFiles.add(str);
				}
				in.close();
			} catch (IOException e) {
				System.out.println("error reading rcfiles.log");
			}
		}

		public void saveRCFiles() {
			try {
				String rcfilename = System.getProperty("user.home")+File.separator+".jgbe"+File.separator+"rcfiles.log";
				BufferedWriter out = new BufferedWriter(new FileWriter(rcfilename));
				String str;
				int num = MIN(10, rcFiles.size());
				for (int i = 0; i < num; ++i) {
					str = (String)rcFiles.elementAt(i);
					out.write(str, 0, str.length());
					out.newLine();
				}
				out.close();
			} catch (IOException e) {
				System.out.println("error writing rcfiles.log");
			}
			makeRcFilesMenuItems();
		}

		#define PRINT_KEY_DEFAULT PRINTLN((keyMap[i]>>8>0 ? \
		                                  KeyEvent.getKeyModifiersText(keyMap[i]>>8)+"+" : "") +\
		                                  KeyEvent.getKeyText(keyMap[i]&0xff))
		private void saveKeyBinds() {
			DataOutputStream distream=null;
			try {
				String path=FHandler.EnsureExists(""); //ensure JGBE Config dir exists
				FileOutputStream fistream = new FileOutputStream(path+"keys.conf");
				distream = new DataOutputStream(fistream);
				for(int i=0; i<16+nrOfShortCuts; ++i) {
					distream.writeInt(keyMap[i]);
//  					PRINT_KEY_DEFAULT;
				}
			}
			catch(IOException e) { //File not found or error reading it
					JOptionPane.showMessageDialog(frame,
                                        "Could not save keybinds!",
                                        "Error",
					                              JOptionPane.ERROR_MESSAGE);
			}
			finally {
				try {
					distream.close();
				}
				catch(Exception e) {
				}
			}
		}

		private void loadKeyBinds() {
			DataInputStream distream=null;
			try {
				String path=FHandler.EnsureExists(""); //ensure JGBE Config dir exists
				FileInputStream fistream = new FileInputStream(path+"keys.conf");
				distream = new DataInputStream(fistream);
				for(int i=0; i<16+nrOfShortCuts; ++i) {
						keyMap[i] = distream.readInt();
				}
			}
			catch(IOException e) { //File not found or error reading it
				pauseEmulation(false);
				JOptionPane.showMessageDialog(frame,
																			"Keys need to be configured",
																			"Warning",
																			JOptionPane.WARNING_MESSAGE);
				generateDefaultKeyBinds();
				keyConfigDialog k=new keyConfigDialog(frame,keyMap);
				k.getKeyCodes();
				saveKeyBinds();
				resumeEmulation(false);
			}
			finally {
				try {
					applyAccelerators();
					distream.close();
				}
				catch(Exception e) {
				}
			}
		}

		private void generateDefaultKeyBinds() {
			//Magix
			keyMap[0]=38; // Up
			keyMap[1]=40; // Down
			keyMap[2]=37; // Left
			keyMap[3]=39; // Right
			keyMap[4]=90; // Z
			keyMap[5]=88; // X
			keyMap[6]=61; // Equals
			keyMap[7]=45; // Minus
			keyMap[8]=73; // I
			keyMap[9]=75; // K
			keyMap[10]=74; // J
			keyMap[11]=76; // L
			keyMap[12]=91; // Open Bracket
			keyMap[13]=93; // Close Bracket
			keyMap[14]=222; // Quote
			keyMap[15]=59; // Semicolon
			keyMap[16]=556; // Ctrl+Comma
			keyMap[17]=591; // Ctrl+O
			keyMap[18]=19; // Pause
			keyMap[19]=594; // Ctrl+R
			keyMap[20]=593; // Ctrl+Q
			keyMap[21]=561; // Ctrl+1
			keyMap[22]=562; // Ctrl+2
			keyMap[23]=563; // Ctrl+3
			keyMap[24]=564; // Ctrl+4
			keyMap[25]=605; // Ctrl+Close Bracket
			keyMap[26]=603; // Ctrl+Open Bracket
			keyMap[27]=560; // Ctrl+0
			keyMap[28]=569; // Ctrl+9
			keyMap[29]=568; // Ctrl+8
			keyMap[30]=567; // Ctrl+7
			keyMap[31]=595; // Ctrl+S
			keyMap[32]=588; // Ctrl+L
			keyMap[33]=577; // Ctrl+A
			keyMap[34]=2097; // Alt+1
			keyMap[35]=2098; // Alt+2
			keyMap[36]=2099; // Alt+3
			keyMap[37]=2100; // Alt+4
			keyMap[38]=704; // Ctrl+Back Quote
			keyMap[39]=604; // Ctrl+Back Slash
			keyMap[40]=829; // Ctrl+Shift+Equals
			keyMap[41]=557; // Ctrl+Minus
			keyMap[42]=861; // Ctrl+Shift+Close Bracket
			keyMap[43]=859; // Ctrl+Shift+Open Bracket
			keyMap[44]=573; // Ctrl+Equals
		}

		static Cartridge cart = null;
		public static void main( String[] args ) {
			final swinggui gui=new swinggui();

			gui.loadRCFiles();

			boolean sound=true, debug=false, lastcart=false;
			String romfile="", logfile="";
			for (int i = 0; i < args.length; ++i) {
				if (args[i].charAt(0)!='-')
					romfile = args[i];
				if (args[i].equals("-log"))
					logfile = args[++i];
				if (args[i].equals("-nosound"))
					sound = false;
				if (args[i].equals("-debug"))
					debug = true;
				if ((args[i].equals("-lastcart"))) //TODO: FIXME: Invert this (current behavious is a work-around)
					lastcart=true;
			}
			if(lastcart && (gui.rcFiles.size() > 0))
				romfile = (String)gui.rcFiles.elementAt(0);

			if (!romfile.equals("")) {
				cart = new Cartridge(romfile);
				if(cart.getError()!=null) {
					System.out.println("ERROR: "+cart.getError());
					cart = null;
				}
				else {
					gui.updateCartName(romfile);
					System.out.println("Succesfully loaded ROM :)");
				}
			}

			gui.cpu = new CPU();
			gui.VC = gui.cpu.VC;
			gui.cs = new ColorSelector( gui.VC );

			gui.createAndShowGUI();
			gui.loadKeyBinds();
			cheatcodes = new CheatCodeEditor(frame, curcartname);
			cheatcodes.applyCheatCodes(cart);
			gui.cpu.VC.addListener(gui.grfx);
			if (!sound)
				gui.cpu.AC.isMuted = true;

			Timer timer = new Timer(1000, gui);
			timer.setInitialDelay(1000);
			timer.start();

			if (cart != null)
				gui.cpu.loadCartridge(cart);

			gui.makeRcFilesMenuItems();

			/*DEBUGGER*/
			if (debug) {
				Debugger dbgr = new Debugger(gui, logfile); //The GUI to which this debugger belongs
				gui.cpuRunner = dbgr.runner;
			}
			else {
				gui.cpuRunner = new SimpleCPURunner();
				gui.resumeEmulation(false);
			}
		}
	}
#endif
