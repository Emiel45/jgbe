#include "Global.inc"
import java.io.*;
#ifdef USE_JAVA_142
import javax.microedition.lcdui.*;
import javax.microedition.lcdui.game.GameCanvas;
#else
import javax.swing.*;
import java.awt.*;
import java.awt.image.*;
#endif

public class VideoController {
	private static final int MIN_WIDTH  = 160;
	private static final int MIN_HEIGHT = 144;

#ifdef USE_JAVA_142
	private Graphics listener = null;
#else
	private JPanel listener = null;
	private Image drawImg[];
	private int drawData[];
#endif
	private int curDrawImg = 0;

	private int CurrentVRAMBank=0;
	//private int VRAM[][]=new int[2][0x2000]; //8k per bank;
	protected int VRAM[]=new int[0x4000]; //8k per bank;
	protected int OAM[]=new int[0xa0]; //Sprite Attribute Table;

	protected boolean isCGB;

	protected int LY=0;
	protected int LYC=0;
	protected int SCX=0;
	protected int SCY=0;
	protected int WX=0;
	protected int WY=0;
	protected int LCDC=0;
	protected int STAT=0; // FF41 - STAT - LCDC Status (R/W)

// 	protected int GRAYSHADES[][] = {
// 	                                 {0xFF, 0xFF, 0xFF},   // WHITE
// 	                                 {0xD3, 0xD3, 0xE3},   // LIGHTGRAY
// 	                                 {0xBE, 0xBE, 0xBE},   // DARKGRAY
// 	                                 {0x00, 0x00, 0x00} }; // BLACK

 	// Looks a lot like Origional Gameboy
 	protected int GRAYSHADES[][] = { {0xa0, 0xe0, 0x20},   // WHITE
 	                                 {0x70, 0xb0, 0x40},   // LIGHTGRAY
 	                                 {0x40, 0x70, 0x32},   // DARKGRAY
 	                                 {0x10, 0x50, 0x26} }; // BLACK

	protected int BGPI=0;              //BCPS/BGPI - CGB Mode Only - Background Palette Index
	private int BGPD[]=new int[8*4*2]; //BCPD/BGPD - CGB Mode Only - Background Palette Data

	protected int OBPI=0;              //OCPS/OBPI - CGB Mode Only - Sprite Palette Index
	private int OBPD[]=new int[8*4*2]; //OCPD/OBPD - CGB Mode Only - Sprite Palette Data

	/* caching vars */
#ifdef USE_JAVA_142
#define BLITPIXTYPE int[]
	private int blitImg[][][]=new int[144][160][3]; // [y][x]
	private int palColors[][] = new int[8*4*2][3];
// 	private Color colColors[] = new Color[8*4*2];
#else
#define BLITPIXTYPE int
	private BLITPIXTYPE blitImg[][] =new BLITPIXTYPE[144][160]; // [y][x]
	private BLITPIXTYPE palColors[] = new BLITPIXTYPE[8*4*2];
#endif
	private int patpix[][][] = new int[4096][][]; // see updatepatpix()
	private boolean patdirty[] = new boolean[1024]; // see updatepatpix()
	private boolean anydirty = true;                // see updatepatpix()
// 	private boolean alldirty = true;                // see updatepatpix()

	private CPU cpu; // dont think we need this... //yes we do, we need interrupts

	private long pfreq;
	private long ptick;
	private long ftick;

	private int scale = 2;
	public int nscale = 2;
	private int cfskip = 0;
	public int fskip = 1; // 1 is off

	public void reset() {
		this.isCGB = cpu.isCGB();
		CurrentVRAMBank=0;
		LY=0;
		LYC=0;
		SCX=0;
		SCY=0;
		WX=0;
		WY=0;
		LCDC=0;
		STAT=0; // FF41 - STAT - LCDC Status (R/W)
		BGPI=0;              //BCPS/BGPI - CGB Mode Only - Background Palette Index
		OBPI=0;              //OCPS/OBPI - CGB Mode Only - Sprite Palette Index
		anydirty = true;                // see updatepatpix()
		for(int i=0; i<1024; ++i) {
			patdirty[i]=true;
		}
		updatepatpix();

		for (int i = 0; i < 0x20; ++i) {
			OBPD[i*2] = OBPD[i*2+1] = 0;
			BGPD[i*2] = BGPD[i*2+1] = 0;
			updateBGColData(i);
			updateOBColData(i);
		};
		updateMonoColData(0);
		updateMonoColData(1);
		updateMonoColData(2);

		for (int i = 0; i < 0xa0; ++i)
			OAM[i] = 0;
		for (int i = 0; i < 0x4000; ++i)
			VRAM[i] = 0;
	}

	public VideoController(CPU cpu, int image_width, int image_height) {
		this.cpu = cpu;
#ifndef USE_JAVA_142
		drawImg=new Image[2];
#endif
		scale();
	}


	SAVELOAD_FUNCTION {
		SL_INT(CurrentVRAMBank);
		SL_ARR(UINT8, VRAM, 0x4000);
		SL_ARR(UINT8, OAM, 0xa0);

		//SL_BOOL(isCGB); should be correct already

		SL_UINT8(LY);
		SL_UINT8(LYC);
		SL_UINT8(SCX);
		SL_UINT8(SCY);
		SL_UINT8(WX);
		SL_UINT8(WY);
		SL_UINT8(LCDC);
		SL_UINT8(STAT);

		SL_UINT8(BGPI);
		SL_ARR(UINT8, BGPD, 8*4*2);

		SL_UINT8(OBPI);
		SL_ARR(UINT8, OBPD, 8*4*2);

		if (SL_LOAD) {
			for(int i=0; i<1024; ++i) {
				patdirty[i]=true;
			}
			anydirty = true;
			for (int i = 0; i < 0x20; ++i) {
				updateBGColData(i);
				updateOBColData(i);
			};
			updateMonoColData(0);
			updateMonoColData(1);
			updateMonoColData(2);
		}
	}

#ifndef USE_JAVA_142
	final public void addListener(JPanel panel) {

		listener = panel; // only 1 listener at a time currently :-p
		//drawImg[1]=new BufferedImage(160, 144, BufferedImage.TYPE_3BYTE_BGR);
		this.scale();
	}
#else
	final public void addListener(Graphics grfx) {
		listener = grfx;
		//this.scale(drawImg[0].getWidth(null), drawImg[0].getHeight(null));
	}
#endif

	private void scale() {
		scale = nscale;
		int width = scale*MIN_WIDTH;
		int height = scale*MIN_HEIGHT;
		drawData = new int[width*height];
#ifndef USE_JAVA_142
		if (listener == null) {
			System.out.println("creating BufferedImage's");
			drawImg[0]=new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
			drawImg[1]=new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
		} else {
			System.out.println("creating VolatileImage's");
			// we dont reall create volatile images cause they are slow...
			// maybe they work faster on windows... needs testing
			/*
			GraphicsEnvironment ge =GraphicsEnvironment.getLocalGraphicsEnvironment();
			GraphicsDevice gs = ge.getDefaultScreenDevice();
			GraphicsConfiguration gc = gs.getDefaultConfiguration();
			drawImg[0]=gc.createCompatibleImage(width, height);
			drawImg[1]=gc.createCompatibleImage(width, height);
			*/
			//drawImg[0]=listener.createVolatileImage(width, height);
			//drawImg[1]=listener.createVolatileImage(width, height);
			drawImg[0]=new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
			drawImg[1]=new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
			//source = new MemoryImageSource(width, height, drawData, 0, width);
	    //source.setAnimated(true);
	    //source.setFullBufferUpdates(true);
			//Image offscreen = Toolkit.getDefaultToolkit().createImage(source);
			//drawImg[0] = offscreen;
			//drawImg[1] = offscreen;
		}
#endif
	}

#ifndef USE_JAVA_142
	final public Image getImage() {
		// return ((VolatileImage)drawImg[curDrawImg]).getScaledInstance(image_width, image_height,Image.SCALE_FAST); // display image not being drawn to
		return drawImg[curDrawImg]; // display image not being drawn to
	}
#endif

	final private void palQuadify(int[] col) {
		for (int i=0; i<3; ++i) {
			col[3+i] = col[i];
			col[6+i] = col[i];
			col[9+i] = col[i];
		}
	}

	final private void palChange(int palcol, int r, int g, int b) {
#ifdef USE_JAVA_142
		palColors[palcol][0] = r;
		palColors[palcol][1] = g;
		palColors[palcol][2] = b;
//
// 		colColors[palcol] = new Color(r,g,b);
#else
		palColors[palcol] =
		/*	((BufferedImage)drawImg[curDrawImg^1]).
			getColorModel().
			getDataElements((r<<16)|(g<<8)|(b<<0), null);
		*/
		((r<<16)|(g<<8)|(b<<0));
#endif
	}

#define DRAWPIX(x, pal, col) { \
		blitLine[x] = palColors[pal | col]; \
} \

// blitting using WritableRaster
#define BLIT_PIX_WR(x,y, col) \
	wr.setPixel(x,y, intColors[col])

#define BLIT_PIX_W2(x,y, col) \
	wr.setDataElements(x,y, palColors[col])

#define BLIT_PIX_W3(x,y, col) {\
	int[] tmp = new int[1]; \
	tmp[0] = col; \
	wr.setDataElements(x,y, tmp); \
}

#define BLIT_PIX_W4(x,y, col) \
//	wr.setDataElements(0,y,x,1, col)

#define BLIT_PIX_W5(x,y, col) \
	drawData[((y)*MIN_WIDTH*scale)+(x)] = col
//	wr.setDataElements(0,y,x,1, col)

#define BLIT_PIX_WI(i, col) \
	drawData[++i] = col
//	wr.setDataElements(0,y,x,1, col)


#define BLIT_PIX_GR(x,y, col) { \
	g.setColor(colColors[col]); \
	g.drawRect(x,y, 0, 0); \
}

#define BLIT_PIX_USE_JAVA_142(x,y, col) { \
	int[] tcol = col; \
	listener.setColor(tcol[0], tcol[1], tcol[2]); \
	listener.drawRect(x,y, 0, 0); \
}

#define EQ(a,b) ((a) == (b))
//#define EQ(a,b) ((a).equals(b))

#ifndef USE_JAVA_142
#define BLIT_PIX BLIT_PIX_W5
#else
#define BLIT_PIX BLIT_PIX_USE_JAVA_142
#endif

	//static long lastms = System.nanoTime();
	static long lastms;
// 	static int fps23fix=0;
	final private void blitImage() {
		if (scale != nscale) scale();
		//Graphics g = drawImg[curDrawImg^1].getGraphics();
#ifndef USE_JAVA_142
		WritableRaster wr = ((BufferedImage)drawImg[curDrawImg^1]).getRaster();
#endif
		if (scale == 1) {
			for (int y = 0; y < 144; ++y) {
				BLITPIXTYPE[] blitLine = blitImg[y];
//				for (int x = 0; x < 160; ++x)	 {
//					BLIT_PIX(x, y, blitLine[x]);
//				}
				wr.setDataElements(0,y,160,1, blitLine);
			}
		}
		else if (scale == 2) {
			// 'scale2x' algo // http://scale2x.sourceforge.net/algorithm.html
			#define A blitLine1[xn]
			#define B blitLine1[x]
			#define C blitLine1[xp]
			#define D blitLine2[xn]
			#define E blitLine2[x]
			#define F blitLine2[xp]
			#define G blitLine3[xn]
			#define H blitLine3[x]
			#define I blitLine3[xp]
			int ti1 = -1, ti2 = -1;
			ti2 += 160*2;
			for (int y = 0; y < 144; ++y) {
				int yn = (y==0  )?0  :y-1;
				int yp = (y==143)?143:y+1;
				BLITPIXTYPE[] blitLine2 = blitImg[y];
				BLITPIXTYPE[] blitLine1 = blitImg[yn];
				BLITPIXTYPE[] blitLine3 = blitImg[yp];
				for (int x = 0; x < 160; ++x) {
					int xn = (x==0  )?0  :x-1;
					int xp = (x==159)?159:x+1;
					if (!EQ(blitLine2[xn], blitLine2[xp])
					&&  !EQ(blitLine1[x] , blitLine3[x])) {
						BLIT_PIX_WI(ti1, EQ(B, D) ? D : E);
						BLIT_PIX_WI(ti1, EQ(B, F) ? F : E);
						BLIT_PIX_WI(ti2, EQ(H, D) ? D : E);
						BLIT_PIX_WI(ti2, EQ(H, F) ? F : E);
					}
					else {
						BLITPIXTYPE col = E;
						BLIT_PIX_WI(ti1, col);
						BLIT_PIX_WI(ti1, col);
						BLIT_PIX_WI(ti2, col);
						BLIT_PIX_WI(ti2, col);
					}
				}
				ti1 += 160*2;
				ti2 += 160*2;
			}
			wr.setDataElements(0,0,160*scale,144*scale, drawData);
		} else if (scale == 3) {
			// 'scale3x' algo // http://scale2x.sourceforge.net/algorithm.html
			int ti1 = -1, ti2 = -1, ti3 = -1;
			ti2 += 160*3;
			ti3 += 160*3*2;
			for (int y = 0; y < 144; ++y) {
				int yn = (y==0  )?0  :y-1;
				int yp = (y==143)?143:y+1;
				BLITPIXTYPE[] blitLine2 = blitImg[y];
				BLITPIXTYPE[] blitLine1 = blitImg[yn];
				BLITPIXTYPE[] blitLine3 = blitImg[yp];
				for (int x = 0; x < 160; ++x) {
					int xn = (x==0  )?0  :x-1;
					int xp = (x==159)?159:x+1;
					if (!EQ(B, H) && !EQ(D, F)) {
						BLIT_PIX_WI(ti1 , EQ(D, B) ? D : E);
						BLIT_PIX_WI(ti1 , (EQ(D, B) && !EQ(E, C)) || (EQ(B, F) && !EQ(E, A))? B : E);
						BLIT_PIX_WI(ti1 , EQ(B, F) ? F : E);
						BLIT_PIX_WI(ti2 , (EQ(D, B) && !EQ(E, G)) || (EQ(D, H) && !EQ(E, A))? D : E);
						BLIT_PIX_WI(ti2 , E);
						BLIT_PIX_WI(ti2 , (EQ(B, F) && !EQ(E, I)) || (EQ(H, F) && !EQ(E, C))? F : E);
						BLIT_PIX_WI(ti3 , EQ(D, H) ? D : E);
						BLIT_PIX_WI(ti3 , (EQ(D, H) && !EQ(E, I)) || (EQ(H, F) && !EQ(E, G))? H : E);
						BLIT_PIX_WI(ti3 , EQ(H, F) ? F : E);
					} else {
						BLITPIXTYPE col = E;
						BLIT_PIX_WI(ti1 , col);
						BLIT_PIX_WI(ti1 , col);
						BLIT_PIX_WI(ti1 , col);
						BLIT_PIX_WI(ti2 , col);
						BLIT_PIX_WI(ti2 , col);
						BLIT_PIX_WI(ti2 , col);
						BLIT_PIX_WI(ti3 , col);
						BLIT_PIX_WI(ti3 , col);
						BLIT_PIX_WI(ti3 , col);
					}
				}
				ti1 += 160*3*2;
				ti2 += 160*3*2;
				ti3 += 160*3*2;
			}
			wr.setDataElements(0,0,160*scale,144*scale, drawData);
		}
		else if (scale == 4) {
			// 'scale2x' algo // http://scale2x.sourceforge.net/algorithm.html
			int ti1 = -1, ti2 = -1, ti3 = -1, ti4 = -1;
			ti2 += 160*4;
			ti3 += 160*4*2;
			ti4 += 160*4*3;
			for (int y = 0; y < 144; ++y) {
				int yn = (y==0  )?0  :y-1;
				int yp = (y==143)?143:y+1;
				BLITPIXTYPE[] blitLine2 = blitImg[y];
				BLITPIXTYPE[] blitLine1 = blitImg[yn];
				BLITPIXTYPE[] blitLine3 = blitImg[yp];
				for (int x = 0; x < 160; ++x) {
					int xn = (x==0  )?0  :x-1;
					int xp = (x==159)?159:x+1;
					BLIT_PIX_WI(ti1, EQ(B, D) ? B : E);
					BLIT_PIX_WI(ti1, EQ(B, D) ? B : E);
					BLIT_PIX_WI(ti1, EQ(B, F) ? B : E);
					BLIT_PIX_WI(ti1, EQ(B, F) ? B : E);
					BLIT_PIX_WI(ti2, EQ(B, D) ? B : E);
					BLIT_PIX_WI(ti2, E);
					BLIT_PIX_WI(ti2, E);
					BLIT_PIX_WI(ti2, EQ(B, F) ? B : E);
					BLIT_PIX_WI(ti3, EQ(H, D) ? H : E);
					BLIT_PIX_WI(ti3, E);
					BLIT_PIX_WI(ti3, E);
					BLIT_PIX_WI(ti3, EQ(H, F) ? H : E);
					BLIT_PIX_WI(ti4, EQ(H, D) ? H : E);
					BLIT_PIX_WI(ti4, EQ(H, D) ? H : E);
					BLIT_PIX_WI(ti4, EQ(H, F) ? H : E);
					BLIT_PIX_WI(ti4, EQ(H, F) ? H : E);
				}
				ti1 += 160*4*3;
				ti2 += 160*4*3;
				ti3 += 160*4*3;
				ti4 += 160*4*3;
			}
			wr.setDataElements(0,0,160*scale,144*scale, drawData);
		}
		//source.newPixels();
		curDrawImg ^= 1;
#undef A
#undef B
#undef C
#undef D
#undef E
#undef F
#undef G
#undef H
#undef I
	}

	final public void updateMonoColData(int index) {
		// index = 0 -> FF47 - BGP - BG Palette Data (R/W) - Non CGB Mode Only
		// index = 1 -> FF48 - OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only
		// index = 2 -> FF49 - OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only

		if (isCGB) return;

		int value = CPU.read(index + 0xff47); // could fix this to hold those values ourselves..

		if (index==0) index= (0x20>>2);
		else --index;
		int temp[] = new int[3];
		temp = GRAYSHADES[(value>>0)&3]; palChange((index<<2) | 0, temp[0], temp[1], temp[2]);
		temp = GRAYSHADES[(value>>2)&3]; palChange((index<<2) | 1, temp[0], temp[1], temp[2]);
		temp = GRAYSHADES[(value>>4)&3]; palChange((index<<2) | 2, temp[0], temp[1], temp[2]);
		temp = GRAYSHADES[(value>>6)&3]; palChange((index<<2) | 3, temp[0], temp[1], temp[2]);
	}

	final public void setBGColData(int value) {
		BGPD[BGPI&0x3f] = value;
		int bnum = (BGPI & 0x3e) >> 1;
		updateBGColData(bnum);
		if ((BGPI&(1<<7))!=0)
			++BGPI;
	}

	final public void updateBGColData(int bnum) {
		int base = bnum << 1;

		// calculate color now
		int data = BGPD[base] | (BGPD[base+1]<<8);
		int palnum = base >> 3;
		int colnum = (base >> 1) & 3;
		int r = (data >>  0) & 0x1F;
		int g = (data >>  5) & 0x1F;
		int b = (data >> 10) & 0x1F;

		r <<= 3; r |= (r >> 5);
		g <<= 3; g |= (g >> 5);
		b <<= 3; b |= (b >> 5);
		// TODO gb->vga rgb conv
		// i think that was it... gnuboy doesnt seem
		// to do anything more and there it works
		// fading issue is somethere else, maybe int timing issue?

		palChange((palnum << 2) | colnum | 0x20, r, g, b);
	}

	final public int getBGColData() {
		return BGPD[BGPI&0x3f];
	}

	final public void setOBColData(int value) {
		OBPD[OBPI&0x3f] = value;
		int bnum = (OBPI & 0x3e) >> 1;
		updateOBColData(bnum);
		if ((OBPI&(1<<7))!=0)
			++OBPI;
	}

	final public void updateOBColData(int bnum) {
		int base = bnum << 1;

		// calculate color now
		int data = OBPD[base] | (OBPD[base+1]<<8);
		int palnum = base >> 3;
		int colnum = (base >> 1) & 3;
		int r = (data >>  0) & 0x1F;
		int g = (data >>  5) & 0x1F;
		int b = (data >> 10) & 0x1F;

		r <<= 3; r |= (r >> 5);
		g <<= 3; g |= (g >> 5);
		b <<= 3; b |= (b >> 5);

		palChange((palnum << 2) | colnum, r, g, b);
	}

	final public int getOBColData() {
		return OBPD[OBPI&0x3f];
	}

	/** updates contents of patpix[][][] when it is outdated
	 *
	 *  when anydirty is false nothing will be done
	 *  when alldirty is true all patterns will be updated
	 *  when patdirty[i] is true pattern i will be updated
	 *
	 *  patpix[i] is an 8x8 (y,x) matrix with colors of the tile
	 *  i needs to 0..384-1 or 512..896
	 *
	 *  patpix[   0..1024-1] hold normal patterns
	 *  patpix[1024..2048-1] hold patterns flipped x-wise
	 *  patpix[2048..3072-1] hold patterns flipped y-wise
	 *  patpix[3072..3072-1] hold patterns flipped x-wise and y-wise
	 */
	final private void updatepatpix() {
		if (!anydirty/* && !alldirty*/)
			return;

		for (int i = 0; i < 1024; ++i)
		{
			if (i == 384) i = 512;
			if (i == 896) break;
			if (!patdirty[i]/* && !alldirty*/) continue;
			if (patpix[i]==null) {
				patpix[i]      = new int[8][8];
				patpix[i+1024] = new int[8][8];
				patpix[i+2048] = new int[8][8];
				patpix[i+3072] = new int[8][8];
			}
			patdirty[i] = false;

			for (int y = 0; y < 8; ++y) {
				int lineofs = (i*16) + (y*2);
				for (int x = 0; x < 8; ++x) { // not really x, but 7-x
					// this info is always in bank 0, so read directly from VRAM[0]
					int col = (VRAM[lineofs]>>x)&1;
					col |= ((VRAM[lineofs+1]>>x)&1)<<1;
					patpix[i]     [y]  [7-x] = col;
					patpix[i+1024][y]  [x]   = col;
					patpix[i+2048][7-y][7-x] = col;
					patpix[i+3072][7-y][x]   = col;
				}
			}
		}
		anydirty = false;
		//alldirty = false;
	}

	final public void modeChanged(int mode) {
		STAT &= ~(1<<2);
		if (LY==LYC)
			STAT |= (1<<2);
		if ((mode == 0)
		 && (LY==LYC)
		 && ((STAT&(1<<6))!=0))
			cpu.triggerInterrupt(1);
		if ((mode == 2)
		 && ((STAT&(1<<5))!=0))
			cpu.triggerInterrupt(1);
		if ((mode == 0)
		 && ((STAT&(1<<3))!=0))
			cpu.triggerInterrupt(1);
		if ((mode == 1)
		 && ((STAT&(1<<4))!=0))
			cpu.triggerInterrupt(1);
		if (mode == 1) {
			if (cfskip == 0) {
				blitImage();
#ifndef USE_JAVA_142
				if (listener != null) listener.updateUI();
#endif
			}
			cfskip--;
			if (cfskip < 0) cfskip += fskip;
			cpu.triggerInterrupt(0);
		}
		if ((mode == 0)
		 && (cfskip == 0))
			renderScanLine();
	}

	final public int read(int index) {
		if(index<0x8000) {
			System.out.println("Error: VideoController.read(): Reading from non VideoController-Address "+index);
		}
		else if(index < 0xa000) {
			return VRAM[index-0x8000+CurrentVRAMBank];
		}
		else if(index<0xfe00) {
			System.out.println("Error: VideoController.read(): Reading from non VideoController-Address "+index);
		}
		else if(index<0xfea0) {
			return OAM[index-0xfe00];
		}
		else {
			System.out.println("Error: VideoController.read(): Reading from non VideoController-Address "+index);
		}
		return VRAM[index+CurrentVRAMBank];
	}

	final public void write(int index, int value) {
		if(index<0x8000) {
			System.out.println("Error: VideoController.write(): Writing to non VideoController-Address "+index+" value="+value);
		}
		else if(index < 0xa000) {
			VRAM[index-0x8000+CurrentVRAMBank]=value;
			patdirty[(CurrentVRAMBank>>4)+((index-0x8000)>>4)] = true; // nicked from gnuboy...
			anydirty = true;
			//alldirty = true;
		}
		else if(index<0xfe00) {
			System.out.println("Error: VideoController.write(): Writing to non VideoController-Address "+index+" value="+value);
		}
		else if(index<0xfea0) {
			OAM[index-0xfe00]=value;
		}
		else {
			System.out.println("Error: VideoController.write(): Writing to non VideoController-Address "+index+" value="+value);
		}
	}

	final public void selectVRAMBank(int i) {
		CurrentVRAMBank=i*0x2000;
		if ((i <0) || (i > 1))
			PRINTF("current offset=%x\n",CurrentVRAMBank);
	}

	final public int getcurVRAMBank() {
		return CurrentVRAMBank/0x2000;
	}

	/* rendering of scanline starts here */
	// some global vars for render procedure
	// not thread-safe, who cares!
	private static int TileData;
	private static int BGTileMap;
	private static int WindowTileMap;
	private static int bgY;
	private static int bgTileY;
	private static int bgOffsY;
	private static int bgX;
	private static int bgTileX;
	private static int bgOffsX;
	private static int windX;
	private static int tilebufBG[] = new int[0x200]; // ? max here could be lower?
	private static BLITPIXTYPE[] blitLine;

#define DRAWPIX_S(x, pal, col) DRAWPIX(x, (pal << 2), col)

	final private void renderScanLine() {
		/* FF40 - LCDC - LCD Control (R/W)
		* Bit 7 - LCD Display Enable             (0=Off, 1=On)
		* Bit 6 - Window Tile Map Display Select (0=9800-9BFF, 1=9C00-9FFF)
		* Bit 5 - Window Display Enable          (0=Off, 1=On)
		* Bit 4 - BG & Window Tile Data Select   (0=8800-97FF, 1=8000-8FFF)
		* Bit 3 - BG Tile Map Display Select     (0=9800-9BFF, 1=9C00-9FFF)
		* Bit 2 - OBJ (Sprite) Size              (0=8x8, 1=8x16)
		* Bit 1 - OBJ (Sprite) Display Enable    (0=Off, 1=On)
		* Bit 0 - BG Display (for CGB see below) (0=Off, 1=On)
		*/
		if((LCDC&(1<<7))!=0) { //LCD enabled

			updatepatpix();

			blitLine = blitImg[LY];

			TileData = ((LCDC&(1<<4))==0) ? 0x0800 : 0x0000;
			BGTileMap = ((LCDC&(1<<3))==0) ? 0x1800 : 0x1c00;
			WindowTileMap = ((LCDC&(1<<6))==0) ? 0x1800 : 0x1c00;

			/* When Bit 0 is cleared, the background and window lose their priority - the sprites will be always
			 * displayed on top of background and window, independently of the priority flags in OAM and BG Map
			 * attributes.
			 */
			int BGPrio = (LCDC&(1<<0)); // ok dunno what exactly this does atm

			windX = 160;
			if(((LCDC&(1<<5))!=0)			 //window display enabled
			&& (WX >= 0) && (WX < 167) // yes this is 160+7
			&& (WY >= 0) && (WY < 144)
			&& (LY >= WY))
				windX = (WX - 7);         // [-8 < wndX < 160]

			renderScanlineBG();

			if (windX < 160) { // window doesnt have height, width
				renderScanlineWindow();
			}

			if((LCDC&(1<<1))!=0) { // sprites enabled
				renderScanlineSprites();
			}
		}
	}

	private int lbgTileY = -1;

	final private void calcBGTileBuf() {
		/*	not really 100% correct...
				if (lbgTileY==bgTileY)
			return;
		lbgTileY=bgTileY;
		*/
		int tileMap = BGTileMap + bgTileX + (bgTileY*32);
		int attrMap = tileMap + 0x2000;
		int bufMap = 0;
		int cnt = ((windX+7) >> 3) + 1;

		for (int i = 0; i < cnt; ++i) {
			int tile = VRAM[tileMap++];
			int attr = VRAM[attrMap++];
			if (TileData == 0x0800) {
				tile ^= 0x80;
				tile += 0x80;
			}
			tilebufBG[bufMap++] = tile |
			 ((attr & 0x08) << 6) |              // bank select
			 ((attr & 0x60) << 5);               // horiz/vert flip
			tilebufBG[bufMap++] = ((attr&7) | 0x08) << 2; // pal select
			if ((tileMap&31)==0) { //if ((attrMap&31)==0)
				tileMap -= 32;
				attrMap -= 32;
			}
		}
	}

	final private void renderScanlineBG() {
		int bufMap = 0;
		int cnt = windX;
		if (cnt == 0) return;

		bgY     = (SCY+LY)&0xFF;
		bgTileY = bgY >> 3;
		bgOffsY = bgY & 7;
		bgX     = SCX; // it wraps, too
		bgTileX = bgX >> 3; // tile x
		bgOffsX = bgX & 7; // x offs

		calcBGTileBuf();

		int PatLine[] = patpix[tilebufBG[bufMap++]][bgOffsY];
		int TilePal = tilebufBG[bufMap++];
		int curX = 0;

		for (int t = bgOffsX; t < 8; ++t, --cnt)
			DRAWPIX(curX++, TilePal, PatLine[t]);

		if (cnt == 0) return;

		while (cnt>=8) {
			PatLine = patpix[tilebufBG[bufMap++]][bgOffsY];
			TilePal = tilebufBG[bufMap++];
			for (int t = 0; t < 8; ++t)
				DRAWPIX(curX++, TilePal, PatLine[t]);
			cnt -= 8;
		}
		PatLine = patpix[tilebufBG[bufMap++]][bgOffsY];
		TilePal = tilebufBG[bufMap++];
		for (int t = 0; cnt > 0; --cnt, ++t)
			DRAWPIX(curX++, TilePal, PatLine[t]);
	}

	final private void calcWindTileBuf() {
		int tileMap = WindowTileMap + (bgTileY*32);
		int attrMap = tileMap + 0x2000;
		int bufMap = 0;
		int cnt = ((160-(windX+7)) >> 3) + 2;

		for (int i = 0; i < cnt; ++i) {
			int tile = VRAM[tileMap++];
			int attr = VRAM[attrMap++];
			if (TileData == 0x0800) {
				tile ^= 0x80;
				tile += 0x80;
			}
			tilebufBG[bufMap++] = tile |
			 ((attr & 0x08) << 6) |              // bank select
			 ((attr & 0x60) << 5);               // horiz/vert flip
			tilebufBG[bufMap++] = ((attr&7) | 0x8) << 2; // pal select
			if ((tileMap&31)==0) { //if ((attrMap&31)==0)
				tileMap -= 32;
				attrMap -= 32;
			}
		}
	}

	final private void renderScanlineWindow() {
		int bufMap = 0;
		int curX = MAX(windX,0);
		int cnt = 160-curX;
		if (cnt == 0)
			return;
		bgY     = LY - WY;
		bgTileY = bgY >> 3;
		bgOffsY = bgY & 7;

		bgOffsX = curX - windX;

		calcWindTileBuf();

		int PatLine[] = patpix[tilebufBG[bufMap++]][bgOffsY];
		int TilePal = tilebufBG[bufMap++];

		for (int t = bgOffsX; (t < 8) && (cnt > 0); ++t, --cnt)
			DRAWPIX(curX++, TilePal, PatLine[t]);

		while (cnt>=8) {
			PatLine = patpix[tilebufBG[bufMap++]][bgOffsY];
			TilePal = tilebufBG[bufMap++];
			for (int t = 0; t < 8; ++t)
				DRAWPIX(curX++, TilePal, PatLine[t]);
			cnt -= 8;
		}
		PatLine = patpix[tilebufBG[bufMap++]][bgOffsY];
		TilePal = tilebufBG[bufMap++];
		for (int t = 0; cnt > 0; --cnt, ++t)
			DRAWPIX(curX++, TilePal, PatLine[t]);
	}

	final private void renderScanlineSprites() {
		boolean spr8x16 = ((LCDC&(1<<2))!=0);

		for (int spr = 0; spr < 40; ++spr) {
			int sprY    = OAM[(spr*4) + 0];
			int sprX    = OAM[(spr*4) + 1];
			int sprNum  = OAM[(spr*4) + 2];
			int sprAttr = OAM[(spr*4) + 3];

			int ofsY = LY - sprY + 16;

			//check if sprite is visible on this scanline
			if ((ofsY >= 0) && (ofsY < (spr8x16 ? 16 : 8))
			&&  (sprX > 0) && (sprX < 168)) {
				if ((sprAttr&(1<<6))!=0) ofsY = (spr8x16 ? 15 : 7) - ofsY;  // vert  flip
				if (spr8x16) {
					sprNum &= ~1;
					sprNum |= (ofsY >= 8) ? 1 : 0;
					ofsY &= 7;
				}

				if ((sprAttr&(1<<3))!=0) sprNum |= (1<<9);  // bank select
				if ((sprAttr&(1<<5))!=0) sprNum |= (1<<10); // horiz flip
				//if ((sprAttr&(1<<6))!=0) sprNum |= (1<<11); // vert flip
				boolean prio = ((sprAttr&(1<<7))==0);

				int palnr;
				if (isCGB)
					palnr = sprAttr & 7;
				else
					palnr = (sprAttr>>4)&1;

				int[] PatLine = patpix[sprNum][ofsY];

				for (int ofsX = 0; ofsX < 8; ++ofsX) {
					int rx = sprX - 8 + ofsX;
					// 0 is transparent color
					int col = PatLine[ofsX];
					if((col != 0) && (rx >= 0) && (rx < 160)
					/*&& (prio || ((blitLine[rx]&0x3c)== 0x20))*/) {
						DRAWPIX_S(rx, palnr, col);
					}
				}
			}
		}
	}
}
