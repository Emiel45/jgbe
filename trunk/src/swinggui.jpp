#include "Global.inc"
#ifndef USE_JAVA_MOBILE
import javax.swing.*;
import javax.swing.event.*;
import java.awt.*;
import java.awt.dnd.*;
import java.awt.datatransfer.*;
import java.awt.event.*;
/* These may be needed for 'true' outline fonts
import java.awt.font.*;
import java.awt.geom.*;*/
import java.util.Scanner;
import java.net.*;
import java.io.*;
import java.util.ArrayList;
import java.awt.image.BufferedImage;

#include "keyConfigDialog.inc"

class MenuItemArray extends ArrayList {
	public void add(JMenuItem b) {
		super.add(b);
	}
	public void add(JMenuItem b, int mnemonic) {
		super.add(b);
		b.setMnemonic(mnemonic);
	}
	public void remove(JMenuItem b) {
		super.remove(b);
	}
	public void addActionListener(ActionListener l) {
		FOREACH(JMenuItem, ab, this)
			ab.addActionListener(l);
	}
	public void addToMenu(JMenu m) {
		FOREACH(JMenuItem, ab, this)
			m.add(ab);
	}
	public boolean contains(Object b) {
		return (b instanceof JMenuItem) && super.contains(b);
	}
	public JMenuItem get(int index) {
		return (JMenuItem)super.get(index);
	}
}

class MenuItemArrayGroup extends MenuItemArray {
	private ButtonGroup grp = new ButtonGroup();
	public void add(JMenuItem b) {
		super.add(b);
		grp.add(b);
	}
	public void add(JMenuItem b, int mnemonic) {
		super.add(b);
		grp.add(b);
	}
	public void remove(JMenuItem b) {
		super.remove(b);
		grp.remove(b);
	}
	public int getSelectedIndex() {
		int i = -1;
		FOREACH(JMenuItem, ab, this) {
			++i;
			if (ab.isSelected())
				return i;
		}
		return -1;
	}
	public void setSelectedIndex(int index) {
		int i = -1;
		FOREACH(JMenuItem, ab, this) {
			++i;
			ab.setSelected(i == index);
		}
	}
}

class SimpleCPURunner implements CPURunner, Runnable {
	private volatile int threadStatus = 0;
	private Thread cpurunthread;
	// 0 means suspended
	// 1 means suspend->running requested
	// 2 means running
	// 3 means running->suspended requested
	synchronized public void suspend() {
		while (threadStatus != 0) {
			threadStatus = 3;
			while (threadStatus == 3) { YIELD; };
		}
	}

	synchronized public void resume() {
		if (!CPU.canRun()) return;
		if (threadStatus != 2) {
			threadStatus = 1;
			while (threadStatus == 1) { YIELD; };
		}
	}

	public boolean isRunning() {
		return (threadStatus != 0);
	}

	SimpleCPURunner() {
		cpurunthread = new Thread(this);
		cpurunthread.start();
		while (!cpurunthread.isAlive()) { YIELD; }; // wait for thread to actually start
	}

	public void run() {
		while (true) {
			// suspended
			while (threadStatus == 0) { YIELD; };
			// suspend -> running
			if (threadStatus == 1) threadStatus = 2;
			// running
			while ((threadStatus == 2) && (CPU.nextinstruction()!=0)) {};

			if (threadStatus == 2) { // CPU returned exception
				threadStatus = 3;
				JOptionPane.showMessageDialog(null,
				                              "Encountered an invalid instruction, perhaps ROM is broken?",
				                              "Invalid Instruction",
				                              JOptionPane.INFORMATION_MESSAGE);
			}
			// running -> suspended
			if (threadStatus == 3) threadStatus = 0;
			// suspended
		}
	}
}

public final class swinggui extends JApplet implements ActionListener, ItemListener, KeyListener, ComponentListener, WindowListener {
		private static DrawingArea grfx;
		protected VideoController VC;
		protected CPU cpu;
		protected AudioDriver audioDriver;
		private int fps;
		private boolean isApplet;
		private int selectedState = 0;
		private int[] keyMap = new int[16+nrOfShortCuts]; // first 8: player 1, next 8: player 2, etc, last N-4*8 = shortcuts
		VECTOR(String) osdLines = new VECTOR(String)();
		VECTOR(String) rcFiles = new VECTOR(String)();
		int osdTime = 0;
		static public String curcartname;
		static public String biosfilename;
		static public DataOutputStream speedRunPlayWithOutputVideoStream;
		//menuitem <-- here for my KDev autocomplete
		JMenuItem menuitemExit;
		MenuItemArrayGroup scaleRadioGroup;
		MenuItemArrayGroup interpolationRadioGroup;
		JCheckBoxMenuItem keepAspectRatio;
		JCheckBoxMenuItem enableFullScreen;
		JMenuItem menuitemOpenROM;
		JMenuItem menuitemSaveState;
		JMenuItem menuitemLoadState;
		JMenuItem menuitemIncFrameSkip;
		JMenuItem menuitemDecFrameSkip;
		JCheckBoxMenuItem menuitemEnableSound;
		MenuItemArrayGroup savestateRadioGroup;
		JMenuItem[] menuItems; //Savestates?
		JMenuItem menuitemSeparator;
		JMenuItem menuitemPause;
		JMenuItem menuitemReset;
		JMenu menuColorScheme;
		JCheckBoxMenuItem[] menuitemColorSchemes;

		JMenu menuSoundChannels;
		MenuItemArray soundChannelGroup;
		JMenu menuOther;
		JMenuItem menuitemCheats;
		JCheckBoxMenuItem menuitemEnableCheats;
		JCheckBoxMenuItem menuitemUseBIOS;
		JMenuItem menuitemSetBIOS;
		JMenu menuEmuSpeed;
		JMenuItem menuitemEmuSpeedPlus;
		JMenuItem menuitemEmuSpeedMinus;
		JMenuItem menuitemEmuSpeedMul;
		JMenuItem menuitemEmuSpeedDiv;
		JMenuItem menuitemEmuSpeedNormal;
#ifdef SCALEBUILDER
		JMenuItem menuitemScaleBuilder;
#endif
		JMenu menuLink;
		JMenuItem menuitemLinkServe;
		JMenuItem menuitemLinkClient;
		JMenuItem menuitemLinkSever;
		JMenuItem menuitemConfigKeys;
		JCheckBoxMenuItem	menuitemToggleRemoteKeys;
		JCheckBoxMenuItem menuitemSpeedRunRecord; //Resets CPU and enables Recording
		JCheckBoxMenuItem menuitemSpeedRunPlay;   //Resets CPU and enables Playback
		JCheckBoxMenuItem menuitemSpeedRunPlayWithOutput; //Play to file/pipe for encoding
		JMenuItem menuitemShowAdvancedAudioPropertiesDialog;

		static CheatCodeEditor cheatcodes;
		static AdvancedAudioPropertiesDialog advancedAudioPropertiesDialog;
		CPURunner cpuRunner;

		protected ColorSelector cs;

		public void updateCartName(String fname) {
			int slashPos = fname.lastIndexOf(File.separator);
			int dotPos = fname.lastIndexOf(".");
			if (dotPos == -1) dotPos = fname.length();
			curcartname = fname.substring(slashPos+1, dotPos);
// 			PRINTLN("cartname = " + curcartname);

			rcFiles.remove(fname);
			rcFiles.add(0, fname);
			saveRCFiles();
		}

		public class DrawingArea extends JPanel implements IVideoListener {
			private static final long serialVersionUID = 1L; // prevent warning

			public int interpolation;
			VideoController VC;
			public DrawingArea(VideoController vc) {
				super();
				VC=vc;
			}
			Color ColorTextShadow = new Color(128,128,128);
			Color ColorTextLight  = new Color(255,255,255);
			int DrawingAreaFontSize = 10;
			Font DrawingAreaFont = new Font("SansSerif", Font.BOLD, DrawingAreaFontSize);

			public void updateVideoImage(Image img) {
				updateUI();
				if( speedRunPlayWithOutputVideoStream != null) {
					BufferedImage bimg = (BufferedImage)img;
					int[] data = (int[])bimg.getRaster().getDataElements(0,0,bimg.getWidth(),bimg.getHeight(),null);
					//PRINTF("Width = %d, Height= %d, Length = %d\n",bimg.getWidth(),bimg.getHeight(),data.length);
					for(int i=0; i<data.length; ++i) {
						int j = data[i];
						int ar = (j>>16)&0xff;
						int ag = (j>> 8)&0xff;
						int ab = (j>> 0)&0xff;
						try {
							speedRunPlayWithOutputVideoStream.writeByte(ar);
							speedRunPlayWithOutputVideoStream.writeByte(ag);
							speedRunPlayWithOutputVideoStream.writeByte(ab);
						}
						catch (IOException ee) {
							speedRunPlayWithOutputVideoStream = null;
							JOptionPane.showMessageDialog(frame,
							                              "Error while writing to file, aborting recording:\n"+ee.getMessage(),
							                              "Error!",
							                               JOptionPane.ERROR_MESSAGE);
						}
					}
				}
			}

			public void paintComponent(Graphics g) {
				super.paintComponent(g);
				if (interpolation == 0) {
					g.drawImage(cpu.VC.getImage(),0,0, this);
				} else {
					((Graphics2D)g).setRenderingHint(RenderingHints.KEY_INTERPOLATION,
						(interpolation == 1) ? RenderingHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR  :
						(interpolation == 2) ? RenderingHints.VALUE_INTERPOLATION_BILINEAR  :
						(interpolation == 3) ? RenderingHints.VALUE_INTERPOLATION_BICUBIC  :
						null
					);

					g.drawImage(cpu.VC.getImage(),0,0, getWidth(),getHeight(), this);
				}
				if (osdTime > 0) {
					while (osdLines.size() > 3*VC.nscale) //Made this 3 by user request
						osdLines.remove(0);
					g.setColor(new Color(255,255,255));
					--osdTime;
					if ((osdTime == 0) && (osdLines.size()>0)) {
						osdLines.remove(0);
						osdTime = 15;
					}
					for (int i = 0; i < osdLines.size(); ++i) {
						//FIXME: Make proper Font Outlines (Difficulty: Very Hard)
						String s=(String)osdLines.get(i);
// 						g.drawString(s, 9,  10+10*i);
// 						g.drawString(s, 10,  9+10*i);
// 						g.setFont(DrawingAreaFont);
						g.setColor(ColorTextShadow);
						g.drawString(s, 11, (DrawingAreaFontSize+1)+DrawingAreaFontSize*i);
						g.drawString(s, 11, (DrawingAreaFontSize+1)+DrawingAreaFontSize*i);
						g.setColor(ColorTextLight);
						g.drawString(s, 10, DrawingAreaFontSize+DrawingAreaFontSize*i);
					}
				}
				++fps;
			}
		}

		public void addOSDLine(String line) {
			osdLines.add(line);
			osdTime = 200;
		}

		public swinggui() {
			isApplet = false;
		}

		private JMenu menuFile;

		private JMenuBar mainMenuBar;

		private JMenuBar createJMenuBar() {
			JMenuBar mainMenuBar;
			JMenu menuVideo;
			JMenu menuScaling;
			JMenu menuFrameSkip;
			JMenu menuState;
			JMenu menuSound;
			JMenu menuColor;
			mainMenuBar = new JMenuBar();

			menuFile = new JMenu( "File" );
			menuFile.setMnemonic( KeyEvent.VK_F );
			mainMenuBar.add( menuFile );
			menuVideo = new JMenu( "Video" );
			menuVideo.setMnemonic( KeyEvent.VK_V );
			mainMenuBar.add( menuVideo );

			menuitemOpenROM = new JMenuItem("Open ROM", KeyEvent.VK_O);
			menuitemOpenROM.addActionListener( this );
			menuFile.add(menuitemOpenROM);
			menuitemPause=new JMenuItem("Pause", KeyEvent.VK_P);
			menuitemPause.addActionListener(this);
			menuFile.add(menuitemPause);
			menuitemReset=new JMenuItem("Reset", KeyEvent.VK_R);
			menuitemReset.addActionListener(this);
			menuFile.add(menuitemReset);

			menuitemExit = new JMenuItem( "Exit", KeyEvent.VK_X );
			menuitemExit.addActionListener( this );
			menuFile.add( menuitemExit );

			enableFullScreen = new JCheckBoxMenuItem("Full Screen");
			enableFullScreen.addActionListener(this);
			menuVideo.add(enableFullScreen);

			menuVideo.addSeparator();

			menuScaling = new JMenu( "Scaling");
			scaleRadioGroup = new MenuItemArrayGroup();
			scaleRadioGroup.add(new JRadioButtonMenuItem( "Scale 1x" ), KeyEvent.VK_1);
			scaleRadioGroup.add(new JRadioButtonMenuItem( "Scale 2x" ), KeyEvent.VK_2);
			scaleRadioGroup.add(new JRadioButtonMenuItem( "Scale 3x" ), KeyEvent.VK_3);
			scaleRadioGroup.add(new JRadioButtonMenuItem( "Scale 4x" ), KeyEvent.VK_4);
			scaleRadioGroup.addActionListener( this );
			scaleRadioGroup.addToMenu(menuScaling);
			menuScaling.addSeparator();

			interpolationRadioGroup = new MenuItemArrayGroup();
			interpolationRadioGroup.add(new JRadioButtonMenuItem("No Interpolation (fixed window size)"));
			interpolationRadioGroup.add(new JRadioButtonMenuItem("Nearest Neighbour Interpolation"));
			interpolationRadioGroup.add(new JRadioButtonMenuItem("BiLinear Interpolation"));
			interpolationRadioGroup.add(new JRadioButtonMenuItem("BiCubic Interpolation"));

			interpolationRadioGroup.addActionListener(this);
			interpolationRadioGroup.addToMenu(menuScaling);

			menuScaling.addSeparator();
			keepAspectRatio = new JCheckBoxMenuItem("Keep ascpect ratio");
			keepAspectRatio.addActionListener(this);
			menuScaling.add(keepAspectRatio);

			menuVideo.add( menuScaling) ;

			menuFrameSkip = new JMenu( "Frame Skipping");
			menuitemIncFrameSkip = new JMenuItem( "Increase Frame Skip", KeyEvent.VK_I );
			menuitemDecFrameSkip = new JMenuItem( "Decrease Frame Skip", KeyEvent.VK_D );
			menuitemIncFrameSkip.addActionListener( this );
			menuitemDecFrameSkip.addActionListener( this );
			menuFrameSkip.add( menuitemIncFrameSkip );
			menuFrameSkip.add( menuitemDecFrameSkip );
			menuVideo.add( menuFrameSkip) ;

			menuColorScheme = new JMenu("Color scheme");
			menuitemColorSchemes = new JCheckBoxMenuItem[4];
			menuitemColorSchemes[0] = new JCheckBoxMenuItem("GameBoy LCD", false);
			menuitemColorSchemes[0].setMnemonic(KeyEvent.VK_L);
			menuitemColorSchemes[1] = new JCheckBoxMenuItem("Black and White", false);
			menuitemColorSchemes[1].setMnemonic(KeyEvent.VK_B);
			menuitemColorSchemes[2] = new JCheckBoxMenuItem("Graytones", false);
			menuitemColorSchemes[2].setMnemonic(KeyEvent.VK_G);
			menuitemColorSchemes[3] = new JCheckBoxMenuItem("Custom", false);
			menuitemColorSchemes[3].setMnemonic(KeyEvent.VK_C);
			for (int i = 0; i < menuitemColorSchemes.length; ++i) {
				menuColorScheme.add(menuitemColorSchemes[i]);
				menuitemColorSchemes[i].addActionListener(this);
			}
			menuVideo.add(menuColorScheme);

			menuState = new JMenu("State");
			menuState.setMnemonic(KeyEvent.VK_S);
			menuitemSaveState = new JMenuItem( "Save State", KeyEvent.VK_S );
			menuitemLoadState = new JMenuItem( "Load State", KeyEvent.VK_L );

			menuitemSaveState.addActionListener( this );
			menuitemLoadState.addActionListener( this );
			menuState.add( menuitemSaveState );
			menuState.add( menuitemLoadState );
			menuState.addSeparator();
			savestateRadioGroup = new MenuItemArrayGroup();
			for (int i = 0; i < 10; ++i) {
				savestateRadioGroup.add(new JRadioButtonMenuItem("Select State " + i), KeyEvent.VK_0 + i);
				savestateRadioGroup.get(i).setAccelerator( KeyStroke.getKeyStroke( KeyEvent.VK_0 + i, 0));
			}
			savestateRadioGroup.addActionListener(this);
			savestateRadioGroup.addToMenu(menuState);
			savestateRadioGroup.setSelectedIndex(0);

			mainMenuBar.add( menuState) ;

			menuSound = new JMenu( "Sound");
			menuSound.setMnemonic( KeyEvent.VK_U );
			menuitemEnableSound = new JCheckBoxMenuItem( "Enable sound", true );
			menuitemEnableSound.setMnemonic( KeyEvent.VK_T );
			menuitemEnableSound.addActionListener( this );
			menuSound.add( menuitemEnableSound );

			menuSoundChannels = new JMenu("Channels");
			soundChannelGroup = new MenuItemArray();
			soundChannelGroup.add(new JCheckBoxMenuItem("Enable channel 1"), KeyEvent.VK_1);
			soundChannelGroup.add(new JCheckBoxMenuItem("Enable channel 2"), KeyEvent.VK_2);
			soundChannelGroup.add(new JCheckBoxMenuItem("Enable channel 3"), KeyEvent.VK_3);
			soundChannelGroup.add(new JCheckBoxMenuItem("Enable channel 4"), KeyEvent.VK_4);
			soundChannelGroup.addActionListener(this);
			soundChannelGroup.addToMenu(menuSoundChannels);

			menuSound.add(menuSoundChannels);
			menuitemShowAdvancedAudioPropertiesDialog = new JMenuItem("Advanced...", KeyEvent.VK_A);
			menuitemShowAdvancedAudioPropertiesDialog.addActionListener(this);
			menuSound.add(menuitemShowAdvancedAudioPropertiesDialog);
			mainMenuBar.add( menuSound) ;
			menuOther=new JMenu("Other");
			menuOther.setMnemonic( KeyEvent.VK_O );
			menuitemCheats = new JMenuItem("Edit cheats", KeyEvent.VK_C);
			menuitemCheats.addActionListener(this);
			menuitemEnableCheats=new JCheckBoxMenuItem("Enable cheat codes", false);
			menuitemEnableCheats.setMnemonic(KeyEvent.VK_T);
			menuitemEnableCheats.addActionListener(this);
			menuitemUseBIOS=new JCheckBoxMenuItem("Run BIOS on reset", false);
			menuitemUseBIOS.setMnemonic(KeyEvent.VK_B);
			menuitemUseBIOS.addActionListener(this);
			menuitemSetBIOS=new JMenuItem("Select BIOS ROM", KeyEvent.VK_B);
			menuitemSetBIOS.addActionListener(this);

#ifdef SCALEBUILDER
			menuitemScaleBuilder=new JMenuItem("Built Scale", KeyEvent.VK_S);
			menuitemScaleBuilder.addActionListener(this);
			menuOther.add(menuitemScaleBuilder);
#endif
			menuitemToggleRemoteKeys = new JCheckBoxMenuItem("Use Remote Keys", false);
			menuitemToggleRemoteKeys.setMnemonic(KeyEvent.VK_R);
			menuitemToggleRemoteKeys.addActionListener(this);

			menuLink=new JMenu("Link");
			menuLink.setMnemonic( KeyEvent.VK_L );
			menuitemLinkServe = new JMenuItem("Start Link Server", KeyEvent.VK_S);
			menuitemLinkClient = new JMenuItem("Start Link Client", KeyEvent.VK_C);
			menuitemLinkSever = new JMenuItem("Stop Link", KeyEvent.VK_L);
			menuitemLinkServe.addActionListener(this);
			menuitemLinkClient.addActionListener(this);
			menuitemLinkSever.addActionListener(this);
			menuLink.add(menuitemLinkServe);
			menuLink.add(menuitemLinkClient);
			menuLink.add(menuitemLinkSever);
			mainMenuBar.add( menuLink ) ;

			menuitemConfigKeys = new JMenuItem("Config keys",KeyEvent.VK_1);
			menuitemConfigKeys.addActionListener(this);

			menuitemSpeedRunRecord = new JCheckBoxMenuItem("Record speedrun", false);
			menuitemSpeedRunPlay = new JCheckBoxMenuItem("Play speedrun", false);
			menuitemSpeedRunPlayWithOutput = new JCheckBoxMenuItem("Record speedrun to file", false);
			menuitemSpeedRunRecord.setMnemonic(KeyEvent.VK_E);
			menuitemSpeedRunPlay.setMnemonic(KeyEvent.VK_P);
			menuitemSpeedRunPlayWithOutput.setMnemonic(KeyEvent.VK_F);
			menuitemSpeedRunRecord.addActionListener(this);
			menuitemSpeedRunPlay.addActionListener(this);
			menuitemSpeedRunPlayWithOutput.addActionListener(this);

			menuOther.add(menuitemEnableCheats);
			menuOther.add(menuitemUseBIOS);
			menuOther.add(menuitemToggleRemoteKeys);
			menuOther.add(menuitemCheats);
			menuOther.add(menuitemSetBIOS);
			menuOther.add(menuitemConfigKeys);

			menuEmuSpeed = new JMenu("Emulation Speed");
			menuitemEmuSpeedPlus  = new JMenuItem("+25%", KeyEvent.VK_PLUS);
			menuitemEmuSpeedMinus = new JMenuItem("-25%", KeyEvent.VK_MINUS);
			menuitemEmuSpeedMul  = new JMenuItem("*125%", KeyEvent.VK_OPEN_BRACKET);
 			menuitemEmuSpeedDiv = new JMenuItem("*75%", KeyEvent.VK_CLOSE_BRACKET);
			menuitemEmuSpeedNormal= new JMenuItem("100%", KeyEvent.VK_EQUALS);
			menuitemEmuSpeedPlus.addActionListener(this);
			menuitemEmuSpeedMinus.addActionListener(this);
			menuitemEmuSpeedMul.addActionListener(this);
			menuitemEmuSpeedDiv.addActionListener(this);
			menuitemEmuSpeedNormal.addActionListener(this);

			menuEmuSpeed.add(menuitemEmuSpeedPlus);
			menuEmuSpeed.add(menuitemEmuSpeedMinus);
			menuEmuSpeed.add(menuitemEmuSpeedMul);
			menuEmuSpeed.add(menuitemEmuSpeedDiv);
			menuEmuSpeed.add(menuitemEmuSpeedNormal);
			menuOther.add(menuEmuSpeed ) ;
			menuOther.addSeparator();
			menuOther.add(menuitemSpeedRunRecord);
			menuOther.add(menuitemSpeedRunPlay);
			menuOther.add(menuitemSpeedRunPlayWithOutput);

			mainMenuBar.add( menuOther) ;

			return mainMenuBar;
		}

		private void applyAccelerators() {
			int keyMapIndex=16; // Accelerators start at 16
			#define NEXT_KEYSTROKE_FROM_KEYMAP KeyStroke.getKeyStroke( keyMap[keyMapIndex]&0xff, keyMap[keyMapIndex++]>>8 )
			menuitemConfigKeys.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemOpenROM.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemPause.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemReset.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemExit.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			for (int i = 0; i < 4; ++i)
				scaleRadioGroup.get(i).setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemIncFrameSkip.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemDecFrameSkip.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemColorSchemes[0].setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemColorSchemes[1].setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemColorSchemes[2].setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemColorSchemes[3].setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemSaveState.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemLoadState.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemEnableSound.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			for (int i = 0; i < 4; ++i)
				soundChannelGroup.get(i).setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemCheats.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemEnableCheats.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemEmuSpeedPlus.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemEmuSpeedMinus.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemEmuSpeedMul.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemEmuSpeedDiv.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemEmuSpeedNormal.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
		}
		public void addComponentsToPane( Container contentPane ) {
			grfx=new DrawingArea( cpu.VC ); //doublebuffering
			grfx.setFocusable(true);

			// Fix(/workaround) broken X11 key repeat stupidity
			if (System.getProperty("os.name").equals("Linux"))
				grfx.addKeyListener(new TimedKeyListener(this));
			else
				grfx.addKeyListener(this);

			grfx.setDoubleBuffered(false);
			contentPane.add( grfx );
		}

		static JFrame frame;
		static JFrame fsframe;

		private void createAndShowGUI() {
			try {
				UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
			}
			catch (Exception ex) {
				System.out.println(ex);
			}

			frame = new JFrame( "JGameBoy Emulator V"+Version.str);
			fsframe = new JFrame( "JGameBoy Emulator V"+Version.str);

			frame.setDefaultCloseOperation( JFrame.DO_NOTHING_ON_CLOSE );
			fsframe.setDefaultCloseOperation( JFrame.DO_NOTHING_ON_CLOSE );

			frame.getContentPane().setLayout(null);
			fsframe.getContentPane().setLayout(null);

			fsframe.setUndecorated(true);

			//Set up the content pane and add swing components to it
			mainMenuBar = createJMenuBar();
			frame.setJMenuBar( mainMenuBar );
			addComponentsToPane( frame.getContentPane() );
			Toolkit toolkit = Toolkit.getDefaultToolkit();
			URL imgurl = getClass().getResource("icon.gif");
			if(imgurl!=null) {
				Image image = toolkit.getImage(imgurl);
				frame.setIconImage(image);
			}
			else {
				PRINTLN("Can't load JGBE icon!");
			}
			frame.addComponentListener(this);
			frame.addWindowListener(this);
			fsframe.addWindowListener(this);

			frame.setResizable(false);

			Dimension d = Toolkit.getDefaultToolkit().getScreenSize();
			Point     p = new Point();
			p.setLocation((d.getWidth()/2) - (frame.getWidth()/2), (d.getHeight()/2)-(frame.getHeight()/2));
			frame.setLocation(p);

			/* DND */
			JavaCrossplatformnessIsAMyth transferhandler = new JavaCrossplatformnessIsAMyth();
			grfx.setTransferHandler(transferhandler);

			frame.setVisible( true );
		}

		public class JavaCrossplatformnessIsAMyth extends TransferHandler {
			private static final String URI_LIST = "uri-list";
			public boolean canImport(JComponent comp, DataFlavor[] transferFlavors) {
				for(int i=0; i< transferFlavors.length; ++i) {
					DataFlavor flavor = transferFlavors[i];
					// windows
					if (flavor.equals(DataFlavor.javaFileListFlavor)) {
						return true;
					// kde
					} else if (URI_LIST.equals( flavor.getSubType() )) {
						return true;
					}
				}
				return false;
			}

			public boolean importData(JComponent comp, Transferable t) {
				VECTOR(File) files = null;
				try {
					for(int i=0; i < t.getTransferDataFlavors().length; ++i) {
						DataFlavor flavor = t.getTransferDataFlavors()[i];
						Object obj = t.getTransferData(flavor);
						// windows
						if (DataFlavor.javaFileListFlavor.equals(flavor)) {
							files = new VECTOR(File)();
							files.addAll( (java.util.Collection)t.getTransferData(flavor) );
						// kde
						} else if (URI_LIST.equals(flavor.getSubType()) && obj instanceof String ) {
							String urilist = (String)obj;
							Scanner scanner = new Scanner(urilist.trim());
							files = new VECTOR(File)();
							while (scanner.hasNextLine()) {
								files.add(new File(new URI(scanner.nextLine()) ) );
							}
						}
					}
				} catch (Exception e) {
					e.printStackTrace();
					return false;
				}

				if(files != null) if(files.size() == 1) tryToLoadROM(files.get(0).toString());// PRINTLN(files.get(0));

				return true;
			}
		}


		boolean fulls = false;

		public void componentHidden(ComponentEvent e) {}
		public void componentMoved(ComponentEvent e) {}
		public void componentShown(ComponentEvent e) {}
		public void componentResized(ComponentEvent e) {
			if (fulls != enableFullScreen.getState()) {
				if (enableFullScreen.getState()) {
					frame.setVisible(false);

					fsframe.getContentPane().add(grfx);
					fsframe.setJMenuBar(mainMenuBar);

					GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();
					GraphicsDevice gd = ge.getDefaultScreenDevice();
					gd.setFullScreenWindow(fsframe);
				} else {
					GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();
					GraphicsDevice gd = ge.getDefaultScreenDevice();
					gd.setFullScreenWindow(null);
					fsframe.setVisible(false);

					frame.setResizable(grfx.interpolation != 0);
					frame.getContentPane().add(grfx);
					frame.setJMenuBar(mainMenuBar);
					frame.setVisible(true);
				}
				fulls = enableFullScreen.getState();
			}

			Dimension psize,csize;
			csize = (fulls ? fsframe: frame.getContentPane()).getSize();
			if (grfx.interpolation == 0) {
				psize = new Dimension(VC.nscale*160, VC.nscale*144);
				grfx.setSize(psize);
				grfx.setPreferredSize(psize);
				if (!fulls) {
					Dimension fsize = frame.getSize();
					Dimension bsize = new Dimension();
					bsize.width = MAX(psize.width + (fsize.width - csize.width), frame.getPreferredSize().width);
					bsize.height = MAX(psize.height + (fsize.height - csize.height), frame.getPreferredSize().height);
					frame.getContentPane().setSize(psize);
					frame.setSize(bsize);
				}
			} else {
				psize = new Dimension(csize);
				if (keepAspectRatio.getState()) {
					double ratio = psize.getWidth()/psize.getHeight();
					double target = 160.0/144.0;
					if (ratio < target)
						psize.height = (int)Math.round(psize.getWidth() / target);
					else
						psize.width = (int)Math.round(psize.getHeight() * target);
				}
			}
			Rectangle trect = new Rectangle(psize);
			if (psize.width < csize.width) trect.translate((csize.width - psize.width)/2,0);
			if (psize.height < csize.height) trect.translate(0,(csize.height - psize.height)/2);
			grfx.setBounds(trect);
		}

		public void pauseEmulation(boolean verbose) {
			if(cpuRunner!=null) {
				cpuRunner.suspend();
				if(verbose) addOSDLine("Paused gameboy");
			}
		}

		public void resumeEmulation(boolean verbose) {
			if((cpuRunner!=null)&&(cart!=null)) {
				cpuRunner.resume();
				if(verbose) addOSDLine("Unpaused gameboy");
			}
		}

		public void actionPerformed( ActionEvent e ) {
/*				JMenuItem source = ( JMenuItem )( e.getSource() );
				String s = "Menu Item source: " + source.getText()
			           + " (an instance of " + getClassName( source ) + ")";
				PRINTLN(s);*/
			boolean configStateChanged = false;
			if (e.getSource().equals( menuitemExit)) {
				windowClosed(null);
			}
			else if (scaleRadioGroup.contains(e.getSource())) {
				int idx = scaleRadioGroup.getSelectedIndex();
				VC.nscale = idx+1;
				addOSDLine("Set scaling: Scale"+VC.nscale+"x");
				componentResized(null);
				configStateChanged = true;
			}
			else if (interpolationRadioGroup.contains(e.getSource())) {
				int idx = interpolationRadioGroup.getSelectedIndex();
				frame.setResizable(idx != 0);
				keepAspectRatio.setEnabled(idx != 0);
				grfx.interpolation = idx;
				componentResized(null);
			}
			else if (e.getSource().equals(keepAspectRatio)) {
				componentResized(null);
			}
			else if (e.getSource().equals(enableFullScreen)) {
				componentResized(null);
			}
			else if (e.getSource().equals( menuitemIncFrameSkip )) {
				++VC.fskip;
				addOSDLine("Increased frameskip: "+VC.fskip);
				configStateChanged = true;
			}
			else if (e.getSource().equals( menuitemDecFrameSkip )) {
				if (VC.fskip>1) --VC.fskip;
				addOSDLine("Decreased frameskip: "+VC.fskip);
				configStateChanged = true;
			}
			else if (e.getSource().equals( menuitemEnableSound )) {
				cpu.AC.isMuted = !menuitemEnableSound.getState();
				addOSDLine( cpu.AC.isMuted?"Disabled sound":"Enabled sound");
				configStateChanged = true;
			}
			else if (soundChannelGroup.contains(e.getSource())) {
				int channel = soundChannelGroup.indexOf(e.getSource())+1;
				boolean enabled = cpu.AC.toggleChannelOnOff(channel);
				addOSDLine((enabled ? "Enabled" : "Disabled") + " soundchannel " + channel);
				configStateChanged = true;
			}
			else if (e.getSource().equals( menuitemEnableCheats)) {
				cheatcodes.ToggleCheats(cart);
				addOSDLine("Cheats codes are now " + (cheatcodes.UseCheats?"enabled":"disabled") );
			}
			else if (e.getSource().equals( menuitemConfigKeys )) {
				keyConfigDialog k=new keyConfigDialog(frame, keyMap);
				pauseEmulation(false);
				k.getKeyCodes();
				saveKeyBinds();
				applyAccelerators();
				resumeEmulation(false);
			}
#ifdef SCALEBUILDER
			else if (e.getSource().equals( menuitemScaleBuilder)) {
				ScaleBuilder sb = new ScaleBuilder(frame);
				//sb.showOpenDialog();
			}
#endif
			else if (e.getSource().equals( menuitemCheats)) {
				pauseEmulation(false);
				cheatcodes.editCodes();
				cheatcodes.applyCheatCodes(cart);
				resumeEmulation(false);
				addOSDLine("ZOMG CHEATER!!!!");
			}
			else if(e.getSource().equals( menuitemUseBIOS )) {
				if (menuitemUseBIOS.getState()) cart.loadBios(biosfilename);
				else cart.loadBios("");
				configStateChanged = true;
			}
			else if(e.getSource().equals( menuitemSetBIOS )) {
				JFileChooser fc = new JFileChooser(".");
				fc.showOpenDialog(frame);
				File selFile = fc.getSelectedFile();
				if(selFile != null) {
					if(selFile.length() != 256) JOptionPane.showMessageDialog(null,
					                            "This file's size is not equal to 256 bytes!",
					                            "Invalid BIOS Rom",
					                            JOptionPane.INFORMATION_MESSAGE);
					else {
						biosfilename = selFile.getAbsolutePath();
						if (menuitemUseBIOS.getState()) cart.loadBios(biosfilename);
						else cart.loadBios("");
						configStateChanged = true;
					}
				}
			}
			else if(e.getSource().equals( menuitemOpenROM )) {
				JFileChooser fc;
				if (rcFiles.size() > 0) {
					String lastpath = (String)rcFiles.get(0);
					int slashPos = lastpath.lastIndexOf(File.separator);
					lastpath = lastpath.substring(0, slashPos+1);
					fc = new JFileChooser(lastpath);
				}
				else
					fc = new JFileChooser(".");

				// Show open dialog; this method does not return until the dialog is closed
				fc.showOpenDialog(frame);
				File selFile = fc.getSelectedFile();
				if(selFile != null) {
					tryToLoadROM(selFile.getAbsolutePath());
				}
			}
			else if(e.getSource().equals( menuitemLinkServe )) {
				try {
					CPU.serveLink();
				}
				catch (IOException ioe) {
					JOptionPane.showMessageDialog(frame, "Failed: " + ioe.getMessage(), "Error!", JOptionPane.ERROR_MESSAGE);
				}
			}
			else if(e.getSource().equals( menuitemLinkSever )) {
				CPU.severLink();
			}
			else if(e.getSource().equals( menuitemLinkClient )) {
				try {
					CPU.clientLink((String)JOptionPane.showInputDialog(frame, (Object)"Enter host address", "Link setup", JOptionPane.QUESTION_MESSAGE, null, null, "localhost"));
				}
				catch (IOException ioe) {
					JOptionPane.showMessageDialog(frame, "Failed: " + ioe.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
				}
			}
			else if(e.getSource().equals( menuitemSaveState )) {
				if (!CPU.canRun()) return;
				pauseEmulation(false);
				addOSDLine("Saving State "+selectedState);
				try {
					String stname = FHandler.JGBEDir("savestates");
					stname += curcartname + ".st" + selectedState;
					DataOutputStream dostream = FHandler.getDataOutputStream(stname);
					CPU.saveState(dostream);
					dostream.close();
				}
				catch (java.io.IOException ioe) {
					PRINTLN("Error saving state! ");
					PRINTLN(ioe.getMessage());
				};
				menuitemSpeedRunRecord.setState(cpu.keyHistoryEnabled);
				menuitemSpeedRunPlay.setState(cpu.playbackHistoryIndex != -1);
				resumeEmulation(false);
			}
			else if(e.getSource().equals( menuitemLoadState )) {
				if (!CPU.canRun()) return;
				pauseEmulation(false);
				addOSDLine("Loading State "+selectedState);
				try {
					String stname = FHandler.JGBEDir("savestates") + curcartname + ".st" + selectedState;
					DataInputStream distream = FHandler.getDataInputStream(stname);
					CPU.loadState(distream);
					distream.close();
				}
				catch (java.io.IOException ioe) {
					PRINTLN("Error loading state! " + ioe.getMessage());
					PRINTLN(ioe.getMessage());
				};
				resumeEmulation(false);
				if(cpu.keyHistoryEnabled) addOSDLine("Note: Speedrun in progress");
				menuitemSpeedRunRecord.setState(cpu.keyHistoryEnabled);
				menuitemSpeedRunPlay.setState(cpu.playbackHistoryIndex != -1);
			}
			else if(e.getSource().equals( menuitemPause )) {
				if(cpuRunner.isRunning())
					pauseEmulation(true);
				else
					resumeEmulation(true);
			}
			else if(e.getSource().equals( menuitemReset )) {
				pauseEmulation(false);
				cpu.reset();
				resumeEmulation(false);
				addOSDLine("Reset gameboy");
			}
			else if(e.getSource().equals( menuitemSpeedRunRecord )) {
				if(cpu.keyHistoryEnabled) {
					addOSDLine("Stopped recording of your speedrun");
					pauseEmulation(false);
					cpu.keyHistoryEnabled = false;
					resumeEmulation(false);
				}
				else {
					menuitemSpeedRunPlay.setState(false);
					addOSDLine("Now recording speedrun");
					pauseEmulation(false);
					cpu.reset();
					cpu.keyHistoryEnabled = true;
					resumeEmulation(false);
				}
				menuitemSpeedRunRecord.setState(cpu.keyHistoryEnabled);
				menuitemSpeedRunPlay.setState(cpu.playbackHistoryIndex != -1);
			}
			else if(e.getSource().equals( menuitemSpeedRunPlay ) || e.getSource().equals( menuitemSpeedRunPlayWithOutput )) {
				menuitemSpeedRunRecord.setState(false);
				pauseEmulation(false);
				IntVector hist = cpu.keyHistory;
				cpu.keyHistory = new IntVector();
				cpu.reset();
				cpu.keyHistory = hist;
				cpu.playbackHistoryIndex = 0;
				cpu.keyHistoryEnabled = false;
				if(e.getSource().equals( menuitemSpeedRunPlayWithOutput )) {
					if(menuitemSpeedRunPlayWithOutput.getState()) {
						JFileChooser fc = new JFileChooser(".");
						File selFile;
						fc.showOpenDialog(frame);
						selFile = fc.getSelectedFile();
						if(selFile != null) {
							try {
								speedRunPlayWithOutputVideoStream = FHandler.getDataOutputStream(selFile.getAbsolutePath());
							}
							catch (IOException ee) {
								speedRunPlayWithOutputVideoStream = null;
								JOptionPane.showMessageDialog(frame,
								                              "Error while opening file, recording will fail:\n"+ee.getMessage(),
								                              "Error!",
								                              JOptionPane.ERROR_MESSAGE);
							}
						}
						// TODO: audio stream/file
						/*fc.showOpenDialog(frame);*/selFile = null;
						selFile = fc.getSelectedFile();
						if(selFile != null) {
						}
					}
					else {
						speedRunPlayWithOutputVideoStream = null;
					}
				}
				resumeEmulation(false);
				menuitemSpeedRunPlay.setState(cpu.playbackHistoryIndex != -1);
			}
			else if(e.getSource().equals( menuitemEmuSpeedPlus )) {
				double cs = CPU.AC.currentEmulationSpeed;
				double ns = 0.25 + cs;
				CPU.AC.setSpeed(ns);
				addOSDLine("EmuSpeed: "+(int)(ns*100.0)+"."+(int)( (ns*100.0-(int)(ns*100.0)) )+"%");
			}
			else if(e.getSource().equals( menuitemEmuSpeedMinus )) {
				double cs = CPU.AC.currentEmulationSpeed;
				double ns = Math.max(cs-0.25,0);
				CPU.AC.setSpeed(ns);
				addOSDLine("EmuSpeed: "+(int)(ns*100.0)+"."+(int)( (ns*100.0-(int)(ns*100.0)) )+"%");
			}
			else if(e.getSource().equals( menuitemEmuSpeedMul )) {
				double cs = CPU.AC.currentEmulationSpeed;
				double ns = 1.25 * cs;
				CPU.AC.setSpeed(ns);
				addOSDLine("EmuSpeed: "+(int)(ns*100.0)+"."+(int)( (ns*100.0-(int)(ns*100.0)) )+"%");
			}
			else if(e.getSource().equals( menuitemEmuSpeedDiv )) {
				double cs = CPU.AC.currentEmulationSpeed;
				double ns = 0.75 * cs;
				CPU.AC.setSpeed(ns);
				addOSDLine("EmuSpeed: "+(int)(ns*100.0)+"."+(int)( (ns*100.0-(int)(ns*100.0)) )+"%");
			}
			else if(e.getSource().equals( menuitemEmuSpeedNormal )) {
				CPU.AC.setSpeed(1.0);
				addOSDLine("EmuSpeed: 100%");
			}
			#define SELECT_COLOR_MENU(x) for(int i=0; i<menuitemColorSchemes.length; ++i) \
			                             	menuitemColorSchemes[i].setState(false); \
			                             menuitemColorSchemes[x].setState(true)
			else if(e.getSource().equals( menuitemColorSchemes[0] )) {
				int[][] c={ {0xa0, 0xe0, 0x20},	// WHITE
										{0x70, 0xb0, 0x40},  // LIGHTGRAY
										{0x40, 0x70, 0x32},  // DARKGRAY
										{0x10, 0x50, 0x26}}; // BLACK
				cpu.VC.setGrayShades(c);
				cs.setVisible( false );
				configStateChanged = true;
				SELECT_COLOR_MENU( 0 );
			}
			else if(e.getSource().equals( menuitemColorSchemes[1] )) {
				int[][] c={ {0xf8, 0xf8, 0xf8},	// WHITE
										{0xa8, 0xa8, 0xa8},  // LIGHTGRAY
										{0x60, 0x60, 0x60},  // DARKGRAY
										{0x00, 0x00, 0x00}}; // BLACK
				cpu.VC.setGrayShades(c);
				cs.setVisible( false );
				configStateChanged = true;
				SELECT_COLOR_MENU( 1 );
			}
			else if(e.getSource().equals( menuitemColorSchemes[2] )) {
				int[][] c={ {0xc5, 0xc5, 0xc5},	// WHITE
										{0x9a, 0x9a, 0x9a},  // LIGHTGRAY
										{0x61, 0x61, 0x61},  // DARKGRAY
										{0x3f, 0x3f, 0x3f}}; // BLACK
				cpu.VC.setGrayShades(c);
 				cs.setVisible( false );
				configStateChanged = true;
				SELECT_COLOR_MENU( 2 );
			}
			else if (e.getSource().equals( menuitemColorSchemes[3] )) {
				if ( !cpu.isCGB() ) {
					if (!loading) cs.setVisible( true );
					configStateChanged = true;
					SELECT_COLOR_MENU( 3 );
				}
				else {
					JOptionPane.showMessageDialog(frame,
                                        "You are not allowed to change colors",
                                        "color error",
					                              JOptionPane.ERROR_MESSAGE);
				}
			}
			else if(e.getSource().equals( menuitemToggleRemoteKeys )) {
				cpu.useRemoteKeys = !cpu.useRemoteKeys;
				addOSDLine("Remote Keys: "+(cpu.useRemoteKeys?"Enabled":"Disabled"));
			}
			else if(e.getSource().equals( menuitemShowAdvancedAudioPropertiesDialog )) {
				advancedAudioPropertiesDialog.showWindow();
			}
			else if (savestateRadioGroup.contains(e.getSource())) {
				int idx = savestateRadioGroup.getSelectedIndex();
				selectedState = idx;
				addOSDLine("Selected State "+selectedState);
			}
			else { //timer?
				if(menuItems!=null)
					for (int i = 0; i < menuItems.length; ++i) {
						if (e.getSource().equals(menuItems[i]))
						tryToLoadROM((String)rcFiles.get(i));
				}
				//PRINTLN("timer!");
				long ctime = System.nanoTime();
				long timeLapse =  ctime - FPSTimeMillis;
				FPSTimeMillis = ctime;
				double afps=fps/(timeLapse/1000000000.0);
				double emuspeed = ((int)(afps/(4194304.0/702240000.0)))/100.0;
				frame.setTitle("JGBE V"+Version.str+" - "+((int)(afps*100))/100.0+" fps / "+emuspeed+"% - "+ CPU.TotalCycleCount);
				//cpu.AC.srendered = 0;
				fps = 0;
			}
			if (configStateChanged ) saveConfig();
		}
		long FPSTimeMillis = System.nanoTime();

		public void itemStateChanged( ItemEvent e ) {
			JMenuItem source = ( JMenuItem )( e.getSource() );
			String s = "Menu Item source: " + source.getText()
			           + " (an instance of " + getClassName( source ) + ")"
			           + "\n"
			           + "    State of check Box: "
			           + (( e.getStateChange() == ItemEvent.SELECTED ) ?
			              "selected":"unselected" );
			PRINTLN( s );
		}

		public void keyTyped(KeyEvent e) {
			//PRINTLN("keyTyped");
		}

		static final int[] keyMasks = {
			BUTTON_UP,
			BUTTON_DOWN,
			BUTTON_LEFT,
			BUTTON_RIGHT,
			BUTTON_A,
			BUTTON_B,
			BUTTON_START,
			BUTTON_SELECT,
		};

		public void keyReleased(KeyEvent e) {
			int keyCode = e.getKeyCode();
			int keyModifiers = e.getModifiers();
			int keyState = keyCode | (keyModifiers << 8);

			for(int i=0; i<8; ++i) {
				if((keyMap[i]&0xff)==keyCode) { //Check just the keycode, modifiers don't matter for release
					cpu.releaseButton(keyMasks[i]);
					return;
				}
			}
			for(int i=8; i<16; ++i) {
				if(keyMap[i]==keyState) {
					cpu.releaseRemoteButton(keyMasks[i&7]);
					return;
				}
			}
			if(keyCode == 32) { //FIXME: Not configurable....
				cpu.AC.speedHax = false;
			}
		}

		public void keyPressed(KeyEvent e) {
			int keyCode = e.getKeyCode();
			int keyModifiers = e.getModifiers();
			int keyState = keyCode | (keyModifiers << 8);

			for(int i=0; i<8; ++i) {
				if(keyMap[i]==keyState) {
					cpu.pressButton(keyMasks[i]);
					return;
				}
			}
			for(int i=8; i<16; ++i) {
				if(keyMap[i]==keyState) {
					cpu.pressRemoteButton(keyMasks[i&7]);
					return;
				}
			}
			if(keyCode == 32) { //FIXME: Not configurable....
				cpu.AC.speedHax = true;
			}
		}

		public void makeRcFilesMenuItems() {
			int staticMenuItems = 4;

			if (menuFile != null) {
				while (menuFile.getItemCount() > staticMenuItems) {
					menuFile.remove(staticMenuItems);
				}

				menuItems = new JMenuItem[rcFiles.size()];

				menuFile.addSeparator();

				for (int i = 0; i < rcFiles.size(); ++i) {
					String lname = (String)rcFiles.get(i);
					String name = lname.substring(lname.lastIndexOf(File.separator) + 1);
					menuItems[i] = new JMenuItem(name);
					menuFile.add(menuItems[i]);
					menuItems[i].addActionListener(this);
				}
			}

		}


		// Returns the class name, no package info
		protected static String getClassName( Object o ) {
			String classString = o.getClass().getName();
			int dotIndex = classString.lastIndexOf( "." );
			return classString.substring( dotIndex+1 );	//Returns only Class name
		}

		public void loadRCFiles() {
			try {
				String rcfilename = FHandler.JGBEDir("") + "rcfiles.log";
				BufferedReader in = new BufferedReader(new FileReader(rcfilename));
				String str;
				rcFiles.clear();
				while ((str = in.readLine()) != null) {
						rcFiles.add(str);
				}
				in.close();
			} catch (IOException e) {
				PRINTLN("error reading rcfiles.log");
			}
		}

		public void saveRCFiles() {
			try {
				String rcfilename = FHandler.JGBEDir("") + "rcfiles.log";
				BufferedWriter out = new BufferedWriter(new FileWriter(rcfilename));
				String str;
				int num = MIN(10, rcFiles.size());
				for (int i = 0; i < num; ++i) {
					str = (String)rcFiles.get(i);
					out.write(str, 0, str.length());
					out.newLine();
				}
				out.close();
			} catch (IOException e) {
				PRINTLN("error writing rcfiles.log");
			}
			makeRcFilesMenuItems();
		}

		public void saveConfig() {
			if(!loading) try {
				String filename = FHandler.JGBEDir("") + "jgbe.conf";
				BufferedWriter out = new BufferedWriter(new FileWriter(filename));
				String str;
				boolean runbiosonreset = menuitemUseBIOS.getState();
				boolean soundchannel1active = cpu.AC.channelActive(1);
				boolean soundchannel2active = cpu.AC.channelActive(2);
				boolean soundchannel3active = cpu.AC.channelActive(3);
				boolean soundchannel4active = cpu.AC.channelActive(4);
				boolean usecheats = cheatcodes.UseCheats;
				#define SAVE_VAL(x) str=#x + " = " + (x); out.write(str, 0, str.length()); out.newLine()

				str = "\
# Notice:\n\
#   Editing this file manually might cause JGBE to crash upon start.\n\
#   If this happens, simply delete this file and try again.\n\
";out.write(str, 0, str.length()); out.newLine();
				SAVE_VAL(cpu.AC.isMuted);
				SAVE_VAL(biosfilename);
				SAVE_VAL(runbiosonreset);
				SAVE_VAL(VC.nscale);
				SAVE_VAL(VC.fskip);
				SAVE_VAL(soundchannel1active);
				SAVE_VAL(soundchannel2active);
				SAVE_VAL(soundchannel3active);
				SAVE_VAL(soundchannel4active);
				SAVE_VAL(usecheats);

				/* SAVE PAL */
				str = "ColorType = ";
				for (int i = 0; i < menuitemColorSchemes.length; ++i)
					if (menuitemColorSchemes[i].getState()) str += i;
				out.write(str, 0, str.length()); out.newLine();
				if (menuitemColorSchemes[3].getState()) {
					str = "CustomColors =";
					for(int k=0; k<3; ++k)
						for(int i=0; i<4; ++i)
							for(int j=0; j<3; ++j)
								str+=" "+VC.getGrayShade(k)[i][j];
					out.write(str, 0, str.length()); out.newLine();
				}

				out.close();
			} catch (IOException e) {
				PRINTLN("error writing jgbe.conf");
			}
		}

		private boolean loading = false;
		public void loadConfig() {
			loading = true;
			boolean runbiosonreset = false;
			boolean[] soundchannelactive = new boolean[4];
			boolean usecheats = true;
			int colorType = 0;
			biosfilename = "";
			VC.nscale = 2;
			try {
				String filename = FHandler.JGBEDir("") + "jgbe.conf";
				BufferedReader in = new BufferedReader(new FileReader(filename));
				String str;
				while ((str = in.readLine()) != null) {
// 					PRINTF("loadConfig(): `"+str+"' --> ");
					int index = str.indexOf("#");	if(index>=0) str = str.substring(0, index).trim();
					index=str.indexOf("=");
					String property, value;
					if(index>=0) {
						property = str.substring(0, index).trim();
						value = str.substring( index+1, str.length()).trim();
					}
					else {
						property="";
						value="";
					}
// 					PRINTLN(property+"("+value+")");
					#define LOAD_INT_VAL(x) if( property.equalsIgnoreCase( #x ) ) { \
					                        	try { \
					                        		(x) = Integer.parseInt(value); \
					                        	} catch( Exception e) { } \
					                         }
					#define LOAD_BOOL_VAL(x) if( property.equalsIgnoreCase( #x ) ) { \
					                         	x = value.equalsIgnoreCase("True"); \
					                         }
					#define LOAD_STRING_VAL(x) if( property.equalsIgnoreCase( #x ) ) { \
					                             	x = value; \
					                             }

					LOAD_BOOL_VAL( cpu.AC.isMuted );
					LOAD_STRING_VAL( biosfilename );
					LOAD_BOOL_VAL( runbiosonreset );
					LOAD_INT_VAL( VC.nscale );
					LOAD_INT_VAL( VC.fskip );
					for (int i = 0; i < 4; ++i)
						if (property.equalsIgnoreCase("soundchannel"+(i+1)+"active"))
							soundchannelactive[i] = value.equalsIgnoreCase("True");

					/* LOAD PAL */
					if (property.equalsIgnoreCase("ColorType")) {
						try {
							colorType = Integer.parseInt(value);
						} catch( Exception e) { };
					}
					if(property.equalsIgnoreCase("CustomColors")) {
						String[] strs = value.split(" ");

						int[][][] ints = new int[3][4][3];
						for (int k = 0; k < 3; ++k) {
							for (int i = 0; i < 12; ++i) {
								try {
									ints[k][i / 3][i % 3] = Integer.parseInt(strs[k*12+i]);
								} catch( Exception e) { };
							}
						}
						cpu.VC.setGrayShades(ints[0],ints[1],ints[2]);
					}
				}
				in.close();
			} catch (IOException e) {
				PRINTLN("error reading jgbe.conf");
			}
			grfx.setPreferredSize( new Dimension( 160*cpu.VC.nscale, 144*cpu.VC.nscale ) ); //quadruple each pixel
			grfx.setSize( new Dimension( 160*cpu.VC.nscale, 144*cpu.VC.nscale ) ); //quadruple each pixel
			frame.pack();
			menuitemUseBIOS.setState(runbiosonreset);
			menuitemEnableSound.setState(!cpu.AC.isMuted);
			for (int i = 0; i < 4; ++i) {
				cpu.AC.setChannelActive(i+1, soundchannelactive[i]);
				((JCheckBoxMenuItem)soundChannelGroup.get(i)).setState(soundchannelactive[i]);
			}
			actionPerformed(new ActionEvent(menuitemColorSchemes[colorType], 0, ""));
			scaleRadioGroup.setSelectedIndex(VC.nscale-1);
			if(!usecheats) cheatcodes.ToggleCheats(cart); //by default on
			menuitemEnableCheats.setState(usecheats);
			loading = false;

			// FIXME: save/load these
			interpolationRadioGroup.setSelectedIndex(0);
			keepAspectRatio.setState(true);
			keepAspectRatio.setEnabled(false);
			enableFullScreen.setState(false);
			enableFullScreen.setEnabled(true);
		}

		#define PRINT_KEY_DEFAULT PRINTLN((keyMap[i]>>8>0 ? \
		                                  KeyEvent.getKeyModifiersText(keyMap[i]>>8)+"+" : "") +\
		                                  KeyEvent.getKeyText(keyMap[i]&0xff))
		private void saveKeyBinds() {
			DataOutputStream distream=null;
			try {
				String path = FHandler.JGBEDir("") + "keys.conf";
				FileOutputStream fistream = new FileOutputStream(path);
				distream = new DataOutputStream(fistream);
				for(int i=0; i<16+nrOfShortCuts; ++i) {
					distream.writeInt(keyMap[i]);
//  					PRINT_KEY_DEFAULT;
				}
			}
			catch(IOException e) { //File not found or error reading it
					JOptionPane.showMessageDialog(frame,
                                        "Could not save keybinds!",
                                        "Error",
					                              JOptionPane.ERROR_MESSAGE);
			}
			finally {
				try {
					distream.close();
				}
				catch(Exception e) {
				}
			}
		}

		private void tryToLoadROM(String filename) {
			pauseEmulation(false);
			Cartridge tcart=new Cartridge(filename);
			if (menuitemUseBIOS.getState())
				tcart.loadBios(biosfilename);
			else
				tcart.loadBios("");
			if(tcart.getError() == null) {
				cart = tcart;
				CPU.loadCartridge(cart);
				updateCartName(filename);
				cheatcodes = new CheatCodeEditor(frame, curcartname);
				cheatcodes.applyCheatCodes(cart);
				addOSDLine("loaded Rom: " + curcartname);
			}
			else { //error loading file as ROM
				JOptionPane.showMessageDialog(frame, "There was an error loading this ROM!\n("+tcart.getError()+")" , "Error!", JOptionPane.ERROR_MESSAGE);
			}
			resumeEmulation(false);
		}

		private void loadKeyBinds() {
			DataInputStream distream=null;
			try {
				String path = FHandler.JGBEDir("") + "keys.conf";
				FileInputStream fistream = new FileInputStream(path);
				distream = new DataInputStream(fistream);
				for(int i=0; i<16+nrOfShortCuts; ++i) {
						keyMap[i] = distream.readInt();
				}
			}
			catch(IOException e) { //File not found or error reading it
				pauseEmulation(false);
				JOptionPane.showMessageDialog(frame,
					"Keys need to be configured",
					"Warning",
					JOptionPane.WARNING_MESSAGE);
				generateDefaultKeyBinds();
				keyConfigDialog k=new keyConfigDialog(frame,keyMap);
				k.getKeyCodes();
				saveKeyBinds();
				resumeEmulation(false);
			}
			finally {
				try {
					applyAccelerators();
					distream.close();
				}
				catch(Exception e) {
				}
			}
		}

		private void generateDefaultKeyBinds() {
			//Magix
			keyMap[0]=38; // Up
			keyMap[1]=40; // Down
			keyMap[2]=37; // Left
			keyMap[3]=39; // Right
			keyMap[4]=90; // Z
			keyMap[5]=88; // X
			keyMap[6]=61; // Equals
			keyMap[7]=45; // Minus
			keyMap[8]=73; // I
			keyMap[9]=75; // K
			keyMap[10]=74; // J
			keyMap[11]=76; // L
			keyMap[12]=91; // Open Bracket
			keyMap[13]=93; // Close Bracket
			keyMap[14]=222; // Quote
			keyMap[15]=59; // Semicolon
			keyMap[16]=556; // Ctrl+Comma
			keyMap[17]=591; // Ctrl+O
			keyMap[18]=19; // Pause
			keyMap[19]=594; // Ctrl+R
			keyMap[20]=593; // Ctrl+Q
			keyMap[21]=561; // Ctrl+1
			keyMap[22]=562; // Ctrl+2
			keyMap[23]=563; // Ctrl+3
			keyMap[24]=564; // Ctrl+4
			keyMap[25]=605; // Ctrl+Close Bracket
			keyMap[26]=603; // Ctrl+Open Bracket
			keyMap[27]=560; // Ctrl+0
			keyMap[28]=569; // Ctrl+9
			keyMap[29]=568; // Ctrl+8
			keyMap[30]=567; // Ctrl+7
			keyMap[31]=595; // Ctrl+S
			keyMap[32]=588; // Ctrl+L
			keyMap[33]=577; // Ctrl+A
			keyMap[34]=2097; // Alt+1
			keyMap[35]=2098; // Alt+2
			keyMap[36]=2099; // Alt+3
			keyMap[37]=2100; // Alt+4
			keyMap[38]=704; // Ctrl+Back Quote
			keyMap[39]=604; // Ctrl+Back Slash
			keyMap[40]=829; // Ctrl+Shift+Equals
			keyMap[41]=557; // Ctrl+Minus
			keyMap[42]=861; // Ctrl+Shift+Close Bracket
			keyMap[43]=859; // Ctrl+Shift+Open Bracket
			keyMap[44]=573; // Ctrl+Equals
		}

		static Cartridge cart = null;

		public void init() {
			JLabel label = new JLabel("The emulator will be opened in a new window.");
			getContentPane().add(label);
		}

		public static void starter(swinggui gui, String[] args) {
			gui.loadRCFiles();
			boolean sound=true, debug=false, lastcart=false;
			String romfile="", logfile="";
			for (int i = 0; i < args.length; ++i) {
				if (args[i].charAt(0)!='-')
					romfile = args[i];
				if (args[i].equals("-log"))
					logfile = args[++i];
				if (args[i].equals("-nosound"))
					sound = false;
				if (args[i].equals("-sound"))
					sound = true;
				if (args[i].equals("-debug"))
					debug = true;
				if ((args[i].equals("-lastcart"))) //TODO: FIXME: Invert this (current behavious is a work-around)
					lastcart=true;
			}
			if(lastcart && (gui.rcFiles.size() > 0))
				romfile = (String)gui.rcFiles.get(0);

			gui.cpu = new CPU();
			gui.audioDriver = new AudioDriver(gui.cpu.AC);
			CPU.AC.addIAudioListener(gui.audioDriver);

			gui.VC = gui.cpu.VC;
			gui.cs = new ColorSelector( gui );
			gui.createAndShowGUI();
			//Audio Properties Dialog
			advancedAudioPropertiesDialog = new AdvancedAudioPropertiesDialog(frame, gui.audioDriver);
// 			advancedAudioPropertiesDialog.showWindow();

			if (!romfile.equals(""))
				gui.tryToLoadROM(romfile);
			if(cheatcodes==null) cheatcodes = new CheatCodeEditor(frame, curcartname);
			if (gui.menuitemUseBIOS.getState() && cart != null) cart.loadBios(biosfilename);
			gui.loadKeyBinds();

			cheatcodes.applyCheatCodes(cart);

			gui.loadConfig();

			gui.cpu.VC.addListener(gui.grfx);
			if (!sound)
				gui.cpu.AC.isMuted = true;

			Timer timer = new Timer(1000, gui);
			timer.setInitialDelay(1000);
			timer.start();

			if (cart != null)
				gui.cpu.loadCartridge(cart);

			gui.makeRcFilesMenuItems();

			//DEBUGGER
			if (debug) {
				Debugger dbgr = new Debugger(gui, logfile); //The GUI to which this debugger belongs
				gui.cpuRunner = dbgr.runner;
			}
			else {
				gui.cpuRunner = new SimpleCPURunner();
				gui.resumeEmulation(false);
			}
			PRINTFREEMEM("Emulator up & running");
		}

		public void start() {
			try {
				isApplet = true;
				final swinggui gui=this;
				String[] args = getParameter("params").split(" ");

				starter(gui, args);
			} catch (Exception e) {
				// prevent browser crash on unchecked exception
			}
		}

		public static void main(String[] args) {
			final swinggui gui=new swinggui();
			starter(gui, args);
		}

		public void windowActivated(WindowEvent e) {}
		public void windowClosing(WindowEvent e) {
			windowClosed(e);
		}
		public void windowDeactivated(WindowEvent e) {}
		public void windowDeiconified(WindowEvent e) {}
		public void windowIconified(WindowEvent e) {}
		public void windowOpened(WindowEvent e) {}
		public void windowClosed(WindowEvent e) {
			if (isApplet) {
				try {
					getAppletContext().showDocument(new URL("http://code.google.com/p/jgbe/"));
				} catch ( MalformedURLException ex) {
					//ex.printstacktrace();
				}
			} else {
				System.exit(0);
			}
		}

	}
#endif
