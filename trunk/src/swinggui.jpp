#include "Global.inc"
#ifndef USE_JAVA_MOBILE
import javax.swing.*;
import javax.swing.event.*;
import java.awt.*;
import java.awt.event.*;
/* These may be needed for 'true' outline fonts
import java.awt.font.*;
import java.awt.geom.*;*/
import java.util.ArrayList;
import java.net.*;
import java.io.*;
import java.awt.image.BufferedImage;

#include "keyConfigDialog.inc"

class SimpleCPURunner implements CPURunner, Runnable {
	private volatile int threadStatus = 0;
	private Thread cpurunthread;
	// 0 means suspended
	// 1 means suspend->running requested
	// 2 means running
	// 3 means running->suspended requested
	synchronized public void suspend() {
		while (threadStatus != 0) {
			threadStatus = 3;
			while (threadStatus == 3) { YIELD; };
		}
	}

	synchronized public void resume() {
		if (!CPU.canRun()) return;
		if (threadStatus != 2) {
			threadStatus = 1;
			while (threadStatus == 1) { YIELD; };
		}
	}

	public boolean isRunning() {
		return (threadStatus != 0);
	}

	SimpleCPURunner() {
		cpurunthread = new Thread(this);
		cpurunthread.start();
		while (!cpurunthread.isAlive()) { YIELD; }; // wait for thread to actually start
	}

	public void run() {
		while (true) {
			// suspended
			while (threadStatus == 0) { YIELD; };
			// suspend -> running
			if (threadStatus == 1) threadStatus = 2;
			// running
			while ((threadStatus == 2) && (CPU.nextinstruction()!=0)) {};

			if (threadStatus == 2) { // CPU returned exception
				threadStatus = 3;
				JOptionPane.showMessageDialog(null,
				                              "Encountered an invalid instruction, perhaps ROM is broken?",
				                              "Invalid Instruction",
				                              JOptionPane.INFORMATION_MESSAGE);
			}
			// running -> suspended
			if (threadStatus == 3) threadStatus = 0;
			// suspended
		}
	}
}

public class swinggui extends JApplet implements ActionListener, ItemListener, KeyListener, ComponentListener, WindowListener {
		private static DrawingArea grfx;
		protected VideoController VC;
		protected CPU cpu;
		private int fps;
		private boolean isApplet;
		private int selectedState = 0;
		private int[] keyMap = new int[16+nrOfShortCuts]; // first 8: player 1, next 8: player 2, etc, last N-4*8 = shortcuts
		VECTOR(String) osdLines = new VECTOR(String)();
		VECTOR(String) rcFiles = new VECTOR(String)();
		int osdTime = 0;
		static public String curcartname;
		static public String biosfilename;
		//menuitem <-- here for my KDev autocomplete
		JMenuItem menuitemExit;
		JCheckBoxMenuItem menuitemScale1x;
		JCheckBoxMenuItem menuitemScale2x;
		JCheckBoxMenuItem menuitemScale3x;
		JCheckBoxMenuItem menuitemScale4x;
		JMenuItem menuitemOpenROM;
		JMenuItem menuitemSaveState;
		JMenuItem menuitemLoadState;
		JMenuItem menuitemIncFrameSkip;
		JMenuItem menuitemDecFrameSkip;
		JCheckBoxMenuItem menuitemEnableSound;
		JMenuItem[] menuitemSelectState;
		JMenuItem[] menuItems; //Savestates?
		JMenuItem menuitemSeparator;
		JMenuItem menuitemPause;
		JMenuItem menuitemReset;
		JMenu menuColorScheme;
		JCheckBoxMenuItem[] menuitemColorSchemes;
		JMenu menuSoundChannels;
		JCheckBoxMenuItem menuitemSoundChannel1;
		JCheckBoxMenuItem menuitemSoundChannel2;
		JCheckBoxMenuItem menuitemSoundChannel3;
		JCheckBoxMenuItem menuitemSoundChannel4;
		JMenu menuOther;
		JMenuItem menuitemCheats;
		JCheckBoxMenuItem menuitemEnableCheats;
		JCheckBoxMenuItem menuitemUseBIOS;
		JMenuItem menuitemSetBIOS;
		JMenu menuEmuSpeed;
		JMenuItem menuitemEmuSpeedPlus;
		JMenuItem menuitemEmuSpeedMinus;
		JMenuItem menuitemEmuSpeedMul;
		JMenuItem menuitemEmuSpeedDiv;
		JMenuItem menuitemEmuSpeedNormal;
#ifdef SCALEBUILDER
		JMenuItem menuitemScaleBuilder;
#endif
		JMenu menuLink;
		JMenuItem menuitemLinkServe;
		JMenuItem menuitemLinkClient;
		JMenuItem menuitemLinkSever;
		JMenuItem menuitemConfigKeys;
		JCheckBoxMenuItem	menuitemToggleRemoteKeys;

		static CheatCodeEditor cheatcodes;
		CPURunner cpuRunner;

		protected ColorSelector cs;

		public void updateCartName(String fname) {
			int slashPos = fname.lastIndexOf(File.separator);
			int dotPos = fname.lastIndexOf(".");
			if (dotPos == -1) dotPos = fname.length();
			curcartname = fname.substring(slashPos+1, dotPos);
			PRINTLN("cartname = " + curcartname);

			rcFiles.remove(fname);
			rcFiles.add(0, fname);
			saveRCFiles();
		}

		public class DrawingArea extends JPanel{
			private static final long serialVersionUID = 1L; // prevent warning
			VideoController VC;
			public DrawingArea(VideoController vc) {
				super();
				VC=vc;
			}
			Color ColorMediumGray = new Color(128,128,128);
			public void paintComponent(Graphics g) {
				super.paintComponent(g);
				g.drawImage(cpu.VC.getImage(),0,0, this);
				if (osdTime > 0) {
					while (osdLines.size() > 14*VC.nscale)
						osdLines.remove(0);
					g.setColor(new Color(255,255,255));
					--osdTime;
					if ((osdTime == 0) && (osdLines.size()>0)){
						osdLines.remove(0);
						osdTime = 15;
					}
					for (int i = 0; i < osdLines.size(); ++i) {
						//FIXME: Make proper Font Outlines (Difficulty: Very Hard)
						String s=(String)osdLines.get(i);
// 						g.drawString(s, 9,  10+10*i);
// 						g.drawString(s, 10,  9+10*i);
						g.setColor(ColorMediumGray);
						g.drawString(s, 11, 10+10*i);
						g.drawString(s, 10, 11+10*i);
						g.setColor(Color.WHITE);
						g.drawString(s, 10, 10+10*i);
					}
				}
				++fps;
			}
		}

		public void addOSDLine(String line) {
			osdLines.add(line);
			osdTime = 200;
		}

		public swinggui() {
			isApplet = false;
		}

		private JMenu menuFile;

		private JMenuBar createJMenuBar() {
			JMenuBar mainMenuBar;
			JMenu menuVideo;
			JMenu menuScaling;
			JMenu menuFrameSkip;
			JMenu menuState;
			JMenu menuSound;
			JMenu menuColor;
			mainMenuBar = new JMenuBar();

			menuFile = new JMenu( "File" );
			menuFile.setMnemonic( KeyEvent.VK_F );
			mainMenuBar.add( menuFile );
			menuVideo = new JMenu( "Video" );
			menuVideo.setMnemonic( KeyEvent.VK_V );
			mainMenuBar.add( menuVideo );

			menuitemOpenROM = new JMenuItem("Open ROM", KeyEvent.VK_O);
			menuitemOpenROM.addActionListener( this );
			menuFile.add(menuitemOpenROM);
			menuitemPause=new JMenuItem("Pause", KeyEvent.VK_P);
			menuitemPause.addActionListener(this);
			menuFile.add(menuitemPause);
			menuitemReset=new JMenuItem("Reset", KeyEvent.VK_R);
			menuitemReset.addActionListener(this);
			menuFile.add(menuitemReset);

			menuitemExit = new JMenuItem( "Exit", KeyEvent.VK_X );
			menuitemExit.addActionListener( this );
			menuFile.add( menuitemExit );

			menuScaling = new JMenu( "Scaling");
			menuitemScale1x = new JCheckBoxMenuItem( "Scale 1x", true );
			menuitemScale2x = new JCheckBoxMenuItem( "Scale 2x", true );
			menuitemScale3x = new JCheckBoxMenuItem( "Scale 3x", true );
			menuitemScale4x = new JCheckBoxMenuItem( "Scale 4x", true );
			menuitemScale1x.setMnemonic( KeyEvent.VK_1 );
			menuitemScale2x.setMnemonic( KeyEvent.VK_2 );
			menuitemScale3x.setMnemonic( KeyEvent.VK_3 );
			menuitemScale4x.setMnemonic( KeyEvent.VK_4 );
			menuitemScale1x.addActionListener( this );
			menuitemScale2x.addActionListener( this );
			menuitemScale3x.addActionListener( this );
			menuitemScale4x.addActionListener( this );
			menuScaling.add( menuitemScale1x );
			menuScaling.add( menuitemScale2x );
			menuScaling.add( menuitemScale3x );
			menuScaling.add( menuitemScale4x );
			menuVideo.add( menuScaling) ;

			menuFrameSkip = new JMenu( "Frame Skipping");
			menuitemIncFrameSkip = new JMenuItem( "Increase Frame Skip", KeyEvent.VK_I );
			menuitemDecFrameSkip = new JMenuItem( "Decrease Frame Skip", KeyEvent.VK_D );
			menuitemIncFrameSkip.addActionListener( this );
			menuitemDecFrameSkip.addActionListener( this );
			menuFrameSkip.add( menuitemIncFrameSkip );
			menuFrameSkip.add( menuitemDecFrameSkip );
			menuVideo.add( menuFrameSkip) ;

			menuColorScheme = new JMenu("Color scheme");
			menuitemColorSchemes = new JCheckBoxMenuItem[4];
			menuitemColorSchemes[0] = new JCheckBoxMenuItem("GameBoy LCD", false);
			menuitemColorSchemes[0].setMnemonic(KeyEvent.VK_L);
			menuitemColorSchemes[1] = new JCheckBoxMenuItem("Black and White", false);
			menuitemColorSchemes[1].setMnemonic(KeyEvent.VK_B);
			menuitemColorSchemes[2] = new JCheckBoxMenuItem("Graytones", false);
			menuitemColorSchemes[2].setMnemonic(KeyEvent.VK_G);
			menuitemColorSchemes[3] = new JCheckBoxMenuItem("Custom", false);
			menuitemColorSchemes[3].setMnemonic(KeyEvent.VK_C);
			for (int i = 0; i < menuitemColorSchemes.length; ++i) {
				menuColorScheme.add(menuitemColorSchemes[i]);
				menuitemColorSchemes[i].addActionListener(this);
			}
			menuVideo.add(menuColorScheme);

			menuState = new JMenu("State");
			menuState.setMnemonic(KeyEvent.VK_S);
			menuitemSaveState = new JMenuItem( "Save State", KeyEvent.VK_S );
			menuitemLoadState = new JMenuItem( "Load State", KeyEvent.VK_L );

			menuitemSaveState.addActionListener( this );
			menuitemLoadState.addActionListener( this );
			menuState.add( menuitemSaveState );
			menuState.add( menuitemLoadState );
			//menuState.add( menuitemSeparator );
			menuitemSelectState = new JMenuItem[10];
			for (int i = 0; i < 10; ++i) {
				menuitemSelectState[i] = new JMenuItem( "Select State " + i, KeyEvent.VK_0 + i);
				menuitemSelectState[i].setAccelerator( KeyStroke.getKeyStroke( KeyEvent.VK_0 + i, 0));
				menuitemSelectState[i].addActionListener( this );
				menuState.add(menuitemSelectState[i]);
			}
			mainMenuBar.add( menuState) ;

			menuSound = new JMenu( "Sound");
			menuSound.setMnemonic( KeyEvent.VK_U );
			menuitemEnableSound = new JCheckBoxMenuItem( "Enabled sound", true );
			menuitemEnableSound.setMnemonic( KeyEvent.VK_T );
			menuitemEnableSound.addActionListener( this );
			menuSound.add( menuitemEnableSound );
			
			menuSoundChannels=new JMenu("Channels");
			menuitemSoundChannel1=new JCheckBoxMenuItem( "Toggle channel 1", true );
			menuitemSoundChannel2=new JCheckBoxMenuItem( "Toggle channel 2", true );
			menuitemSoundChannel3=new JCheckBoxMenuItem( "Toggle channel 3", true );
			menuitemSoundChannel4=new JCheckBoxMenuItem( "Toggle channel 4", true );

			menuitemSoundChannel1.setMnemonic( KeyEvent.VK_1 );
			menuitemSoundChannel2.setMnemonic( KeyEvent.VK_2 );
			menuitemSoundChannel3.setMnemonic( KeyEvent.VK_3 );
			menuitemSoundChannel4.setMnemonic( KeyEvent.VK_4 );
			menuitemSoundChannel1.addActionListener(this);
			menuitemSoundChannel2.addActionListener(this);
			menuitemSoundChannel3.addActionListener(this);
			menuitemSoundChannel4.addActionListener(this);
			menuSoundChannels.add(menuitemSoundChannel1);
			menuSoundChannels.add(menuitemSoundChannel2);
			menuSoundChannels.add(menuitemSoundChannel3);
			menuSoundChannels.add(menuitemSoundChannel4);
			menuSound.add(menuSoundChannels);
			mainMenuBar.add( menuSound) ;
			menuOther=new JMenu("Other");
			menuOther.setMnemonic( KeyEvent.VK_O );
			menuitemCheats = new JMenuItem("Edit cheats", KeyEvent.VK_C);
			menuitemCheats.addActionListener(this);
			menuitemEnableCheats=new JCheckBoxMenuItem("Enable cheat codes", false);
			menuitemEnableCheats.setMnemonic(KeyEvent.VK_T);
			menuitemEnableCheats.addActionListener(this);
			menuitemUseBIOS=new JCheckBoxMenuItem("Run BIOS on reset", false);
			menuitemUseBIOS.setMnemonic(KeyEvent.VK_B);
			menuitemUseBIOS.addActionListener(this);
			menuitemSetBIOS=new JMenuItem("Select BIOS ROM", KeyEvent.VK_B);
			menuitemSetBIOS.addActionListener(this);
			
#ifdef SCALEBUILDER
			menuitemScaleBuilder=new JMenuItem("Built Scale", KeyEvent.VK_S);
			menuitemScaleBuilder.addActionListener(this);
			menuOther.add(menuitemScaleBuilder);
#endif
			menuitemToggleRemoteKeys = new JCheckBoxMenuItem("Use Remote Keys", false);
			menuitemToggleRemoteKeys.setMnemonic(KeyEvent.VK_R);
			menuitemToggleRemoteKeys.addActionListener(this);

			menuLink=new JMenu("Link");
			menuLink.setMnemonic( KeyEvent.VK_L );
			menuitemLinkServe = new JMenuItem("Start Link Server", KeyEvent.VK_S);
			menuitemLinkClient = new JMenuItem("Start Link Client", KeyEvent.VK_C);
			menuitemLinkSever = new JMenuItem("Stop Link", KeyEvent.VK_L);
			menuitemLinkServe.addActionListener(this);
			menuitemLinkClient.addActionListener(this);
			menuitemLinkSever.addActionListener(this);
			menuLink.add(menuitemLinkServe);
			menuLink.add(menuitemLinkClient);
			menuLink.add(menuitemLinkSever);
			mainMenuBar.add( menuLink ) ;

			menuitemConfigKeys = new JMenuItem("Config keys",KeyEvent.VK_1);
			menuitemConfigKeys.addActionListener(this);
			menuOther.add(menuitemEnableCheats);
			menuOther.add(menuitemUseBIOS);
			menuOther.add(menuitemToggleRemoteKeys);
			menuOther.add(menuitemCheats);
			menuOther.add(menuitemSetBIOS);
			menuOther.add(menuitemConfigKeys);
			
			menuEmuSpeed = new JMenu("Emulation Speed");
			menuitemEmuSpeedPlus  = new JMenuItem("+25%", KeyEvent.VK_PLUS);
			menuitemEmuSpeedMinus = new JMenuItem("-25%", KeyEvent.VK_MINUS);
			menuitemEmuSpeedMul  = new JMenuItem("*125%", KeyEvent.VK_OPEN_BRACKET);
 			menuitemEmuSpeedDiv = new JMenuItem("*75%", KeyEvent.VK_CLOSE_BRACKET);
			menuitemEmuSpeedNormal= new JMenuItem("100%", KeyEvent.VK_EQUALS);
			menuitemEmuSpeedPlus.addActionListener(this);
			menuitemEmuSpeedMinus.addActionListener(this);
			menuitemEmuSpeedMul.addActionListener(this);
			menuitemEmuSpeedDiv.addActionListener(this);
			menuitemEmuSpeedNormal.addActionListener(this);
			menuEmuSpeed.add(menuitemEmuSpeedPlus);
			menuEmuSpeed.add(menuitemEmuSpeedMinus);
			menuEmuSpeed.add(menuitemEmuSpeedMul);
			menuEmuSpeed.add(menuitemEmuSpeedDiv);
			menuEmuSpeed.add(menuitemEmuSpeedNormal);
			menuOther.add(menuEmuSpeed ) ;
			mainMenuBar.add( menuOther) ;

			return mainMenuBar;
		}

		private void applyAccelerators() {
			int keyMapIndex=16; // Accelerators start at 16
			#define NEXT_KEYSTROKE_FROM_KEYMAP KeyStroke.getKeyStroke( keyMap[keyMapIndex]&0xff, keyMap[keyMapIndex++]>>8 )
			menuitemConfigKeys.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemOpenROM.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemPause.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemReset.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemExit.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemScale1x.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemScale2x.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemScale3x.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemScale4x.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemIncFrameSkip.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemDecFrameSkip.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemColorSchemes[0].setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemColorSchemes[1].setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemColorSchemes[2].setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemColorSchemes[3].setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemSaveState.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemLoadState.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemEnableSound.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemSoundChannel1.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemSoundChannel2.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemSoundChannel3.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemSoundChannel4.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemCheats.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemEnableCheats.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemEmuSpeedPlus.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemEmuSpeedMinus.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemEmuSpeedMul.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
			menuitemEmuSpeedDiv.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);			menuitemEmuSpeedNormal.setAccelerator(NEXT_KEYSTROKE_FROM_KEYMAP);
		}
		public void addComponentsToPane( Container contentPane ) {
//      Use BorderLayout. Default empty constructor with no horizontal and vertical
//      gaps
// 			contentPane.setLayout( new BorderLayout( 5,5 ) );
			contentPane.setLayout(new FlowLayout(FlowLayout.CENTER,0,0));
// 			if ( !( contentPane.getLayout() instanceof BorderLayout ) ) {
// 				contentPane.add( new JLabel( "Container doesn't use BorderLayout!" ) );
// 				return;
// 			}

			grfx=new DrawingArea( cpu.VC ); //doublebuffering
			grfx.setFocusable(true);
			grfx.addKeyListener(this);
			grfx.setDoubleBuffered(false);
			grfx.setPreferredSize( new Dimension( 160*cpu.VC.nscale, 144*cpu.VC.nscale ) ); //quadruple each pixel
			contentPane.add( grfx );
		}

		static JFrame frame;

		private void createAndShowGUI() {
			//JFrame.setDefaultLookAndFeelDecorated( true );

			frame = new JFrame( "JGameBoy Emulator V"+Version.str);
			frame.setDefaultCloseOperation( JFrame.DO_NOTHING_ON_CLOSE );
// 			frame.setBounds( 60,60,100,100 );

			//Set up the content pane and add swing components to it
			frame.setJMenuBar( createJMenuBar() );
			addComponentsToPane( frame.getContentPane() );
			Toolkit toolkit = Toolkit.getDefaultToolkit();
			URL imgurl = getClass().getResource("icon.gif");
			if(imgurl!=null) {
				Image image = toolkit.getImage(imgurl);
				frame.setIconImage(image);
			}
			else {
				PRINTLN("Can't load JGBE icon!");
			}
			frame.addComponentListener(this);
			frame.addWindowListener(this);

			frame.setResizable(false);
			frame.pack();
			Dimension d = Toolkit.getDefaultToolkit().getScreenSize();
			Point     p = new Point();
			p.setLocation((d.getWidth()/2) - (frame.getWidth()/2), (d.getHeight()/2)-(frame.getHeight()/2));
			frame.setLocation(p);
			frame.setVisible( true );
		}

		public void componentHidden(ComponentEvent e) {}
		public void componentMoved(ComponentEvent e) {}
		public void componentShown(ComponentEvent e) {}
		public void componentResized(ComponentEvent e) {}

		public void pauseEmulation(boolean verbose) {
			if(cpuRunner!=null) {
				cpuRunner.suspend();
				if(verbose) addOSDLine("Paused gameboy");
			}
		}

		public void resumeEmulation(boolean verbose) {
			if((cpuRunner!=null)&&(cart!=null)) {
				cpuRunner.resume();
				if(verbose) addOSDLine("Unpaused gameboy");
			}
		}

		public void actionPerformed( ActionEvent e ) {
/*				JMenuItem source = ( JMenuItem )( e.getSource() );
				String s = "Menu Item source: " + source.getText()
			           + " (an instance of " + getClassName( source ) + ")";
				System.out.println(s);*/
			#define SET_SCALE_MODE_BOOLEANS menuitemScale1x.setState( VC.nscale == 1 ); \
			                                menuitemScale2x.setState( VC.nscale == 2 ); \
			                                menuitemScale3x.setState( VC.nscale == 3 ); \
			                                menuitemScale4x.setState( VC.nscale == 4 ); \

			boolean configStateChanged = false;
			if (e.getSource().equals( menuitemExit)) {
				windowClosed(null);
			}
			else if (e.getSource().equals( menuitemScale1x )) {
				addOSDLine("Set scaling: Scale1x");
				VC.nscale = 1;
 				grfx.setPreferredSize( new Dimension( 160*cpu.VC.nscale, 144*cpu.VC.nscale ) ); //quadruple each pixel
				grfx.setSize( new Dimension( 160*cpu.VC.nscale, 144*cpu.VC.nscale ) ); //quadruple each pixel
				frame.pack();
				configStateChanged = true;
				SET_SCALE_MODE_BOOLEANS;
			}
			else if (e.getSource().equals( menuitemScale2x )) {
				addOSDLine("Set scaling: Scale2x");
				VC.nscale = 2;
 				grfx.setPreferredSize( new Dimension( 160*cpu.VC.nscale, 144*cpu.VC.nscale ) ); //quadruple each pixel
				grfx.setSize( new Dimension( 160*cpu.VC.nscale, 144*cpu.VC.nscale ) ); //quadruple each pixel
				frame.pack();
				configStateChanged = true;
				SET_SCALE_MODE_BOOLEANS;
			}
			else if (e.getSource().equals( menuitemScale3x )) {
				addOSDLine("Set scaling: Scale3x");
				VC.nscale = 3;
 				grfx.setPreferredSize( new Dimension( 160*cpu.VC.nscale, 144*cpu.VC.nscale ) ); //quadruple each pixel
				grfx.setSize( new Dimension( 160*cpu.VC.nscale, 144*cpu.VC.nscale ) ); //quadruple each pixel
				frame.pack();
				configStateChanged = true;
				SET_SCALE_MODE_BOOLEANS;
			}
			else if (e.getSource().equals( menuitemScale4x )) {
				addOSDLine("Set scaling: Scale4x");
				VC.nscale = 4;
 				grfx.setPreferredSize( new Dimension( 160*cpu.VC.nscale, 144*cpu.VC.nscale ) ); //quadruple each pixel
				grfx.setSize( new Dimension( 160*cpu.VC.nscale, 144*cpu.VC.nscale ) ); //quadruple each pixel
				frame.pack();
				configStateChanged = true;
				SET_SCALE_MODE_BOOLEANS;
			}
			else if (e.getSource().equals( menuitemIncFrameSkip )) {
				++VC.fskip;
				addOSDLine("Increased frameskip: "+VC.fskip);
				configStateChanged = true;
			}
			else if (e.getSource().equals( menuitemDecFrameSkip )) {
				if (VC.fskip>1) --VC.fskip;
				addOSDLine("Decreased frameskip: "+VC.fskip);
				configStateChanged = true;
			}
			else if (e.getSource().equals( menuitemEnableSound )) {
				cpu.AC.isMuted = !menuitemEnableSound.getState();
				addOSDLine( cpu.AC.isMuted?"Disabled sound":"Enabled sound");
				configStateChanged = true;
			}
			else if (e.getSource().equals( menuitemSoundChannel1)) {
				cpu.AC.toggleChannelOnOff(1);
				addOSDLine(cpu.AC.S1.muted==0 ? "Disabled soundchannel 1" : "Enabled soundchannel 1");
				configStateChanged = true;
			}
			else if (e.getSource().equals( menuitemSoundChannel2)) {
				cpu.AC.toggleChannelOnOff(2);
				addOSDLine(cpu.AC.S2.muted==0 ? "Disabled soundchannel 2" : "Enabled soundchannel 2");
				configStateChanged = true;
			}
			else if (e.getSource().equals( menuitemSoundChannel3)) {
				cpu.AC.toggleChannelOnOff(3);
				addOSDLine(cpu.AC.S3.muted==0 ? "Disabled soundchannel 3" : "Enabled soundchannel 3");
				configStateChanged = true;
			}
			else if (e.getSource().equals( menuitemSoundChannel4)) {
				cpu.AC.toggleChannelOnOff(4);
				addOSDLine(cpu.AC.S4.muted==0 ? "Disabled soundchannel 4" : "Enabled soundchannel 4");
				configStateChanged = true;
			}
			else if (e.getSource().equals( menuitemEnableCheats)) {
				cheatcodes.ToggleCheats(cart);
				addOSDLine("Cheats codes are now " + (cheatcodes.UseCheats?"enabled":"disabled") );
			}
			else if (e.getSource().equals( menuitemConfigKeys )) {
				keyConfigDialog k=new keyConfigDialog(frame, keyMap);
				pauseEmulation(false);
				k.getKeyCodes();
				saveKeyBinds();
				applyAccelerators();
				resumeEmulation(false);
			}
#ifdef SCALEBUILDER
			else if (e.getSource().equals( menuitemScaleBuilder)) {
				ScaleBuilder sb = new ScaleBuilder(frame);
				//sb.showOpenDialog();
			}
#endif
			else if (e.getSource().equals( menuitemCheats)) {
				pauseEmulation(false);
				cheatcodes.editCodes();
				cheatcodes.applyCheatCodes(cart);
				resumeEmulation(false);
				addOSDLine("ZOMG CHEATER!!!!");
			}
			else if(e.getSource().equals( menuitemUseBIOS )) {
				if (menuitemUseBIOS.getState()) cart.loadBios(biosfilename);
				else cart.loadBios("");
				configStateChanged = true;
			}
			else if(e.getSource().equals( menuitemSetBIOS )) {
				JFileChooser fc = new JFileChooser(".");
				fc.showOpenDialog(frame);
				File selFile = fc.getSelectedFile();
				if(selFile != null) {
					if(selFile.length() != 256) JOptionPane.showMessageDialog(null,
					                            "This file's size is not equal to 256 bytes!",
					                            "Invalid BIOS Rom",
					                            JOptionPane.INFORMATION_MESSAGE);
					else {
						biosfilename = selFile.getAbsolutePath();
						if (menuitemUseBIOS.getState()) cart.loadBios(biosfilename);
						else cart.loadBios("");
						configStateChanged = true;
					}
				}
			}
			else if(e.getSource().equals( menuitemOpenROM )) {
				JFileChooser fc;
				if (rcFiles.size() > 0) {
					String lastpath = (String)rcFiles.get(0);
					int slashPos = lastpath.lastIndexOf(File.separator);
					lastpath = lastpath.substring(0, slashPos+1);
					fc = new JFileChooser(lastpath);
				}
				else
					fc = new JFileChooser(".");

				// Show open dialog; this method does not return until the dialog is closed
				fc.showOpenDialog(frame);
				File selFile = fc.getSelectedFile();
				if(selFile != null) {
					tryToLoadROM(selFile.getAbsolutePath());
				}
			}
			else if(e.getSource().equals( menuitemLinkServe )) {
				try {
					CPU.serveLink();
				}
				catch (IOException ioe) {
					JOptionPane.showMessageDialog(frame, "Failed: " + ioe.getMessage(), "Error!", JOptionPane.ERROR_MESSAGE);
				}
			}
			else if(e.getSource().equals( menuitemLinkSever )) {
				CPU.severLink();
			}
			else if(e.getSource().equals( menuitemLinkClient )) {
				try {
					CPU.clientLink((String)JOptionPane.showInputDialog(frame, (Object)"Enter host address", "Link setup", JOptionPane.QUESTION_MESSAGE, null, null, "localhost"));
				}
				catch (IOException ioe) {
					JOptionPane.showMessageDialog(frame, "Failed: " + ioe.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
				}
			}
			else if(e.getSource().equals( menuitemSaveState )) {
				if (!CPU.canRun()) return;
				pauseEmulation(false);
				String stname = System.getProperty("user.home")+File.separator+ ".jgbe"+File.separator;
				File jgbedir=new File(stname);
				if(!jgbedir.exists()) if(!jgbedir.mkdir()) PRINTF("failed!\n");
				stname += "savestates"+File.separator;
				File sstatedir=new File(stname);
				if(!sstatedir.exists()) if(!sstatedir.mkdir()) PRINTF("failed!\n");
				if(sstatedir.exists()) {
					stname += curcartname + ".st" + selectedState;
					addOSDLine("Saving State "+selectedState);
					try {
						DataOutputStream dostream = FHandler.getDataOutputStream(stname);
						CPU.saveState(dostream);
						dostream.close();
					}
					catch (java.io.IOException ioe) {
						System.out.println("Error saving state! ");
					};
				}
				resumeEmulation(false);
			}
			else if(e.getSource().equals( menuitemLoadState )) {
				if (!CPU.canRun()) return;
				pauseEmulation(false);
				String stname = System.getProperty("user.home")+File.separator+".jgbe"+File.separator+"savestates"+File.separator + curcartname + ".st" + selectedState;
				addOSDLine("Loading State "+selectedState);
				try {
					DataInputStream distream = FHandler.getDataInputStream(stname);
					CPU.loadState(distream);
					distream.close();
				}
				catch (java.io.IOException ioe) {
					System.out.println("Error loading state! " + ioe.getMessage());
				};
				resumeEmulation(false);
			}
			else if(e.getSource().equals( menuitemPause )) {
				if(cpuRunner.isRunning())
					pauseEmulation(true);
				else
					resumeEmulation(true);
			}
			else if(e.getSource().equals( menuitemReset )) {
				pauseEmulation(false);
				cpu.reset();
				resumeEmulation(false);
				addOSDLine("Reset gameboy");
			}
			else if(e.getSource().equals( menuitemEmuSpeedPlus )) {
				double cs = CPU.AC.currentEmulationSpeed;
				double ns = 0.25 + cs;
				CPU.AC.setSpeed(ns);
				addOSDLine("EmuSpeed: "+(int)(ns*100.0)+"."+(int)( (ns*100.0-(int)(ns*100.0)) )+"%");
			}
			else if(e.getSource().equals( menuitemEmuSpeedMinus )) {
				double cs = CPU.AC.currentEmulationSpeed;
				double ns = Math.max(cs-0.25,0);
				CPU.AC.setSpeed(ns);
				addOSDLine("EmuSpeed: "+(int)(ns*100.0)+"."+(int)( (ns*100.0-(int)(ns*100.0)) )+"%");
			}
			else if(e.getSource().equals( menuitemEmuSpeedMul )) {
				double cs = CPU.AC.currentEmulationSpeed;
				double ns = 1.25 * cs;
				CPU.AC.setSpeed(ns);
				addOSDLine("EmuSpeed: "+(int)(ns*100.0)+"."+(int)( (ns*100.0-(int)(ns*100.0)) )+"%");
			}
			else if(e.getSource().equals( menuitemEmuSpeedDiv )) {
				double cs = CPU.AC.currentEmulationSpeed;
				double ns = 0.75 * cs;
				CPU.AC.setSpeed(ns);
				addOSDLine("EmuSpeed: "+(int)(ns*100.0)+"."+(int)( (ns*100.0-(int)(ns*100.0)) )+"%");
			}
			else if(e.getSource().equals( menuitemEmuSpeedNormal )) {
				CPU.AC.setSpeed(1.0);
				addOSDLine("EmuSpeed: 100%");
			}
			#define SELECT_COLOR_MENU(x) for(int i=0; i<menuitemColorSchemes.length; ++i) \
			                             	menuitemColorSchemes[i].setState(false); \
			                             menuitemColorSchemes[x].setState(true)
			else if(e.getSource().equals( menuitemColorSchemes[0] )) {
				int[][] c={ {0xa0, 0xe0, 0x20},	// WHITE
										{0x70, 0xb0, 0x40},  // LIGHTGRAY
										{0x40, 0x70, 0x32},  // DARKGRAY
										{0x10, 0x50, 0x26}}; // BLACK
				cpu.VC.setGrayShades(c);
				cs.setDefault(c,c,c);
				configStateChanged = true;
				SELECT_COLOR_MENU( 0 );
			}
			else if(e.getSource().equals( menuitemColorSchemes[1] )) {
				int[][] c={ {0xf8, 0xf8, 0xf8},	// WHITE
										{0xa8, 0xa8, 0xa8},  // LIGHTGRAY
										{0x60, 0x60, 0x60},  // DARKGRAY
										{0x00, 0x00, 0x00}}; // BLACK
				cpu.VC.setGrayShades(c);
				cs.setDefault(c,c,c);
				configStateChanged = true;
				SELECT_COLOR_MENU( 1 );
			}
			else if(e.getSource().equals( menuitemColorSchemes[2] )) {
				int[][] c={ {0xc5, 0xc5, 0xc5},	// WHITE
										{0x9a, 0x9a, 0x9a},  // LIGHTGRAY
										{0x61, 0x61, 0x61},  // DARKGRAY
										{0x3f, 0x3f, 0x3f}}; // BLACK
				cpu.VC.setGrayShades(c);
				cs.setDefault(c,c,c);
				configStateChanged = true;
				SELECT_COLOR_MENU( 2 );
			}
			else if (e.getSource().equals( menuitemColorSchemes[3] )) {
				if ( !cpu.isCGB() ) {
					cs.setDefault( VC.getGrayShade(0),
					 	             VC.getGrayShade(1),
					 	             VC.getGrayShade(2));
					if (!loading) cs.setVisible( true );
					configStateChanged = true;
					SELECT_COLOR_MENU( 3 );
				}
				else {
					JOptionPane.showMessageDialog(frame,
                                        "You are not allowed to change colors",
                                        "color error",
					                              JOptionPane.ERROR_MESSAGE);
				}
			}
			else if(e.getSource().equals( menuitemToggleRemoteKeys )) {
				cpu.useRemoteKeys = !cpu.useRemoteKeys;
				addOSDLine("Remote Keys: "+(cpu.useRemoteKeys?"Enabled":"Disabled"));
			}
			else { //timer?
				for (int i = 0; i < 10; ++i) {
					if (e.getSource().equals(menuitemSelectState[i])) {
						selectedState = i;
						addOSDLine("Selected State "+selectedState);
						return;
					}
				}
				if(menuItems!=null)
					for (int i = 0; i < menuItems.length; ++i) {
						if (e.getSource().equals(menuItems[i]))
						tryToLoadROM((String)rcFiles.get(i));
				}
				//System.out.println("timer!");
				long ctime = System.nanoTime();
				long timeLapse =  ctime - FPSTimeMillis;
				FPSTimeMillis = ctime;
				double afps=fps/(timeLapse/1000000000.0);
				double emuspeed = ((int)(afps/(4194304.0/702240000.0)))/100.0;
				frame.setTitle("JGBE V"+Version.str+" - "+((int)(afps*100))/100.0+" fps / "+emuspeed+"%");
				//cpu.AC.srendered = 0;
				fps = 0;
			}
			if (configStateChanged ) saveConfig();
		}
		long FPSTimeMillis = System.nanoTime();

		public void itemStateChanged( ItemEvent e ) {
			JMenuItem source = ( JMenuItem )( e.getSource() );
			String s = "Menu Item source: " + source.getText()
			           + " (an instance of " + getClassName( source ) + ")"
			           + "\n"
			           + "    State of check Box: "
			           + (( e.getStateChange() == ItemEvent.SELECTED ) ?
			              "selected":"unselected" );
			System.out.println( s );
		}

		public void keyTyped(KeyEvent e) {
			//System.out.println("keyTyped");
		}

		static final int[] keyMasks = {
			BUTTON_UP,
			BUTTON_DOWN,
			BUTTON_LEFT,
			BUTTON_RIGHT,
			BUTTON_A,
			BUTTON_B,
			BUTTON_START,
			BUTTON_SELECT,
		};

		public void keyReleased(KeyEvent e) {
			int keyCode = e.getKeyCode();
			int keyModifiers = e.getModifiers();
			int keyState = keyCode | (keyModifiers << 8);

			for(int i=0; i<8; ++i) {
				if((keyMap[i]&0xff)==keyCode) { //Check just the keycode, modifiers don't matter for release
					cpu.releaseButton(keyMasks[i]);
					return;
				}
			}
			for(int i=8; i<16; ++i) {
				if(keyMap[i]==keyState) {
					cpu.releaseRemoteButton(keyMasks[i&7]);
					return;
				}
			}
		}

		public void keyPressed(KeyEvent e) {
			int keyCode = e.getKeyCode();
			int keyModifiers = e.getModifiers();
			int keyState = keyCode | (keyModifiers << 8);

			for(int i=0; i<8; ++i) {
				if(keyMap[i]==keyState) {
					cpu.pressButton(keyMasks[i]);
					return;
				}
			}
			for(int i=8; i<16; ++i) {
				if(keyMap[i]==keyState) {
					cpu.pressRemoteButton(keyMasks[i&7]);
					return;
				}
			}
		}

		public void makeRcFilesMenuItems() {
			int staticMenuItems = 4;

			if (menuFile != null) {
				while (menuFile.getItemCount() > staticMenuItems) {
					menuFile.remove(staticMenuItems);
				}

				menuItems = new JMenuItem[rcFiles.size()];

				menuFile.addSeparator();

				for (int i = 0; i < rcFiles.size(); ++i) {
					String lname = (String)rcFiles.get(i);
					String name = lname.substring(lname.lastIndexOf(File.separator) + 1);
					menuItems[i] = new JMenuItem(name);
					menuFile.add(menuItems[i]);
					menuItems[i].addActionListener(this);
				}
			}

		}


		// Returns the class name, no package info
		protected static String getClassName( Object o ) {
			String classString = o.getClass().getName();
			int dotIndex = classString.lastIndexOf( "." );
			return classString.substring( dotIndex+1 );	//Returns only Class name
		}

		public void loadRCFiles() {
			try {
				String rcfilename = System.getProperty("user.home")+File.separator+".jgbe"+File.separator+"rcfiles.log";
				BufferedReader in = new BufferedReader(new FileReader(rcfilename));
				String str;
				rcFiles.clear();
				while ((str = in.readLine()) != null) {
						rcFiles.add(str);
				}
				in.close();
			} catch (IOException e) {
				System.out.println("error reading rcfiles.log");
			}
		}

		public void saveRCFiles() {
			try {
				String rcfilename = System.getProperty("user.home")+File.separator+".jgbe"+File.separator+"rcfiles.log";
				BufferedWriter out = new BufferedWriter(new FileWriter(rcfilename));
				String str;
				int num = MIN(10, rcFiles.size());
				for (int i = 0; i < num; ++i) {
					str = (String)rcFiles.get(i);
					out.write(str, 0, str.length());
					out.newLine();
				}
				out.close();
			} catch (IOException e) {
				System.out.println("error writing rcfiles.log");
			}
			makeRcFilesMenuItems();
		}

		public void saveConfig() { //FIXME: STUB
			if(!loading) try {
				String filename = System.getProperty("user.home")+File.separator+".jgbe"+File.separator+"jgbe.conf";
				BufferedWriter out = new BufferedWriter(new FileWriter(filename));
				String str;
				boolean runbiosonreset = menuitemUseBIOS.getState();
				boolean soundchannel1active = cpu.AC.channelActive(1);
				boolean soundchannel2active = cpu.AC.channelActive(2);
				boolean soundchannel3active = cpu.AC.channelActive(3);
				boolean soundchannel4active = cpu.AC.channelActive(4);
				boolean usecheats = cheatcodes.UseCheats;
				#define SAVE_VAL(x) str=#x + " = " + (x); out.write(str, 0, str.length()); out.newLine()

				str = "#WARNING: DO NOT EDIT THIS FILE MANUALLY!";out.write(str, 0, str.length()); out.newLine();
				SAVE_VAL(cpu.AC.isMuted);
				SAVE_VAL(biosfilename);
				SAVE_VAL(runbiosonreset);
				SAVE_VAL(VC.nscale);
				SAVE_VAL(VC.fskip);
				SAVE_VAL(soundchannel1active);
				SAVE_VAL(soundchannel2active);
				SAVE_VAL(soundchannel3active);
				SAVE_VAL(soundchannel4active);
				SAVE_VAL(usecheats);

				/* SAVE PAL */
				str = "ColorType = ";
				for (int i = 0; i < menuitemColorSchemes.length; ++i)
					if (menuitemColorSchemes[i].getState()) str += i;
				out.write(str, 0, str.length()); out.newLine();
				if (menuitemColorSchemes[3].getState()) {
					str = "CustomColors =";
					for(int k=0; k<3; ++k)
						for(int i=0; i<4; ++i)
							for(int j=0; j<3; ++j)
								str+=" "+VC.getGrayShade(k)[i][j];
					out.write(str, 0, str.length()); out.newLine();
				}

				out.close();
			} catch (IOException e) {
				System.out.println("error writing jgbe.conf");
			}
		}

		private boolean loading = false;
		public void loadConfig() { //FIXME: STUB
			loading = true;
			try {
				String filename = System.getProperty("user.home")+File.separator+".jgbe"+File.separator+"jgbe.conf";
				BufferedReader in = new BufferedReader(new FileReader(filename));
				String str;
				boolean runbiosonreset = false;
				boolean soundchannel1active = true;
				boolean soundchannel2active = true;
				boolean soundchannel3active = true;
				boolean soundchannel4active = true;
				boolean usecheats = true;
				biosfilename = "";
				VC.nscale = 2;
				while ((str = in.readLine()) != null) {
// 					PRINTF("loadConfig(): `"+str+"' --> ");
					int index = str.indexOf("#");	if(index>=0) str = str.substring(0, index).trim();
					index=str.indexOf("=");
					String property, value;
					if(index>=0) {
						property = str.substring(0, index).trim();
						value = str.substring( index+1, str.length()).trim();
					}
					else {
						property="";
						value="";
					}
// 					PRINTLN(property+"("+value+")");
					#define LOAD_INT_VAL(x) if( property.equalsIgnoreCase( #x ) ) { \
					                        	try { \
					                        		(x) = Integer.parseInt(value); \
					                        	} catch( Exception e) { } \
					                         }
					#define LOAD_BOOL_VAL(x) if( property.equalsIgnoreCase( #x ) ) { \
					                         	x = value.equalsIgnoreCase("True"); \
					                         }
					#define LOAD_STRING_VAL(x) if( property.equalsIgnoreCase( #x ) ) { \
					                             	x = value; \
					                             }

					LOAD_BOOL_VAL( cpu.AC.isMuted );
					LOAD_STRING_VAL( biosfilename );
					LOAD_BOOL_VAL( runbiosonreset );
					LOAD_INT_VAL( VC.nscale );
					LOAD_INT_VAL( VC.fskip );
					LOAD_BOOL_VAL( soundchannel1active );
					LOAD_BOOL_VAL( soundchannel2active );
					LOAD_BOOL_VAL( soundchannel3active );
					LOAD_BOOL_VAL( soundchannel4active );
					LOAD_BOOL_VAL( usecheats );

					/* LOAD PAL */
					if (property.equalsIgnoreCase("ColorType")) {
						int n = 0;
						try {
							n = Integer.parseInt(value);
						} catch( Exception e) { };
						actionPerformed(new ActionEvent(menuitemColorSchemes[n], 0, ""));
					}
					if(property.equalsIgnoreCase("CustomColors")) {
						String[] strs = value.split(" ");

						int[][][] ints = new int[3][4][3];
						for (int k = 0; k < 3; ++k) {
							for (int i = 0; i < 12; ++i) {
								try {
									ints[k][i / 3][i % 3] = Integer.parseInt(strs[k*12+i]);
								} catch( Exception e) { };
							}
						}
						cpu.VC.setGrayShades(ints[0],ints[1],ints[2]);
						cs.setDefault( VC.getGrayShade(0),
						               VC.getGrayShade(1),
						               VC.getGrayShade(2));
					}
				}
				grfx.setPreferredSize( new Dimension( 160*cpu.VC.nscale, 144*cpu.VC.nscale ) ); //quadruple each pixel
				grfx.setSize( new Dimension( 160*cpu.VC.nscale, 144*cpu.VC.nscale ) ); //quadruple each pixel
				frame.pack();
				menuitemUseBIOS.setState(runbiosonreset);
				menuitemEnableSound.setState(!cpu.AC.isMuted);
				cpu.AC.setChannelActive(1, soundchannel1active);
				cpu.AC.setChannelActive(2, soundchannel2active);
				cpu.AC.setChannelActive(3, soundchannel3active);
				cpu.AC.setChannelActive(4, soundchannel4active);
				menuitemSoundChannel1.setState( soundchannel1active );
				menuitemSoundChannel2.setState( soundchannel2active );
				menuitemSoundChannel3.setState( soundchannel3active );
				menuitemSoundChannel4.setState( soundchannel4active );
				SET_SCALE_MODE_BOOLEANS;
				if(!usecheats) cheatcodes.ToggleCheats(cart); //by default on
				menuitemEnableCheats.setState(usecheats);
				in.close();
			} catch (IOException e) {
				System.out.println("error reading jgbe.conf");
			}
			loading = false;
		}

		#define PRINT_KEY_DEFAULT PRINTLN((keyMap[i]>>8>0 ? \
		                                  KeyEvent.getKeyModifiersText(keyMap[i]>>8)+"+" : "") +\
		                                  KeyEvent.getKeyText(keyMap[i]&0xff))
		private void saveKeyBinds() {
			DataOutputStream distream=null;
			try {
				String path=FHandler.EnsureExists(""); //ensure JGBE Config dir exists
				FileOutputStream fistream = new FileOutputStream(path+"keys.conf");
				distream = new DataOutputStream(fistream);
				for(int i=0; i<16+nrOfShortCuts; ++i) {
					distream.writeInt(keyMap[i]);
//  					PRINT_KEY_DEFAULT;
				}
			}
			catch(IOException e) { //File not found or error reading it
					JOptionPane.showMessageDialog(frame,
                                        "Could not save keybinds!",
                                        "Error",
					                              JOptionPane.ERROR_MESSAGE);
			}
			finally {
				try {
					distream.close();
				}
				catch(Exception e) {
				}
			}
		}

		private void tryToLoadROM(String filename) {
			pauseEmulation(false);
			Cartridge tcart=new Cartridge(filename);
			if (menuitemUseBIOS.getState())
				tcart.loadBios(biosfilename);
			else
				tcart.loadBios("");
			if(tcart.getError() == null) {
				cart = tcart;
				CPU.loadCartridge(cart);
				updateCartName(filename);
				cheatcodes = new CheatCodeEditor(frame, curcartname);
				cheatcodes.applyCheatCodes(cart);
				addOSDLine("loaded Rom: " + curcartname);
			}
			else { //error loading file as ROM
				JOptionPane.showMessageDialog(frame, "There was an error loading this ROM!\n("+tcart.getError()+")" , "Error!", JOptionPane.ERROR_MESSAGE);
			}
			resumeEmulation(false);
		}

		private void loadKeyBinds() {
			DataInputStream distream=null;
			try {
				String path=FHandler.EnsureExists(""); //ensure JGBE Config dir exists
				FileInputStream fistream = new FileInputStream(path+"keys.conf");
				distream = new DataInputStream(fistream);
				for(int i=0; i<16+nrOfShortCuts; ++i) {
						keyMap[i] = distream.readInt();
				}
			}
			catch(IOException e) { //File not found or error reading it
				pauseEmulation(false);
				JOptionPane.showMessageDialog(frame,
					"Keys need to be configured",
					"Warning",
					JOptionPane.WARNING_MESSAGE);
				generateDefaultKeyBinds();
				keyConfigDialog k=new keyConfigDialog(frame,keyMap);
				k.getKeyCodes();
				saveKeyBinds();
				resumeEmulation(false);
			}
			finally {
				try {
					applyAccelerators();
					distream.close();
				}
				catch(Exception e) {
				}
			}
		}

		private void generateDefaultKeyBinds() {
			//Magix
			keyMap[0]=38; // Up
			keyMap[1]=40; // Down
			keyMap[2]=37; // Left
			keyMap[3]=39; // Right
			keyMap[4]=90; // Z
			keyMap[5]=88; // X
			keyMap[6]=61; // Equals
			keyMap[7]=45; // Minus
			keyMap[8]=73; // I
			keyMap[9]=75; // K
			keyMap[10]=74; // J
			keyMap[11]=76; // L
			keyMap[12]=91; // Open Bracket
			keyMap[13]=93; // Close Bracket
			keyMap[14]=222; // Quote
			keyMap[15]=59; // Semicolon
			keyMap[16]=556; // Ctrl+Comma
			keyMap[17]=591; // Ctrl+O
			keyMap[18]=19; // Pause
			keyMap[19]=594; // Ctrl+R
			keyMap[20]=593; // Ctrl+Q
			keyMap[21]=561; // Ctrl+1
			keyMap[22]=562; // Ctrl+2
			keyMap[23]=563; // Ctrl+3
			keyMap[24]=564; // Ctrl+4
			keyMap[25]=605; // Ctrl+Close Bracket
			keyMap[26]=603; // Ctrl+Open Bracket
			keyMap[27]=560; // Ctrl+0
			keyMap[28]=569; // Ctrl+9
			keyMap[29]=568; // Ctrl+8
			keyMap[30]=567; // Ctrl+7
			keyMap[31]=595; // Ctrl+S
			keyMap[32]=588; // Ctrl+L
			keyMap[33]=577; // Ctrl+A
			keyMap[34]=2097; // Alt+1
			keyMap[35]=2098; // Alt+2
			keyMap[36]=2099; // Alt+3
			keyMap[37]=2100; // Alt+4
			keyMap[38]=704; // Ctrl+Back Quote
			keyMap[39]=604; // Ctrl+Back Slash
			keyMap[40]=829; // Ctrl+Shift+Equals
			keyMap[41]=557; // Ctrl+Minus
			keyMap[42]=861; // Ctrl+Shift+Close Bracket
			keyMap[43]=859; // Ctrl+Shift+Open Bracket
			keyMap[44]=573; // Ctrl+Equals
		}

		static Cartridge cart = null;

		public void init() {
			JLabel label = new JLabel("The emulator will be opened in a new window.");
			getContentPane().add(label);
		}

		public static void starter(swinggui gui, String[] args) {
			gui.loadRCFiles();
			boolean sound=true, debug=false, lastcart=false;
			String romfile="", logfile="";
			for (int i = 0; i < args.length; ++i) {
				if (args[i].charAt(0)!='-')
					romfile = args[i];
				if (args[i].equals("-log"))
					logfile = args[++i];
				if (args[i].equals("-nosound"))
					sound = false;
				if (args[i].equals("-sound"))
					sound = true;
				if (args[i].equals("-debug"))
					debug = true;
				if ((args[i].equals("-lastcart"))) //TODO: FIXME: Invert this (current behavious is a work-around)
					lastcart=true;
			}
			if(lastcart && (gui.rcFiles.size() > 0))
				romfile = (String)gui.rcFiles.get(0);

			gui.cpu = new CPU();
			gui.VC = gui.cpu.VC;
			gui.cs = new ColorSelector( gui );
			gui.createAndShowGUI();
			if (!romfile.equals(""))
				gui.tryToLoadROM(romfile);
			if(cheatcodes==null) cheatcodes = new CheatCodeEditor(frame, curcartname);
			if (gui.menuitemUseBIOS.getState() && cart != null) cart.loadBios(biosfilename);
			gui.loadKeyBinds();
			
			cheatcodes.applyCheatCodes(cart);
			
			gui.loadConfig();
			
			gui.cpu.VC.addListener(gui.grfx);
			if (!sound)
				gui.cpu.AC.isMuted = true;

			Timer timer = new Timer(1000, gui);
			timer.setInitialDelay(1000);
			timer.start();

			if (cart != null)
				gui.cpu.loadCartridge(cart);

			gui.makeRcFilesMenuItems();

			//DEBUGGER
			if (debug) {
				Debugger dbgr = new Debugger(gui, logfile); //The GUI to which this debugger belongs
				gui.cpuRunner = dbgr.runner;
			}
			else {
				gui.cpuRunner = new SimpleCPURunner();
				gui.resumeEmulation(false);
			}
		}

		public void start() {
			try {
				isApplet = true;
				final swinggui gui=this;
				String[] args = getParameter("params").split(" ");

				starter(gui, args);
			} catch (Exception e) {
				// prevent browser crash on unchecked exception
			}
		}

		public static void main(String[] args) {
			final swinggui gui=new swinggui();
			starter(gui, args);
		}

		public void windowActivated(WindowEvent e) {}
		public void windowClosing(WindowEvent e) {
			windowClosed(e);
		}
		public void windowDeactivated(WindowEvent e) {}
		public void windowDeiconified(WindowEvent e) {}
		public void windowIconified(WindowEvent e) {}
		public void windowOpened(WindowEvent e) {}
		public void windowClosed(WindowEvent e) {
			if (isApplet) {
				try {
					getAppletContext().showDocument(new URL("http://code.google.com/p/jgbe/"));
				} catch ( MalformedURLException ex) {
					//ex.printstacktrace();
				}
			} else {
				System.exit(0);
			}
		}

	}
#endif
