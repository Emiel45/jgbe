#include "Global.inc"
#ifdef USE_JAVA_MOBILE
//TODO: Fix package name
//package gpl.emulation.jgbe;
import javax.microedition.lcdui.*;
import javax.microedition.midlet.*;
import javax.microedition.lcdui.game.GameCanvas;
import com.samsung.util.AudioClip;
import java.util.*;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.DataInputStream;
import javax.microedition.rms.RecordStore;

public class jmgbe extends MIDlet {
	jmgbeCanvas gCanvas;

	public jmgbe() {
		gCanvas = new jmgbeCanvas(this);
	}

	public void startApp() {
		Display display = Display.getDisplay(this);
/*		
		Form form = new Form("Hello World");
		display = Display.getDisplay(this);
		display.setCurrent(form);
		form.append("Hello world");
		try {
			form.append("1\n");
			AudioClip clip = new AudioClip();
			form.append("2\n");
			Thread.sleep(3000);
			form.append("3\n");
			clip = new AudioClip(2, "q.wav");
			form.append("4\n");
			Thread.sleep(3000);
			form.append("5\n");
			//clip.play(0, 10);
			//Thread.sleep(10000);
		} catch (Throwable e) {
			form.append(e.getMessage());
		}
*/		

		display.setCurrent(gCanvas);
		//gCanvas.run();
	}

	public void pauseApp() {
	}

	public void destroyApp(boolean unconditional) {
	}
}

class jmgbeCanvas extends Canvas implements Runnable, IVideoListener {
	private static final int SLEEP_INCREMENT = 10;
	private static final int SLEEP_INITIAL = 150;
	private static final int SLEEP_MAX = 300;

	private Graphics        graphics;
	private Random          random;
	private int             sleepTime = SLEEP_INITIAL;
	private CPU cpu;
	private Cartridge cartridge;
	private int w, h;
	
	private Thread thread;

	private jmgbe parent;
	
	public void listAll(IVFSNode n, Vector v) {
			PRINTLN(".");

		Enumeration e = n.getChildren();
		if (e != null) {
			while (e.hasMoreElements()) {
				listAll((IVFSNode)e.nextElement(), v);
			}
		} else {
			v.addElement(n);
		}
	};
	
	public jmgbeCanvas(jmgbe p){
		try {
			//RecordStore rs = RecordStore.openRecordStore("jmgbe", true, RecordStore.AUTHMODE_ANY, true);
			RecordStore rs = RecordStore.openRecordStore("jmgbe-store-data", "Da Fox && HackyKid && Satan", "JMGBE-Store");
			PRINTLN("rs size:" + rs.getSize());
			PRINTLN("rs size:" + rs.getSizeAvailable());
			//mstr = "rs avail:" + rs.getSizeAvailable();
			String ri = "";
			try {
				ri = new String(rs.getRecord(2));
			} catch (Throwable e) {	};
			if (ri.length() == 0) {
				PRINTLN("rs get:" + ri);
				ri += ":test:";
				//rs.setRecord(1, ri.getBytes(), 0, ri.length());
				int rid= -1;
				rid = rs.addRecord(ri.getBytes(), 0, ri.length());
				PRINTLN("set:"+ rid);
				mstr = "set:"+rid;
			} else {
				mstr = "get:"+ri;
			}
		} catch (Throwable e) {
			PRINTLN("e:" + e.toString());
			mstr = "e:" + e.getMessage();
		}
		
		IVFSNode root = VFSRoot.getRoot();
		Vector carts = new Vector();
		listAll(root, carts);
		
		PRINTLN("carts: " + carts.size());
		
		//super( true );
		parent = p;
		setFullScreenMode(true);
		PRINTFREEMEM("pre cartridge");
		cartridge = new Cartridge(((IVFSNode)carts.elementAt(0)).getInputStream());
		System.gc();
		PRINTFREEMEM("pre CPU");
		cpu = new CPU();
		PRINTFREEMEM("pre CPU");
		cpu.VC.addListener(this);
		cpu.loadCartridge(cartridge);

	}
	
	int fctr = 0;

	// When the game canvas is hidden, stop the thread.
	public void newVideoImage() {
		repaint();
	}
	
	protected void paint(Graphics graphics) {
		for (int t = 0; t < 3; ++t)
			try {
			/*
				int[] imgarr = new int[w*(h-40)];

				for (int i = 0; i < imgarr.length; ++i)
					imgarr[i] = (i) * 0x010101;//Math.abs( random.nextInt() ) & 0xffffff;

				graphics.setColor( 0,  0, 0 );
				graphics.fillRect( 0, 0, w, 43 );
				graphics.setColor( 255, 255, 255 );
				graphics.drawString("i: " + CPU.TotalInstrCount, 0, 0, Graphics.TOP|Graphics.LEFT);
				graphics.drawString("c: " + CPU.TotalCycleCount, 0, 10, Graphics.TOP|Graphics.LEFT);
				graphics.drawString("f: " + fctr++, 0, 20, Graphics.TOP|Graphics.LEFT);
				*/
				graphics.drawImage(Image.createRGBImage(cpu.VC.blitImg, 128, 160, false),0,0, Graphics.TOP | Graphics.LEFT);
				//synchronized(mstr) {
					//graphics.setColor( 0,  0, 0 );
					//graphics.fillRect( 0, 0, w, 43 );
					graphics.setColor( 255, 255, 255 );
					graphics.drawString(mstr, 0, 0, Graphics.TOP|Graphics.LEFT);
					graphics.drawString("f: " + fctr++, 0, 10, Graphics.TOP|Graphics.LEFT);
					//graphics.drawString("State:"+getKeyStates(), 0, 10, Graphics.TOP|Graphics.LEFT);
				//}
				t = 10;
			} catch (Throwable e) {
				System.gc();
			}
		//flushGraphics();
		System.gc();
		Thread.yield();
		PRINTFREEMEM("post frame");
	}
	
	int getKeyMask(int code) {
		int ret = 0;
		if (code == 48) done = true;
		int act = getGameAction(code);
		     if (act == UP)        ret = 1<<0;
		else if (act == DOWN)      ret = 1<<1;
		else if (act == LEFT)      ret = 1<<2;
		else if (act == RIGHT)     ret = 1<<3;
		else if (act == GAME_A)    ret = 1<<4;
		else if (act == GAME_B)    ret = 1<<5;
		else if (act == GAME_C)    ret = 1<<6;
		else if (act == GAME_D)    ret = 1<<7;
		else if (code == KEY_NUM7) ret = 1<<4; 
		else if (code == KEY_NUM0) ret = 1<<5; 
		else if (code == KEY_NUM1) ret = 1<<6; 
		else if (code == KEY_NUM3) ret = 1<<7; 
		else if (code == KEY_NUM2) ret = 1<<0; 
		else if (code == KEY_NUM5) ret = 1<<1; 
		else if (code == KEY_NUM4) ret = 1<<2; 
		else if (code == KEY_NUM6) ret = 1<<3; 
		else if (code == KEY_NUM8) ret = 1<<7; 

		PRINTLN("key="+ret);
		return (ret);
	}
	
	String mstr = "";
	
	protected void keyPressed(int keyCode) {
		//synchronized(mstr) {
			mstr = "keydown: " + keyCode + " (" + getKeyMask(keyCode) + ")";
		//}
		cpu.pressButton(getKeyMask(keyCode));
	}
	
	protected void keyReleased(int keyCode) {
		cpu.releaseButton(getKeyMask(keyCode));
		//synchronized(mstr) {
			mstr = "keyup: " + keyCode + " (" + getKeyMask(keyCode) + ")";
		//}
	}

	protected void hideNotify(){
	}

	// The game loop.
	boolean done;
	public void run(){
		try {
			w = getWidth();
			h = getHeight() - 1;

			w = 128;
			h = 159;

			PRINTFREEMEM("pre gc");
			System.gc();
			PRINTFREEMEM("pre new (" + w + "," + h + "," + w*(h-40) + ")");
			PRINTFREEMEM("post new");
			System.gc();
			PRINTFREEMEM("post gc");

			int fctr = 0;
			
			done = false;
			while (!done) {
				try {
					//newVideoImage();
					CPU.nextinstruction();
				} catch (Throwable e) {
					System.out.println(e.getMessage());
					e.printStackTrace();
					PRINTFREEMEM("pre gc");
					System.gc();
					PRINTFREEMEM("post gc");
				}
			};
			parent.notifyDestroyed();
			/*
			while(true) {
				// Increment or decrement the scrolling interval
				// based on key presses

				int state = getKeyStates();

				if( ( state & DOWN_PRESSED ) != 0 ){
					sleepTime += SLEEP_INCREMENT;
					if( sleepTime > SLEEP_MAX ) 
						sleepTime = SLEEP_MAX;
				} else if( ( state & UP_PRESSED ) != 0 ){
					sleepTime -= SLEEP_INCREMENT;
					if( sleepTime < 0 ) sleepTime = 0;
				}

				// Repaint the screen by first scrolling the
				// existing starfield down one and painting in
				// new stars...
				graphics.copyArea( 0, 42, w, h-43, 0, 43, Graphics.TOP | Graphics.LEFT );
				graphics.setColor( 0,  0, 0 );
				graphics.fillRect( 0, 0, w, 43 );
				graphics.setColor( 255, 255, 255 );
				graphics.drawString("w: " + w, 0,  0, Graphics.TOP|Graphics.LEFT);
				graphics.drawString("h: " + h, 0, 10, Graphics.TOP|Graphics.LEFT);
				graphics.drawString("f: " + fctr++, 0, 20, Graphics.TOP|Graphics.LEFT);

				for (int i = 0; i < imgarr.length; ++i)
					imgarr[i] = (i+fctr) * 0x010101;//Math.abs( random.nextInt() ) & 0xffffff;
				//graphics.drawImage(img, 0,40, Graphics.TOP | Graphics.LEFT);

				try {
					//PRINTFREEMEM("pre blit");
					graphics.drawImage(Image.createRGBImage(imgarr, w, h-40, false),0,40, Graphics.TOP | Graphics.LEFT);
					//PRINTFREEMEM("post blit");
				} catch (Throwable e) {
					System.gc();
					graphics.drawImage(Image.createRGBImage(imgarr, w, h-40, false),0,40, Graphics.TOP | Graphics.LEFT);
				}

				flushGraphics();

				// Now wait...
				try {
					//Thread.sleep(sleepTime);
				} catch(Throwable e) {
				}
			}
				*/
		} catch (Throwable e) {
			System.out.println(e.getMessage());
			e.printStackTrace();
		}
	}

	// When the canvas is shown, start a thread to
	// run the game loop.

	protected void showNotify(){
		random = new Random();

		thread = new Thread( this );
		thread.start();
	}
}
#else
	public class jmgbe {} //DUMMY FOR JAVA 1.5
#endif
