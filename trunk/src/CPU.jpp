//Yoshi no tamago: $293 call crashes
#include "Global.inc"
#include "SaveLoad.inc"
#include "CPU.inc"

#define protected public
#define private public

import java.io.*;
import java.util.zip.*;
public class CPU
{
		static private CPU singleton = null;
		protected static final int CARRY8b    = 512;
		protected static final int CARRY8b_SHR = 5;

		//FLAGS
		protected static final int ZF_Shift = 7;
		protected static final int NF_Shift = ZF_Shift - 1;
		protected static final int HC_Shift = NF_Shift - 1;
		protected static final int CF_Shift = HC_Shift - 1;
		protected static final int ZF_Mask  = 1 << ZF_Shift;
		protected static final int NF_Mask  = 1 << NF_Shift;
		protected static final int HC_Mask  = 1 << HC_Shift;
		protected static final int CF_Mask  = 1 << CF_Shift;

		static protected int TotalInstrCount = 0;
		static protected int TotalCycleCount = 0;

		protected static int B = 1;
		protected static int C = 2;
		protected static int D = 3;
		protected static int E = 4;
		protected static int F = 5;
		protected static int H = 6;
		protected static int L = 7;
		protected static int A = 0;

		static protected int[] IOP = new int[0x80]; //IO Ports
		static protected int[] HRAM = new int[0x7F]; //HighRAM
		static protected int[][] WRAM = new int[0x08][0x1000]; //8x4k InternalRAM
		static protected int CurrentWRAMBank=1;

		static protected boolean doublespeed = false;
		static private boolean speedswitch = false;

		static private int DIVcntdwn = 0;
		static private int TIMAcntdwn = 0;
		static private int VBLANKcntdwn = 0;

		public    static int PC=0;         ///< Program counter
		protected static int SP=0;         ///< Stack Pointer
		protected static int IE=0;         ///< Interrupt Enable (allowed interrupts)
		protected static boolean IME=true; ///< Interrupt Master Enable
		protected static boolean halted=false;
		protected static int hw_ilines=0;  ///< gnuboy magix
		//IO
 		static public int KeyStatus=0; //bitmask, low 4=direction, upper 4=start,select,a,b, inverted from GameBoy POV
		private static int keyBounce=0;
		private static int keyBounceWaitNext=0x3f;

		static boolean BIOS_enabled = false;

		//CPU Class variables
		static private Cartridge cartridge;// = new Cartridge("Pokemon Blue.gb");
		static private int lastException=0;
		#ifndef USE_JAVA_MOBILE
			static private Disassembler deasm;
		#endif
		static protected VideoController VC;
		static protected AudioController AC;
		static int hblank_dma_state;
		static int vcmode;
		//Debug helpers
		protected static int last_memory_access=-1;
		protected static int last_memory_access_internal=-1;

		public CPU() {
			if (singleton != null) {
				System.out.println("FATAL: trying to instantiate second instance of CPU singleton class");
				int x[]=null;
				x[0] = 0;
			}
			singleton = this;
			#ifndef USE_JAVA_MOBILE
				deasm = new Disassembler(this);
			#endif
			VC = new VideoController(this, 160, 144);
			AC = new AudioController(this);
			cartridge = null;
			//CPU.rccache[0x2cbb] = CPURecompiler.Recompile(0x2cbb);
		}

		public static final void loadCartridge(Cartridge acartridge) {
			cartridge = acartridge;
			reset();
		}

		public static boolean canRun() {
			return (cartridge != null);
		}

		static SAVELOAD_FUNCTION {
			SL_IF_VERSION( 1, -1) {
				SL_UINT8(B);
				SL_UINT8(C);
				SL_UINT8(D);
				SL_UINT8(E);
			}
			SL_UINT8(H);
			SL_UINT8(L);
			SL_UINT8(F);
			SL_UINT8(A);
			SL_ARR(UINT8, IOP, 0x80);
			SL_ARR(UINT8, HRAM, 0x7f);
			SL_IF_VERSION( 0,  0) {
				for (int i = 0; i < 8; ++i) {
					SL_ARR(UINT8, WRAM[i], 0x1000);
					//SL_SKIP(UINT8, 0x10000 - 0x1000);
				}
			}
			SL_IF_VERSION( 1, -1) SL_ARR_2D(UINT8, WRAM, 0x08, 0x1000);
			SL_INT(CurrentWRAMBank);
			SL_BOOL(doublespeed);
			SL_BOOL(speedswitch);
			SL_INT(DIVcntdwn);
			SL_INT(TIMAcntdwn);
			SL_INT(VBLANKcntdwn);
			SL_UINT16(PC);
			SL_UINT16(SP);
			SL_UINT8(IE);
			SL_BOOL(IME);
			SL_BOOL(halted);
			SL_IF_VERSION( 0,  2) SL_SKIP(UINT8, 1); //SL_UINT8(DirectionKeyStatus);
			SL_IF_VERSION( 0,  2) SL_SKIP(UINT8, 1); //SL_UINT8(ButtonKeyStatus);
			SL_INT(lastException);
			SL_BOOL(BIOS_enabled);

			SL_OBJ(cartridge);
			SL_OBJ(VC);
			SL_IF_VERSION( 2, -1) SL_OBJ(AC);

			SL_IF_VERSION( 3, -1) SL_UINT8(vcmode);
			SL_IF_VERSION( 3, -1) SL_INT(TotalInstrCount);
			SL_IF_VERSION( 3, -1) SL_INT(TotalCycleCount);

			SL_IF_VERSION( 4, -1) SL_UINT8(hw_ilines);

			SL_IF_VERSION( 7, -1) SL_UINT8(hblank_dma_state);

			if (SL_LOAD) {
				refreshMemMap();
			}
		}

		public static final void saveState(DataOutputStream dostream)
		throws IOException
		{
			int saveversion = SL_SAVE_VERSION; //change when changing savestate format
			dostream.writeInt(SL_MAGIX);
			dostream.writeInt(saveversion);
			int compressionmethod = 1; // GZIP compression
			dostream.writeInt(compressionmethod);
			DeflaterOutputStream zostream = null;
			switch (compressionmethod) {
				// no compression
				case 0: break;
				// GZIP compression
				case 1: {
					zostream = new GZIPOutputStream(dostream);
					dostream = new DataOutputStream(zostream);
				}; break;
			}
			stateSaveLoad(true, saveversion, dostream, null);
			if (zostream != null) {
				dostream.flush();
				zostream.finish();
			}
		}

		public static final void loadState(DataInputStream distream)
		throws IOException
		{
			int loadversion;
			int magix = distream.readInt();
			if (magix != SL_MAGIX) {
				// throw new IOException("save state not valid");
				// hax! 1 in 0xffffffff chance this goes wrong!
				loadversion = 0;
				B = (magix >> 24) & 0xff;
				C = (magix >> 16) & 0xff;
				D = (magix >>  8) & 0xff;
				E = (magix >>  0) & 0xff;
			}
			else
				loadversion = distream.readInt();
			if (loadversion < SL_LOAD_MIN_VERSION)
				throw new IOException("save state too old");
			if (loadversion > SL_LOAD_MAX_VERSION)
				throw new IOException("save state too new");
			if (loadversion != SL_SAVE_VERSION)
				System.out.println("loading state with old version:"+loadversion);

			int compressionmethod = 0;
			if (loadversion >= SL_LOAD_COMPRESS_VERSION)
				compressionmethod = distream.readInt();
			switch (compressionmethod) {
				// no compression
				case 0: break;
				// GZIP compression
				case 1: distream = new DataInputStream(new GZIPInputStream(distream)); break;
			}
			stateSaveLoad(false, loadversion, null, distream);
		}

		static private int[][] rMemMap = new int[0x10][];
		static private int[][] wMemMap = new int[0x10][];

		static public boolean isCGB() {
			//System.out.println("** <INSERT DESCRIPTIVE TEXT HERE> ** [0x0143] = " + read(0x0143));
			return (read(0x0143) == 0x80) || (read(0x0143) == 0xC0);
		}

/*

CA12==0 --> Error!
happens at 0b06
check for badness = $afa



*/


		static private int hblank_dma() {
			if (hblank_dma_state < (1<<7)) return 0;

			int src = ((IOP[0x51]<<8)|IOP[0x52]) & 0xfff0;
			int dst = (((IOP[0x53]<<8)|IOP[0x54]) & 0x1ff0) | 0x8000;
			int len = 16;

			for (int i = 0; i < len; ++i)
				VC.write(dst++, read(src++));

			IOP[0x51] = src >> 8;
			IOP[0x52] = src & 0xF0;
			IOP[0x53] = 0x1F & (dst >> 8);
			IOP[0x54] = dst & 0xF0;
			--IOP[0x55];
			--hblank_dma_state;

			return 0;
		}

#define C VBLANKcntdwn
#define R_LCDC VC.LCDC
#define R_STAT VC.STAT
#define R_LY VC.LY
		static final  private void lcdc_trans() {
			if (0==(R_LCDC & 0x80))
			{
				ASSERT(C <= 0);
				switch (R_STAT & 3)
				{
				case 0:
				case 1:
					VC.stat_change(2);
					C += 40;
					break;
				case 2:
					VC.stat_change(3);
					C += 86;
					break;
				case 3:
					VC.stat_change(0);
					C += 102 - hblank_dma();
					break;
				}
				return;
			}
			ASSERT(C <= 0);
			while (C <= 0)
			{
				switch ((R_STAT & 3))
				{
				case 1:
					if (0==(hw_ilines & IF_VBLANK))
					{
						C += 218;
						hw_interrupt(IF_VBLANK, IF_VBLANK);
						break;
					}
					if (R_LY == 0)
					{
						//lcd_begin();
						VC.stat_change(2);
						C += 40;
						break;
					}
					else if (R_LY < 152)
						C += 228;
					else if (R_LY == 152)
						C += 28;
					else
					{
						R_LY = -1;
						C += 200;
					}
					++R_LY;
					VC.stat_trigger();
					break;
				case 2:
					if (R_LY < 144)
						VC.renderScanLine();
					VC.stat_change(3);
					C += 86;
					break;
				case 3:
					VC.stat_change(0);
					C += 102 - hblank_dma();
					break;
				case 0:
					if (++R_LY >= 144)
					{
						if (halted)
						{
							hw_interrupt(IF_VBLANK, IF_VBLANK);
							C += 228;
						}
						else C += 10;
						VC.stat_change(1);
						break;
					}
					VC.stat_change(2);
					C += 40;
					break;
				}
				//ASSERT(C > 0);
			}
		}
#undef C
		static final private void refreshMemMap() {
			if (BIOS_enabled)
				rMemMap[0x0] = null;
			else
				rMemMap[0x0] = cartridge.MM_ROM[0];
			// cartridge ROM bank 0 (read only, write has special functions)
			rMemMap[0x1] = cartridge.MM_ROM[1];
			rMemMap[0x2] = cartridge.MM_ROM[2];
			rMemMap[0x3] = cartridge.MM_ROM[3];

			// cartridge ROM switchable bank (read only, write has special functions)
			rMemMap[0x4] = cartridge.MM_ROM[(cartridge.CurrentROMBank<<2)|0];
			rMemMap[0x5] = cartridge.MM_ROM[(cartridge.CurrentROMBank<<2)|1];
			rMemMap[0x6] = cartridge.MM_ROM[(cartridge.CurrentROMBank<<2)|2];
			rMemMap[0x7] = cartridge.MM_ROM[(cartridge.CurrentROMBank<<2)|3];

			// 0x8 // TODO: somehow fit VRAM in here, difficult cause its
			// 0x9 //       not in 0xFFF chunks (and VC doesnt want it that way)

			// cartridge RAM (can be switchable)
			rMemMap[0xA] = wMemMap[0xA] = cartridge.MM_RAM[(cartridge.CurrentRAMBank<<1)|0];
			rMemMap[0xB] = wMemMap[0xB] = cartridge.MM_RAM[(cartridge.CurrentRAMBank<<1)|1];

			// WRAM, bank 0 and a switchable bank
			rMemMap[0xC] = wMemMap[0xC] = WRAM[0];
			rMemMap[0xD] = wMemMap[0xD] = WRAM[CurrentWRAMBank];

			// echo..
			rMemMap[0xE] = wMemMap[0xE] = rMemMap[0xC];

			// 0xF // lots of special stuff here...
		}

		static final protected int read(int index) {
			last_memory_access_internal=index;
			int mm[]=rMemMap[index>>12];
			if (mm!=null)
				return mm[index&0x0FFF];
			return read_slow(index);
		}

static int togglestart=1;
		static final private int read_slow(int index) {
			/* Memorymap:
			 * 0000-3FFF   16KB ROM Bank 00     (in cartridge, fixed at bank 00)
			 * 4000-7FFF   16KB ROM Bank 01..NN (in cartridge, switchable bank number)
			 * 8000-9FFF   8KB Video RAM (VRAM) (switchable bank 0-1 in CGB Mode)
			 * A000-BFFF   8KB External RAM     (in cartridge, switchable bank, if any)
			 * C000-CFFF   4KB Work RAM Bank 0 (WRAM)
			 * D000-DFFF   4KB Work RAM Bank 1 (WRAM)  (switchable bank 1-7 in CGB Mode)
			 * E000-FDFF   Same as C000-DDFF (ECHO)    (typically not used)
			 * FE00-FE9F   Sprite Attribute Table (OAM)
			 * FEA0-FEFF   Not Usable
			 * FF00-FF7F   I/O Ports
			 * FF80-FFFE   High RAM (HRAM)
			 * FFFF        Interrupt Enable Register
			 */

			int b;
			last_memory_access_internal=index;
// 			System.out.println("ERROR: not using memmap "+ index);
			if(index<0) { //Invalid
				System.out.println("ERROR: CPU.read(): No negative addresses in GameBoy memorymap.");
				b=-1;
			}
			else if(index < 0x4000) { //16KB ROM Bank 00     (in cartridge, fixed at bank 00)
				if (index < 0x100) {
					b = cartridge.BIOS_ROM[index];
				    //System.out.println("reading from BIOS rom");
				}
				else if (index == 0x100) {
					System.out.println("reading from 0x100, disableing BIOS rom (PC="+PC+")");
					reset(false); // reset without forcing mono mode
					b = read(index);
				}
				else {
					b = cartridge.MM_ROM[0][index];
				  //System.out.println("reading from non-BIOS rom");
				}
			}
			else if(index < 0x8000) { //16KB ROM Bank 01..NN (in cartridge, switchable bank number)
				b=cartridge.read(index);
			}
			else if(index < 0xa000) { //8KB Video RAM (VRAM) (switchable bank 0-1 in CGB Mode)
				b=VC.read(index);
			}
			else if(index < 0xc000) { //8KB External RAM     (in cartridge, switchable bank, if any)
				b=cartridge.read(index);
			}
			else if(index < 0xd000) { //4KB Work RAM Bank 0 (WRAM)
				b=WRAM[0][index-0xc000];
			}
			else if(index < 0xe000) { //4KB Work RAM Bank 1 (WRAM)  (switchable bank 1-7 in CGB Mode)
				b=WRAM[CurrentWRAMBank][index-0xd000];
			}
			else if(index < 0xfe00) { //Same as C000-DDFF (ECHO)    (typically not used)
				b=read(index-0x2000);
			}
			else if(index < 0xfea0) { //Sprite Attribute Table (OAM)
				b=VC.read(index);
			}
			else if(index < 0xff00) { //Not Usable
				System.out.println("WARNING: CPU.read(): Read from unusable memory (0xfea0-0xfeff)");
				b=0;
			}
			else if(index < 0xff80) { //I/O Ports
				switch(index) {
					case 0xff00: // FF00 - P1/JOYP - Joypad (R/W)
						//PRINTF("DEBUG: CPU.read(): YOYP (PC=0x%04x)\n", PC);
// 						if(togglestart--==0){
// 							ButtonKeyStatus ^= 8;
// 							togglestart=10;
// // 							System.out.println("ButtonKeyStatus="+ButtonKeyStatus);
// 						}

						b=(IOP[index-0xff00]&0x30)|0xc0;
						if((b&(1<<4))==0) { // Direction keys, 0=select
							b|=(KeyStatus&0x0f);
						}
						if((b&(1<<5))==0) { // Buttons, 0=select
							b|=(KeyStatus>>4);
						}
						b^=0x0f;
						break;
					case 0xff01: // SB - Serial transfer data (R/W)
					case 0xff02: // SC - Serial Transfer Control (R/W)
						//yes fallthrough works here
					//case 0xff03 ! dont break above ports
					case 0xff04: // DIV
					case 0xff05: // TIMA
					case 0xff06: // TMA
					case 0xff07: // TAC
						b = IOP[index-0xff00];
						break;
					case 0xff0f: // FF0F - IF - Interrupt Flag (R/W)
						b = IOP[0x0f];
						break;
					/* AUDIO IO PORTS */
					case 0xff10: case 0xff11: case 0xff12: case 0xff13: case 0xff14: case 0xff15: case 0xff16: case 0xff17:
					case 0xff18: case 0xff19: case 0xff1a: case 0xff1b: case 0xff1c: case 0xff1d: case 0xff1e: case 0xff1f:
					case 0xff20: case 0xff21: case 0xff22: case 0xff23: case 0xff24: case 0xff25: case 0xff26: case 0xff27:
					case 0xff28: case 0xff29: case 0xff2a: case 0xff2b: case 0xff2c: case 0xff2d: case 0xff2e: case 0xff2f:
					case 0xff30: case 0xff31: case 0xff32: case 0xff33: case 0xff34: case 0xff35: case 0xff36: case 0xff37:
					case 0xff38: case 0xff39: case 0xff3a: case 0xff3b: case 0xff3c: case 0xff3d: case 0xff3e: case 0xff3f:
						b = AC.read(index);
						break;
					case 0xff40: // LCDC register
						b = VC.LCDC;
						break;
					case 0xff41: // FF41 - STAT - LCDC Status (R/W)
						b = VC.STAT;
						break;
					case 0xff42: // SCY
						b = VC.SCY;
						break;
					case 0xff43: // SCX
						b = VC.SCX;
						break;
					case 0xff44: // LY
						b = VC.LY;
						break;
					case 0xff45: // LYC
						b = VC.LYC;
						break;
					case 0xff47: // BGP - BG Palette Data (R/W) - Non CGB Mode Only
					case 0xff48: // OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only
					case 0xff49: // OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only
						b = IOP[index-0xff00];
						break;
					case 0xff4a: // WY
						b = VC.WY;
						break;
					case 0xff4b: // WX
						b = VC.WX;
						break;
					case 0xff4d: // KEY1 - CGB Mode Only - Prepare Speed Switch
						b = doublespeed ? (1<<7) : 0;
						break;
					case 0xff4f: // VRAM bank nr
						b = VC.getcurVRAMBank();
						break;
					case 0xff51: // FF51 - HDMA1 - CGB Mode Only - New DMA Source, High
					case 0xff52: // FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low
					case 0xff53: // FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High
					case 0xff54: // FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low
					case 0xff55: // FF55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start
						b = IOP[index-0xff00];
						break;
					case 0xff68: // BGPI
						b = VC.BGPI;
						break;
					case 0xff69: // BGPD
						b = VC.getBGColData();
						break;
					case 0xff6a: // OBPI
						b = VC.OBPI;
						break;
					case 0xff6b: // OBPD
						b = VC.getOBColData();
						break;
					case 0xff70: // SVBK - CGB Mode Only - WRAM Bank
						b = CurrentWRAMBank;
						break;
					/** some 'undocemented' stuff... */
					case 0xff6c: // Undocumented (FEh) - bit 0 (Read/Write)
						PRINTF("WARNING: CPU.read(): Read from *undocumented* IO port $%04x\n",index);
						b = IOP[index-0xff00] | 0xfe;
						break;
					case 0xff72: // Undocumented (00h) - Bit 0-7 (Read/Write)
					case 0xff73: // Undocumented (00h) - Bit 0-7 (Read/Write)
					case 0xff74: // Undocumented (00h) - Bit 0-7 (Read/Write)
						b = IOP[index-0xff00];
						break;
					case 0xff75: // Undocumented (8Fh) - Bit 4-6 (Read/Write)
						PRINTF("WARNING: CPU.read(): Read from *undocumented* IO port $%04x\n",index);
						b = IOP[index-0xff00] | 0x8f;
						break;
					case 0xff76: // Undocumented (00h) - Always 00h (Read Only)
					case 0xff77: // Undocumented (00h) - Always 00h (Read Only)
						PRINTF("WARNING: CPU.read(): Read from *undocumented* IO port $%04x\n",index);
						b = 0;
						break;
					default:
						PRINTF("TODO: CPU.read(): Read from IO port $%04x\n",index);
						b=0xff; // GnuBoy compat
						break;
				}
				//PRINTF("TODO: CPU.read(): IOP[$%04x] = $%04x\n",index, b);
			}
			else if(index < 0xffff) { //High RAM (HRAM)
				b = HRAM[index-0xff80];
			}
			else if(index < 0x10000) { // Interrupt Enable Register (0xffff)
				//System.out.println("TODO: CPU.read(): Read from Interrupt Enable Register (0xffff)");
				b=IE;
			}
			else {
				System.out.println("ERROR: CPU.read(): Out of range memory access: $"+index);
				b=0;
			}
			return b;
		}

		static final public void write(int index, int value) {
			/* Memorymap:
			 * 0000-3FFF   16KB ROM Bank 00     (in cartridge, fixed at bank 00)
			 * 4000-7FFF   16KB ROM Bank 01..NN (in cartridge, switchable bank number)
			 * 8000-9FFF   8KB Video RAM (VRAM) (switchable bank 0-1 in CGB Mode)
			 * A000-BFFF   8KB External RAM     (in cartridge, switchable bank, if any)
			 * C000-CFFF   4KB Work RAM Bank 0 (WRAM)
			 * D000-DFFF   4KB Work RAM Bank 1 (WRAM)  (switchable bank 1-7 in CGB Mode)
			 * E000-FDFF   Same as C000-DDFF (ECHO)    (typically not used)
			 * FE00-FE9F   Sprite Attribute Table (OAM)
			 * FEA0-FEFF   Not Usable
			 * FF00-FF7F   I/O Ports
			 * FF80-FFFE   High RAM (HRAM)
			 * FFFF        Interrupt Enable Register
			 */
			last_memory_access_internal=index;
			int mm[]=wMemMap[index>>12];
			if (mm!=null) {
				mm[index&0x0FFF] = value;
				return;
			}

			if(index<0) { //Invalid
				System.out.println("ERROR: CPU.write(): No negative addresses in GameBoy memorymap.");
			}
			else if(index < 0x8000) { //cartridge ROM
				cartridge.write(index, value);

				refreshMemMap();
			}
			else if(index < 0xa000) { //8KB Video RAM (VRAM) (switchable bank 0-1 in CGB Mode)
				VC.write(index, value);
			}
			else if(index < 0xc000) { //8KB External RAM     (in cartridge, switchable bank, if any)
				cartridge.write(index, value);
			}
			else if(index < 0xd000) { //4KB Work RAM Bank 0 (WRAM)
				WRAM[0][index-0xc000]=value;
			}
			else if(index < 0xe000) { //4KB Work RAM Bank 1 (WRAM)  (switchable bank 1-7 in CGB Mode)
				WRAM[CurrentWRAMBank][index-0xd000]=value;
			}
			else if(index < 0xfe00) { //Same as C000-DDFF (ECHO)    (typically not used)
				write(index-0x2000, value);
			}
			else if(index < 0xfea0) { //Sprite Attribute Table (OAM)
				VC.write(index, value);
			}
			else if(index < 0xff00) { //Not Usable
				PRINTF("WARNING: CPU.write(): Write to unusable memory (0xfea0-0xfeff) index=$%04x, value=$%02x\n",index,value);
			}
			else if(index < 0xff80) { //I/O Ports
				switch(index) {
					case 0xff00: // FF00 - P1/JOYP - Joypad (R/W)
						IOP[index&0xff]=value;
						break;
					case 0xff01: // SB - Serial transfer data (R/W)
						IOP[0x01]=value;
						break;
					case 0xff02: // SC - Serial Transfer Control (R/W)
						IOP[0x02]=value;
						if ((value&(1<<7))!=0) {
							// transfer! (we do it instantly...)
							if ((value&(1<<0))!=0) {
								// internal clock, this 'works' without other GB
								IOP[0x01] = 0xFF; // 'works'
								IOP[0x02] &= ~(1<<7); // 'transfer' finished
								triggerInterrupt(3);
							}
							else {
								// external clock, nothing will happen
							}
						}
						break;
					case 0xff04: // DIV
						IOP[0x04] = 0;
						break;
					case 0xff05: // TIMA
					case 0xff06: // TMA
					case 0xff07: // TAC
						IOP[index-0xff00] = value;
						break;
					case 0xff0f: // FF0F - IF - Interrupt Flag (R/W) (*Request* interrupts, and *shows* interrupts being queed)
						IOP[0x0f] = value;
						break;
					/* AUDIO IO PORTS */
					case 0xff10: case 0xff11: case 0xff12: case 0xff13: case 0xff14: case 0xff15: case 0xff16: case 0xff17:
					case 0xff18: case 0xff19: case 0xff1a: case 0xff1b: case 0xff1c: case 0xff1d: case 0xff1e: case 0xff1f:
					case 0xff20: case 0xff21: case 0xff22: case 0xff23: case 0xff24: case 0xff25: case 0xff26: case 0xff27:
					case 0xff28: case 0xff29: case 0xff2a: case 0xff2b: case 0xff2c: case 0xff2d: case 0xff2e: case 0xff2f:
					case 0xff30: case 0xff31: case 0xff32: case 0xff33: case 0xff34: case 0xff35: case 0xff36: case 0xff37:
					case 0xff38: case 0xff39: case 0xff3a: case 0xff3b: case 0xff3c: case 0xff3d: case 0xff3e: case 0xff3f:
						AC.write(index, value);
						break;
					case 0xff40: // LCDC register
						VC.LCDC = value;
						break;
					case 0xff41: // FF41 - STAT - LCDC Status (R/W)
						VC.STAT = (VC.STAT&7)|(value&0x78); //lower 3bits are readonly
						if (!VC.isCGB && ((VC.STAT & 2)!=0)) /* DMG STAT write bug => interrupt */
							triggerInterrupt(1);
						VC.stat_trigger();
						break;
					case 0xff42: // SCY
						VC.SCY = value;
						break;
					case 0xff43: // SCX
						VC.SCX = value;
						break;
					case 0xff44: // LY
						VC.LY = 0; // can only be set to 0
						break;
					case 0xff45: // LYC
						VC.LYC = value;
						//PRINTF("Setting LYC=%d ($%02x)\n",value,value);
						break;
					case 0xff46:{ // FF46 - DMA - DMA Transfer and Start Address (W)
// 						System.out.println("WARNING: CPU.write(): TODO: Untimed DMA Transfer");
						last_memory_access=last_memory_access_internal;
						for(int i=0; i<0xa0; ++i){ //TODO : This takes TIME and needs TIMING
							write(0xfe00|i, read(i+(value<<8)));
						}
						last_memory_access_internal=last_memory_access;
/*						VC.STAT|=2; //MODE2 or 3
						int cnt=0;
						while(cnt<160) { //Timing :D
						  cnt+=nextinstruction();
						}
						VC.STAT&=~2;*/
						} break;
					case 0xff47: // BGP - BG Palette Data (R/W) - Non CGB Mode Only
					case 0xff48: // OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only
					case 0xff49: // OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only
						IOP[index-0xff00] = value;
						VC.updateMonoColData(index-0xff47);
						break;
					case 0xff4a: // WY
						VC.WY = value;
						break;
					case 0xff4b: // WX
						VC.WX = value;
						break;
					case 0xff4d: // KEY1 - CGB Mode Only - Prepare Speed Switch
						speedswitch = ((value&1)!=0);
						break;
					case 0xff4f: // FF4F - VBK - CGB Mode Only - VRAM Bank
						VC.selectVRAMBank(value&1);
						break;
					case 0xff51: // FF51 - HDMA1 - CGB Mode Only - New DMA Source, High
					case 0xff52: // FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low
					case 0xff53: // FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High
					case 0xff54: // FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low
						IOP[index-0xff00] = value;
						break;
					case 0xff55: // FF55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start
						int mode = ((hblank_dma_state|value) & 0x80);
						if (mode == 0) {
							int src = ((IOP[0x51]<<8)|IOP[0x52]) & 0xfff0;
							int dst = (((IOP[0x53]<<8)|IOP[0x54]) & 0x1ff0) | 0x8000;
							int len = ((value & 0x7f)+1)<<4;
// 							System.out.println("WARNING: CPU.write(): TODO: Untimed H-DMA Transfer");
							// TODO: this should take more than 4-12 cycles :O
							//PRINTF("DONE: General HDMA transfer src=$%04x dst=$%04x len=$%04x\n", src, dst, len);
							for (int i = 0; i < len; ++i)
								VC.write(dst++, read(src++));
							IOP[0x51] = src >> 8;
							IOP[0x52] = src & 0xF0;
							IOP[0x53] = 0x1F & (dst >> 8);
							IOP[0x54] = dst & 0xF0;
							IOP[0x55] = 0xff; // indicate we have finished
						} else {
							hblank_dma_state = value;
							IOP[0x55] = value & 0x7f;
						}
						break;
					case 0xff68: // BGPI
						VC.BGPI = value;;
						break;
					case 0xff69: // BGPD
						VC.setBGColData(value);
						break;
					case 0xff6a: // OBPI
						VC.OBPI = value;;
						break;
					case 0xff6b: // OBPD
						VC.setOBColData(value);
						break;
					case 0xff70: //FF70 - SVBK - CGB Mode Only - WRAM Bank
						CurrentWRAMBank=MAX(value&0x07, 1);
						refreshMemMap();
						break;
					/** some 'undocemented' stuff... */
					case 0xff6c: // Undocumented (FEh) - bit 0 (Read/Write)
					case 0xff72: // Undocumented (00h) - Bit 0-7 (Read/Write)
					case 0xff73: // Undocumented (00h) - Bit 0-7 (Read/Write)
					case 0xff74: // Undocumented (00h) - Bit 0-7 (Read/Write)
					case 0xff75: // Undocumented (8Fh) - Bit 4-6 (Read/Write)
						PRINTF("WARNING: CPU.write(): Write to *undocumented* IO port $%04x\n",index);
						IOP[index-0xff00] = value;
						break;
					case 0xff76: // Undocumented (00h) - Always 00h (Read Only)
					case 0xff77: // Undocumented (00h) - Always 00h (Read Only)
						PRINTF("WARNING: CPU.write(): Write to *undocumented* IO port $%04x\n",index);
						break;
					default:
						PRINTF("TODO: CPU.write(): Write %02x to IO port $%04x\n",value, index);
						break;
				}
			}
			else if(index < 0xffff) { //High RAM (HRAM)
				HRAM[index-0xff80] = value;
			}
			else if(index < 0x10000) { // FFFF - IE - Interrupt Enable (R/W)
				IE=value; // Interrupt Enable Register
				//System.out.println("IE write: VBlank="+(IE&1)+" STAT="+((IE&2)>>1)+" Timer="+((IE&4)>>2)+" Serial="+((IE&8)>>3)+" Joypad="+((IE&16)>>4 ));
			}
			else {
				System.out.println("ERROR: CPU.write(): Out of range memory access: $"+index);
			}
		}


		static final public void reset() {
			reset(true);
		}

		static final public void reset(boolean bios) {
			BIOS_enabled = bios;
 			VC.reset();
 			cartridge.CurrentRAMBank=0;
 			cartridge.CurrentROMBank=1;
			refreshMemMap();

			PC = 0x100;

			//AF=$01B0
			A=VC.isCGB?0x11:0x01; // CGB sets this to 0x11 instead of 0x01 for GB
			F=0xb0;
			//BC=$0013
			B=0x00;
			C=0x13;
			//DE=$00D8
			D=0x00;
			E=0xd8;
			//HL=$014D
			H=0x01;
			L=0x4d;
			TotalInstrCount=0;
			TotalCycleCount=0;

			//Stack Pointer=$FFFE
			SP=0xfffe;

			write(0xff05, 0x00); // [$FF05] = $00   ; TIMA
			write(0xff06, 0x00); // [$FF06] = $00   ; TMA
			write(0xff07, 0x00); // [$FF07] = $00   ; TAC
			write(0xff26, 0xf1); // [$FF26] = $F1-GB, $F0-SGB ; NR52
			AC.sound_off(); // Sets FF11-FF25
			write(0xff47, 0xfc); // [$FF47] = $FC   ; BGP
			write(0xff48, 0xff); // [$FF48] = $FF   ; OBP0
			write(0xff49, 0xff); // [$FF49] = $FF   ; OBP1

			CurrentWRAMBank=1;
			doublespeed = false;
			speedswitch = false;
			DIVcntdwn = 0;
			TIMAcntdwn = 0;
			VBLANKcntdwn = 0;
			IE=0;         ///< Interrupt Enable (allowed interrupts)
			IME=true; ///< Interrupt Master Enable
			halted=false;
			KeyStatus=0; //bitmask
			lastException=0;
			hw_ilines = 0;
			hblank_dma_state = 0;
		}

		static final protected int cycles() {
			return TotalInstrCount;
		}

		static final protected void printCPUstatus() {
			String flags = "";
			flags += (( F & ZF_Mask ) == ZF_Mask )?"Z ":"z ";
			flags += (( F & NF_Mask ) == NF_Mask )?"N ":"n ";
			flags += (( F & HC_Mask ) == HC_Mask )?"H ":"h ";
			flags += (( F & CF_Mask ) == CF_Mask )?"C ":"c ";
			flags += (( F & ( 1 <<3 ) ) == ( 1 <<3 ) )?"1 ":"0 ";
			flags += (( F & ( 1 <<2 ) ) == ( 1 <<2 ) )?"1 ":"0 ";
			flags += (( F & ( 1 <<1 ) ) == ( 1 <<1 ) )?"1 ":"0 ";
			flags += (( F & ( 1 <<0 ) ) == ( 1 <<0 ) )?"1 ":"0 ";
			System.out.println( "---CPU Status for cycle "+TotalCycleCount+" , instruction "+TotalInstrCount+"---" );
			PRINTF( "   A=$%02x    B=$%02x    C=$%02x    D=$%02x   E=$%02x   F=$%02x   H=$%02x   L=$%02x\n", A, B, C, D, E, F, H,L );
			PRINTF( "  PC=$%04x SP=$%04x                           flags="+flags+"\n",PC,SP );
			#ifndef USE_JAVA_MOBILE
				System.out.println( "  "+deasm.simple_disasm( PC ) );
			#endif
		}

		static final protected int checkInterrupts() { //handle interrupt priorities
			if(IME) { // If interrupts enabled
				int ir = IOP[0x0f]&IE; //First Requested interrupts
				if((ir&(1<<0))!=0) { //VBlANK
					IOP[0x0f] &= ~(1<<0);
					interrupt(0x40);
					return 1;
				}
				else if ((ir&(1<<1))!=0) { //LCD STAT
					IOP[0x0f] &= ~(1<<1);
					interrupt(0x48);
					return 1;
				}
				else if ((ir&(1<<2))!=0) { //Timer
					IOP[0x0f] &= ~(1<<2);
					interrupt(0x50);
					return 1;
				}
				else if ((ir&(1<<3))!=0) { //Serial
					IOP[0x0f] &= ~(1<<3);
					interrupt(0x58);
					return 1;
				}
				else if ((ir&(1<<4))!=0) { //Joypad
					IOP[0x0f] &= ~(1<<4);
					interrupt(0x60);
					return 1;
				}
			}
			return 0; // No interrupts to service
		}

		static final protected void interrupt(int i) { //execute interrupt #i
//  			PRINTF("INTERRUPT: PC=$%04x, interrupt=$%02x, LY=%d\n",PC,i,VC.LY);
			IME = false;

			PUSH_OLD(PC);
			PC = i;
		}

		static final protected void triggerInterrupt(int i) { // request interrupt with bit nr #i
			//IOP[0x0f] |= (1<<i);
			hw_interrupt((1<<i), (1<<i));
			hw_interrupt(0, (1<<i));
		}

#define R_IF IOP[0x0f]
		static final protected void hw_interrupt(int i, int mask)
		{
			int oldif = R_IF;
			i &= 0x1F & mask;
			R_IF |= i & (hw_ilines ^ i);

			/* FIXME - is this correct? not sure the docs understand... */
			if ((0!=(R_IF & (R_IF ^ oldif) & IE)) && IME) halted = false;
			/* if ((i & (hw.ilines ^ i) & R_IE) && cpu.ime) cpu.halt = 0; */
			/* if ((i & R_IE) && cpu.ime) cpu.halt = 0; */

			hw_ilines &= ~mask;
			hw_ilines |= i;
		}

		public static final void pressButton(int i) {
			if ((KeyStatus&i) != 0) return;
			KeyStatus |= i;
			keyBounce=1000; //times to bounce the key
			//PRINTLN("PRESS "+keyBounce + " "+KeyStatus + " " + System.nanoTime());
		}

		public static final void releaseButton(int i) {
			if ((KeyStatus&i) == 0) return;
			KeyStatus&=~i;
			keyBounce=1000; //times to bounce the key
			//PRINTLN("RELEA "+keyBounce + " "+KeyStatus + " " + System.nanoTime());
		}

		static final protected int execute() {
// 			if(last_memory_access_internal==0xff00) System.out.println("ASDASDASDSADDSA");
			int cycles;
			TVARS;

			if (CHECK_INTS) {
				checkInterrupts();
				halted = false;
				//return 12; // 12 cycles for this?
 				return 4;/* FIXME(?) For break on interrupt */
			}

			if (halted) return 4;

#ifdef ENABLE_RECOMPILER
			if ((PC < 0x4000) && (rccache[PC] != null)) {
				//PRINTF("executing recompiled block starting at PC=0x%02x\n", PC);
				return rccache[PC].execute();
				//rccache[PC] = CPURecompiler.Recompile(PC);
			}
			/*if (PC < 0x4000) {
				++rccnt[PC];
				if (rccnt[PC] > 0xfff) {
					rccnt[PC] = 0;
					PRINTF("PC=0x%02x\n",PC);
				}
			}*/
#endif

			--keyBounceWaitNext;
			if(keyBounceWaitNext == 0) {//wait some instructions
				keyBounceWaitNext=1000;
				if (keyBounce > 0) {
// 					PRINTF(".keyBounce\n");
					triggerInterrupt(4);
					--keyBounce;
				}
			}
			int op = FETCH;
			cycles = Tables.cycles[op];

#define break return cycles
			switch ( op ) {
				case 0x00: break;                                   // NOP
				case 0xf3: IME=false; break;                        // DI
				case 0xfb: IME=true; break;                         // IE
				case 0xea: WRITE_V(IMM16, A); break;                // LD   (nn), A
				case 0xfa: A = READ_V(IMM16); break;                // LD   A   , (nn)
				case 0xe0: WRITE_S(IMM8 | 0xff00, A); break;        // LDH  (n) , A
				case 0xf0: A = READ_S(IMM8 | 0xff00); break;        // LDH  A   , (n)
				case 0xe2: WRITE_S(C | 0xff00, A); break;           // LDH  (C) , A
				case 0xf2: A = READ_S(C | 0xff00); break;           // LDH  A   , (C)
				case 0xf9: SP = R16RHL; break;                      // LD   SP  , HL
				case 0x22: WRITE_V(R16RHL, A); DO_INC16(HL); break; // LDI  (HL), A
				case 0x2a: A = READ_V(R16RHL); DO_INC16(HL); break; // LDI  A   , (HL)
				case 0x32: WRITE_V(R16RHL, A); DO_DEC16(HL); break; // LDD  (HL), A
				case 0x3a: A = READ_V(R16RHL); DO_DEC16(HL); break; // LDD  A   , (HL)
				case 0xc3: DO_JP_NN; break;                         // JP   (nn)
				case 0xc2: DO_JP_COND((F&FZ)==0); break;            // JP   NZ  , (nn)
				case 0xca: DO_JP_COND((F&FZ)!=0); break;            // JP   Z   , (nn)
				case 0xd2: DO_JP_COND((F&FC)==0); break;            // JP   NC  , (nn)
				case 0xda: DO_JP_COND((F&FC)!=0); break;            // JP   C   , (nn)
				case 0xcd: DO_CALL_NN; break;                       // CALL (nn)
				case 0xc4: DO_CALL_COND((F&FZ)==0); break;          // CALL NZ  , (d)
				case 0xcc: DO_CALL_COND((F&FZ)!=0); break;          // CALL Z   , (d)
				case 0xd4: DO_CALL_COND((F&FC)==0); break;          // CALL NC  , (d)
				case 0xdc: DO_CALL_COND((F&FC)!=0); break;          // CALL C   , (d)
				case 0x18: DO_JR_D; break;                          // JR   (d)
				case 0x20: DO_JR_COND((F&FZ)==0); break;            // JR   NZ  , (d)
				case 0x28: DO_JR_COND((F&FZ)!=0); break;            // JR   Z   , (d)
				case 0x30: DO_JR_COND((F&FC)==0); break;            // JR   NC  , (d)
				case 0x38: DO_JR_COND((F&FC)!=0); break;            // JR   C   , (d)
				case 0xc9: DO_RET; break;                           // RET
				case 0xc0: DO_RET_COND((F&FZ)==0); break;           // RET  NZ
				case 0xc8: DO_RET_COND((F&FZ)!=0); break;           // RET  Z
				case 0xd0: DO_RET_COND((F&FC)==0); break;           // RET  NC
				case 0xd8: DO_RET_COND((F&FC)!=0); break;           // RET  C
				case 0x02: WRITE_V(R16RBC, A); break;               // LD   (BC), A
				case 0x0A: A = READ_V(R16RBC); break;               // LD   A   , (BC)
				case 0x12: WRITE_V(R16RDE, A); break;               // LD   (DE), A
				case 0x1A: A = READ_V(R16RDE); break;               // LD   A   , (DE)
				case 0x70: WRITE_V(R16RHL, B); break;               // LD   (HL), B
				case 0x71: WRITE_V(R16RHL, C); break;               // LD   (HL), C
				case 0x72: WRITE_V(R16RHL, D); break;               // LD   (HL), D
				case 0x73: WRITE_V(R16RHL, E); break;               // LD   (HL), E
				case 0x74: WRITE_V(R16RHL, H); break;               // LD   (HL), H
				case 0x75: WRITE_V(R16RHL, L); break;               // LD   (HL), L
				case 0x77: WRITE_V(R16RHL, A); break;               // LD   (HL), A
				case 0x76: halted = true;	/*System.out.println("CPU HALTED");*/ break;                    // HALT
				case 0xd9: IME = true; DO_RET; break;               // RETI
				case 0xc1: R16WBC_V(POP); break;                    // PUSH BC
				case 0xd1: R16WDE_V(POP); break;                    // PUSH DE
				case 0xe1: R16WHL_V(POP); break;                    // PUSH HL
				case 0xf1: R16WAF_V(POP); break;                    // PUSH AF
				case 0xc5: PUSH_V(R16RBC); break;                   // PUSH BC
				case 0xd5: PUSH_V(R16RDE); break;                   // PUSH DE
				case 0xe5: PUSH_V(R16RHL); break;                   // PUSH HL
				case 0xf5: PUSH_V(R16RAF); break;                   // PUSH AF
				case 0x09: DO_ADD_HL(B, C); break;                  // ADD  HL  , BC
				case 0x19: DO_ADD_HL(D, E); break;                  // ADD  HL  , DE
				case 0x29: DO_ADD_HL(H, L); break;                  // ADD  HL  , HL
				case 0x39: DO_ADD_HL((SP>>8), (SP&0xff)); break;    // ADD  HL  , SP
				case 0xe9: PC = R16RHL; break;                      // JP   HL
				case 0x2f: A ^= 0xff; F |= (FN|FH); break;          // CPL
				case 0x36: WRITE_V(R16RHL, IMM8); break;            // LD   (HL), n
				case 0x07: DO_SHOP_R(RLC, A); F &= FC; break;       // RLA
				case 0x17: DO_SHOP_R(RL, A); F &= FC; break;        // RL
				case 0x0f: DO_SHOP_R(RRC, A); F &= FC; break;       // RRA
				case 0x1f: DO_SHOP_R(RR, A); F &= FC; break;        // RR
				case 0xc7: PUSH(PC); PC = 0x00; break;              // RST  &0
				case 0xcf: PUSH(PC); PC = 0x08; break;              // RST  &8
				case 0xd7: PUSH(PC); PC = 0x10; break;              // RST  &10
				case 0xdf: PUSH(PC); PC = 0x18; break;              // RST  &18
				case 0xe7: PUSH(PC); PC = 0x20; break;              // RST  &20
				case 0xef: PUSH(PC); PC = 0x28; break;              // RST  &28
				case 0xf7: PUSH(PC); PC = 0x30; break;              // RST  &30
				case 0xff: PUSH(PC); PC = 0x38; break;              // RST  &38
				case 0x37: F &= FZ; F |= FC; break;                 // SCF
				case 0x3f: F &= (FZ|FC); F ^= FC; break;            // CCF
				case 0x08: {                                        // LD   (nn), SP
					t_acc = IMM16;
					WRITE_V(t_acc, SP&0xff);
					WRITE_F((t_acc+1)&0xffff , SP>>8);
				}; break;
				case 0xf8:{                                         // LD  HL, SP+dd
					R16WHL(SP);
					L += (((IMM8)^0x80)-0x80);
					F = 0;
					if (L > 0xff) {
						L &= 0xff;
						F |= FH;
						++H;
						if (H > 0xff) {
							H &= 0xff;
							F |= FC;
						}
					}
					else if (L < 0) {
						L &= 0xff;
						F |= FH;
						--H;
						if (H < 0) {
							H &= 0xff;
							F |= FC;
						}
					}
				};break;
				case 0x27:{                                         // DAA
					t_acc = Tables.daa[(((F)&0x70)<<4) | A];
					A += t_acc;
					F = (F & (FN)) | ((A==0)?FZ:0) | Tables.daa_carry[t_acc>>2];
					A &= 0xff;
				};break;
				case 0xe8:{
					t_acc = SP;
					SP += (((IMM8)^0x80)-0x80);
					F = ((SP >> 8) != (t_acc >> 8)) ? FH : 0;
					if ((SP & ~0xffff) != 0) {
						SP &= 0xffff;
						F |= CF_Mask;
					}
				};break;
				case 0x10: if (speedswitch) {                       // STOP
					System.out.println("Speed switch!");
					doublespeed = !doublespeed;
					++PC; // debuggin hax! gnuboy does this too! (fix?)
					speedswitch = false;
				}; break;
				CASES_ALU_OP(0xb8, 0xfe, CP)                        // CP   x            x = r, imm8, (HL)
				CASES_ALU_OP(0xa0, 0xe6, AND)                       // AND  x            x = r, imm8, (HL)
				CASES_ALU_OP(0xa8, 0xee, XOR)                       // XOR  x            x = r, imm8, (HL)
				CASES_ALU_OP(0xb0, 0xf6, OR)                        // OR   x            x = r, imm8, (HL)
				CASES_ALU_OP(0x80, 0xC6, ADD)
				CASES_ALU_OP(0x88, 0xCE, ADC)
				CASES_ALU_OP(0x90, 0xD6, SUB)
				CASES_ALU_OP(0x98, 0xDE, SBC)
				CASES_INCDEC8
				CASES_INCDEC16
				CASES_LD_XX
				case 0xcb: // prefix instruction
					op = FETCH;
					cycles = Tables.cb_cycles[op];
					switch ( op ) {
						CASES_CB_BITNUM(0x40, BIT)
						CASES_CB_BITNUM(0x80, RES)
						CASES_CB_BITNUM(0xc0, SET)
						CASES_CB_SHOP(0x00, RLC)
						CASES_CB_SHOP(0x08, RRC)
						CASES_CB_SHOP(0x10, RL)
						CASES_CB_SHOP(0x18, RR)
						CASES_CB_SHOP(0x20, SLA)
						CASES_CB_SHOP(0x28, SRA)
						CASES_CB_SHOP(0x38, SRL)
						CASES_CB_SWAP
 						default:
						PRINTF( "UNKNOWN PREFIX INSTRUCTION: $%02x\n" , op );
						PC -= 2;
						return 0;
					}
				default:
					PRINTF( "UNKNOWN INSTRUCTION: $%02x\n" , op );
					PC -= 1; // we failed to execute the instruction, so restore PC
					return 0;
			}
#undef break
//			return cycles;
		}

		static long lastns = 0;
		static long lastuf = 0;
		static int samplesLeft = 0;

#ifdef ENABLE_RECOMPILER
		static CPURunBlock[] rccache =  new CPURunBlock[0x4000];
		static int[] rccnt =  new int[0x4000];
#endif

		static final public int nextinstruction() {
			//PRINTF("execing stuff PC=0x%04x VBLANKcntdwn=%05d, mode=%d\n",PC, VBLANKcntdwn, R_STAT&3);
			int res = 4*execute();
			last_memory_access=last_memory_access_internal;
			SP &= 0xffff;
			PC &= 0xffff;
			++TotalInstrCount;
			TotalCycleCount += res;
			lastException = ((res!=0) ? 0 : 1);
			if (res > 0) {
				//clockfreq = 4194304hz
				DIVcntdwn -= res;
				if (DIVcntdwn < 0) {
					DIVcntdwn += 256; // == 4194304/16384
					++IOP[0x04];
					IOP[0x04] &= 0xff;
				}
				int tac = IOP[0x07];
				if ((tac&4)!=0) {
					TIMAcntdwn -= res;
					if (TIMAcntdwn < 0) {
						if ((tac&3)==0) TIMAcntdwn += 1024; // == 4194304/4096
						if ((tac&3)==1) TIMAcntdwn +=   16; // == 4194304/262144
						if ((tac&3)==2) TIMAcntdwn +=   64; // == 4194304/65536
						if ((tac&3)==3) TIMAcntdwn +=  256; // == 4194304/16384
						++IOP[0x05];
						if (IOP[0x05] > 0xff) {
							IOP[0x05] = IOP[0x06];
							triggerInterrupt(2);
						}
					}
				}

				if (doublespeed) {
					VBLANKcntdwn -= res>>2; // more instrs per vblank int
					AC.render(res>>1); //render enough sound bytes for res Cycles
				}
			 	else {
					VBLANKcntdwn -= res>>1;
					AC.render(res); //render enough sound bytes for res Cycles
				}

				/** TODO: put this logic inside VideoController */
/*			Mode 0  ___000___000___000___000___000___000________________000
				Mode 1  ____________________________________11111111111111_____
				Mode 2  2_____2_____2_____2_____2_____2___________________2____
				Mode 3  _33____33____33____33____33____33__________________3___
*/
				if (VBLANKcntdwn < 0)
					lcdc_trans();
				/*{
					VBLANKcntdwn += 456;   // 4194304/9198
					++VC.LY;
					if (VC.LY >= 154)
						VC.LY = 0;
				}

				int mode = 2;
				if (VBLANKcntdwn < 376) mode = 3;
				if (VBLANKcntdwn < 204) mode = 0;
				if (VC.LY >= 144)       mode = 1;

				if (mode != vcmode) {
					vcmode = mode;
					VC.modeChanged(mode);
// 				PRINTF("\n");
				}*/
				/*
				for(int i=0; i<res; ++i)
					PRINTF("%d",mode);*/
				// [0 <= VBLANKcntdwn < 456]
				// [0..204)  [204..376)  [376..456)
				// mode 0    mode 3      mode 2
				// when LY>144 then mode 1

				// HBlank - HBlank = 456
				// VBlank - VBlank = 70224
				// [0 ................................................................................. 70224]
				// [                                                                  4560 - 1111111111111111] // mode 1 - 4560cycles
				// [                                                                                         ] // mode 2 - 80  cycles
				// [                                                                                         ] // mode 3 - 172 cycles
				// [                                                                                         ] // mode 0 - 204 cycles
				// 80+172+204=456

			}

			return res;
		}

		final protected int exception() {
			return lastException;
		}
}
