//Yoshi no tamago: $293 call crashes
public class CPU
{
		static private CPU singleton = null;
		protected static final int CARRY8b    = 512;
		protected static final int CARRY8b_SHR = 5;

		//FLAGS
		protected static final int ZF_Shift = 7;
		protected static final int NF_Shift = ZF_Shift - 1;
		protected static final int HC_Shift = NF_Shift - 1;
		protected static final int CF_Shift = HC_Shift - 1;
		protected static final int ZF_Mask  = 1 << ZF_Shift;
		protected static final int NF_Mask  = 1 << NF_Shift;
		protected static final int HC_Mask  = 1 << HC_Shift;
		protected static final int CF_Mask  = 1 << CF_Shift;

		#include "CPU.inc"

		static protected int TotalInstrCount = 0;
		static protected int TotalCycleCount = 0;

		protected static int B = 1;
		protected static int C = 2;
		protected static int D = 3;
		protected static int E = 4;
		protected static int F = 5;
		protected static int H = 6;
		protected static int L = 7;
		protected static int A = 0;

		//public int[] regs = new int[0x100]; // haha does nothing

/*
		final protected int shla(int value) {
			int res = value;
			res <<= 1;
			regs[F] = 0;
			regs[F] |= (res > 0xff) ? CF_Mask : 0;
			res &= 0xff;
			regs[F] |= (res == 0) ? ZF_Mask : 0;
			return res;
		}

		final protected int shra(int value) {
			int res = value;
			res >>= 1;
			regs[F] = 0;
			regs[F] |= ((value&1)!=0) ? CF_Mask : 0;
			res |= (value&(1<<7));
			regs[F] |= (res == 0) ? ZF_Mask : 0;
			return res;
		}

		final protected int shrl(int value) {
			int res = value;
			res >>= 1;
			regs[F] = 0;
			regs[F] |= ((value&1)!=0) ? CF_Mask : 0;
			regs[F] |= (res == 0) ? ZF_Mask : 0;
			return res;
		}

		final protected int rol(int value) {
			int res = value;
			res <<= 1;
			res |= ((regs[F]&CF_Mask)==CF_Mask) ? 1 : 0;
			regs[F] = 0;
			regs[F] |= (res > 0xff) ? CF_Mask : 0;
			res &= 0xff;
			regs[F] |= (res == 0) ? ZF_Mask : 0;
			return res;
		}

		final protected int rolc(int value) {
			int res = value;
			res <<= 1;
			res |= (res > 0xff) ? 1 : 0;
			regs[F] = 0;
			regs[F] |= (res > 0xff) ? CF_Mask : 0;
			res &= 0xff;
			regs[F] |= (res == 0) ? ZF_Mask : 0;
			return res;
		}

		final protected int ror(int value) {
			int res = value;
			res >>= 1;
			res |= ((regs[F]&CF_Mask)==CF_Mask) ? 1<<7 : 0;
			regs[F] = 0;
			regs[F] |= ((value&1)==1) ? CF_Mask : 0;
			res &= 0xff;
			regs[F] |= (res == 0) ? ZF_Mask : 0;
			return res;
		}

		final protected int rorc(int value) {
			int res = value;
			res >>= 1;
			res |= ((value&1)==1) ? 1<<7 : 0;
			regs[F] = 0;
			regs[F] |= ((value&1)==1) ? CF_Mask : 0;
			res &= 0xff;
			regs[F] |= (res == 0) ? ZF_Mask : 0;
			return res;
		}
*/
		static private int[] IOP = new int[0x80]; //IO Ports
		static private int[] HRAM = new int[0x7F]; //HighRAM
		static private int[][] WRAM = new int[0x08][0x10000]; //8x4k InternalRAM
		static private int CurrentWRAMBank=1;

		static private boolean doublespeed = false;
		static private boolean speedswitch = false;

		static private int DIVcntdwn = 0;
		static private int TIMAcntdwn = 0;
		static private int VBLANKcntdwn = 0;

		protected static int PC=0;         ///< Program counter
		protected static int SP=0;         ///< Stack Pointer
		protected static int IE=0;         ///< Interrupt Enable (allowed interrupts)
		protected static boolean IME=true; ///< Interrupt Master Enable
		protected static boolean halted=false;
		//IO
		static public int DirectionKeyStatus=0x0f; //bitmask
		static public int ButtonKeyStatus=0x3f; //bitmask
		//CPU Class variables
		static private Cartridge cartridge;// = new Cartridge("Pokemon Blue.gb");
		static private int lastException=0;
		static private Disassembler deasm;
		static protected VideoController VC;
		static protected AudioController AC;

		public CPU( Cartridge cartridge ) {
			if (singleton != null) {
				System.out.println("FATAL: trying to instantiate second instance of CPU singleton class");
				int x[]=null;
				x[0] = 0;
			}
			singleton = this;
			this.cartridge = cartridge;
			refreshMemMap();
			deasm = new Disassembler(this);
			VC = new VideoController(this, 160, 144);
			AC = new AudioController(this);
			reset();
		}

		static private int[][] rMemMap = new int[0x10][];
		static private int[][] wMemMap = new int[0x10][];

		static public boolean isCGB() {
			//System.out.println("** <INSERT DESCRIPTIVE TEXT HERE> ** [0x0143] = " + read(0x0143));
			return (read(0x0143) == 0x80) || (read(0x0143) == 0xC0);
		}

		static boolean BIOS_enabled = false;

		static final private void refreshMemMap() {
			if (BIOS_enabled)
				rMemMap[0x0] = null;
			else
				rMemMap[0x0] = cartridge.MM_ROM[0];
			// cartridge ROM bank 0 (read only, write has special functions)
			rMemMap[0x1] = cartridge.MM_ROM[1];
			rMemMap[0x2] = cartridge.MM_ROM[2];
			rMemMap[0x3] = cartridge.MM_ROM[3];

			// cartridge ROM switchable bank (read only, write has special functions)
			rMemMap[0x4] = cartridge.MM_ROM[(cartridge.CurrentROMBank<<2)|0];
			rMemMap[0x5] = cartridge.MM_ROM[(cartridge.CurrentROMBank<<2)|1];
			rMemMap[0x6] = cartridge.MM_ROM[(cartridge.CurrentROMBank<<2)|2];
			rMemMap[0x7] = cartridge.MM_ROM[(cartridge.CurrentROMBank<<2)|3];

			// 0x8 // TODO: somehow fit VRAM in here, difficult cause its
			// 0x9 //       not in 0xFFF chunks (and VC doesnt want it that way)

			// cartridge RAM (can be switchable)
			rMemMap[0xA] = wMemMap[0xA] = cartridge.MM_RAM[(cartridge.CurrentRAMBank<<1)|0];
			rMemMap[0xB] = wMemMap[0xB] = cartridge.MM_RAM[(cartridge.CurrentRAMBank<<1)|1];

			// WRAM, bank 0 and a switchable bank
			rMemMap[0xC] = wMemMap[0xC] = WRAM[0];
			rMemMap[0xD] = wMemMap[0xD] = WRAM[CurrentWRAMBank];

			// echo..
			rMemMap[0xE] = wMemMap[0xE] = rMemMap[0xC];

			// 0xF // lots of special stuff here...
		}

		static final protected int read(int index) {
			int mm[]=rMemMap[index>>12];
			if (mm!=null)
				return mm[index&0x0FFF];
			return read_slow(index);
		}

		static final private int read_slow(int index) {
			/* Memorymap:
			 * 0000-3FFF   16KB ROM Bank 00     (in cartridge, fixed at bank 00)
			 * 4000-7FFF   16KB ROM Bank 01..NN (in cartridge, switchable bank number)
			 * 8000-9FFF   8KB Video RAM (VRAM) (switchable bank 0-1 in CGB Mode)
			 * A000-BFFF   8KB External RAM     (in cartridge, switchable bank, if any)
			 * C000-CFFF   4KB Work RAM Bank 0 (WRAM)
			 * D000-DFFF   4KB Work RAM Bank 1 (WRAM)  (switchable bank 1-7 in CGB Mode)
			 * E000-FDFF   Same as C000-DDFF (ECHO)    (typically not used)
			 * FE00-FE9F   Sprite Attribute Table (OAM)
			 * FEA0-FEFF   Not Usable
			 * FF00-FF7F   I/O Ports
			 * FF80-FFFE   High RAM (HRAM)
			 * FFFF        Interrupt Enable Register
			 */
			int b;
			//System.out.println("ERROR: not using memmap "+ index);
			if(index<0) { //Invalid
				System.out.println("ERROR: CPU.read(): No negative addresses in GameBoy memorymap.");
				b=-1;
			}
			else if(index < 0x4000) { //16KB ROM Bank 00     (in cartridge, fixed at bank 00)
				if (index < 0x100) {
					b = cartridge.BIOS_ROM[index];
				    //System.out.println("reading from BIOS rom");
				}
				else if (index == 0x100) {
					System.out.println("reading from 0x100, disableing BIOS rom (PC="+PC+")");
					reset(false); // reset without forcing mono mode
					b = read(index);
				}
				else {
					b = cartridge.MM_ROM[0][index];
				  //System.out.println("reading from non-BIOS rom");
				}
			}
			else if(index < 0x8000) { //16KB ROM Bank 01..NN (in cartridge, switchable bank number)
				b=cartridge.read(index);
			}
			else if(index < 0xa000) { //8KB Video RAM (VRAM) (switchable bank 0-1 in CGB Mode)
				b=VC.read(index);
			}
			else if(index < 0xc000) { //8KB External RAM     (in cartridge, switchable bank, if any)
				b=cartridge.read(index);
			}
			else if(index < 0xd000) { //4KB Work RAM Bank 0 (WRAM)
				b=WRAM[0][index-0xc000];
			}
			else if(index < 0xe000) { //4KB Work RAM Bank 1 (WRAM)  (switchable bank 1-7 in CGB Mode)
				b=WRAM[CurrentWRAMBank][index-0xd000];
			}
			else if(index < 0xfe00) { //Same as C000-DDFF (ECHO)    (typically not used)
				b=read(index-0x2000);
			}
			else if(index < 0xfea0) { //Sprite Attribute Table (OAM)
				//System.out.println("TODO: CPU.read(): Sprite Attribute Table");
				b=VC.read(index);
			}
			else if(index < 0xff00) { //Not Usable
				System.out.println("WARNING: CPU.read(): Read from unusable memory (0xfea-0xfeff)");
				b=0;
			}
			else if(index < 0xff80) { //I/O Ports
				switch(index) {
					case 0xff00: // FF00 - P1/JOYP - Joypad (R/W)
						b=IOP[index-0xff00]&0xf0;
						if((b&(1<<4))==0) { // Direction keys, 0=select
							b|=DirectionKeyStatus;
						}
						if((b&(1<<5))==0) { // Buttons, 0=select
							b|=ButtonKeyStatus;
						}
						break;
					case 0xff01: // SB - Serial transfer data (R/W)
					case 0xff02: // SC - Serial Transfer Control (R/W)
						//yes fallthrough works here
					//case 0xff03 ! dont break above ports
					case 0xff04: // DIV
					case 0xff05: // TIMA
					case 0xff06: // TMA
					case 0xff07: // TAC
						b = IOP[index-0xff00];
						break;
					case 0xff0f: // FF0F - IF - Interrupt Flag (R/W)
						b = IOP[0x0f];
						break;
					/* AUDIO IO PORTS */
					case 0xff10: case 0xff11: case 0xff12: case 0xff13: case 0xff14: case 0xff15: case 0xff16: case 0xff17:
					case 0xff18: case 0xff19: case 0xff1a: case 0xff1b: case 0xff1c: case 0xff1d: case 0xff1e: case 0xff1f:
					case 0xff20: case 0xff21: case 0xff22: case 0xff23: case 0xff24: case 0xff25: case 0xff26: case 0xff27:
					case 0xff28: case 0xff29: case 0xff2a: case 0xff2b: case 0xff2c: case 0xff2d: case 0xff2e: case 0xff2f:
					case 0xff30: case 0xff31: case 0xff32: case 0xff33: case 0xff34: case 0xff35: case 0xff36: case 0xff37:
					case 0xff38: case 0xff39: case 0xff3a: case 0xff3b: case 0xff3c: case 0xff3d: case 0xff3e: case 0xff3f:
						b = AC.read(index);
						break;
					case 0xff40: // LCDC register
						b = VC.LCDC;
						break;
					case 0xff41: // FF41 - STAT - LCDC Status (R/W)
						//BLAAAA
						b = VC.STAT|(((new java.util.Random()).nextInt(2))<<1); //HAX I wanna play!!!
						break;
					case 0xff42: // SCY
						b = VC.SCY;
						break;
					case 0xff43: // SCX
						b = VC.SCX;
						break;
					case 0xff44: // LY
						b = VC.LY;
						break;
					case 0xff45: // LYC
						b = VC.LYC;
						break;
					case 0xff47: // BGP - BG Palette Data (R/W) - Non CGB Mode Only
					case 0xff48: // OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only
					case 0xff49: // OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only
						b = IOP[index-0xff00];
						break;
					case 0xff4a: // WY
						b = VC.WY;
						break;
					case 0xff4b: // WX
						b = VC.WX;
						break;
					case 0xff4d: // KEY1 - CGB Mode Only - Prepare Speed Switch
						b = doublespeed ? (1<<7) : 0;
						break;
					case 0xff4f: // VRAM bank nr
						b = VC.getcurVRAMBank();
						break;
					case 0xff51: // FF51 - HDMA1 - CGB Mode Only - New DMA Source, High
					case 0xff52: // FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low
					case 0xff53: // FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High
					case 0xff54: // FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low
					case 0xff55: // FF55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start
						b = IOP[index-0xff00];
						break;
					case 0xff68: // BGPI
						b = VC.BGPI;
						break;
					case 0xff69: // BGPD
						b = VC.getBGColData();
						break;
					case 0xff6a: // OBPI
						b = VC.OBPI;
						break;
					case 0xff6b: // OBPD
						b = VC.getOBColData();
						break;
					case 0xff70: // SVBK - CGB Mode Only - WRAM Bank
						b = CurrentWRAMBank;
						break;
					default:
						System.out.printf("TODO: CPU.read(): Read from IO port $%04x\n",index);
						b=0xff; // GnuBoy compat
						break;
				}
				//System.out.printf("TODO: CPU.read(): IOP[$%04x] = $%04x\n",index, b);
			}
			else if(index < 0xffff) { //High RAM (HRAM)
				b = HRAM[index-0xff80];
			}
			else if(index < 0x10000) { // Interrupt Enable Register (0xffff)
				//System.out.println("TODO: CPU.read(): Read from Interrupt Enable Register (0xffff)");
				b=IE;
			}
			else {
				System.out.println("ERROR: CPU.read(): Out of range memory access: $"+index);
				b=0;
			}
			return b;
		}

		static final private void write(int index, int value) {
			/* Memorymap:
			 * 0000-3FFF   16KB ROM Bank 00     (in cartridge, fixed at bank 00)
			 * 4000-7FFF   16KB ROM Bank 01..NN (in cartridge, switchable bank number)
			 * 8000-9FFF   8KB Video RAM (VRAM) (switchable bank 0-1 in CGB Mode)
			 * A000-BFFF   8KB External RAM     (in cartridge, switchable bank, if any)
			 * C000-CFFF   4KB Work RAM Bank 0 (WRAM)
			 * D000-DFFF   4KB Work RAM Bank 1 (WRAM)  (switchable bank 1-7 in CGB Mode)
			 * E000-FDFF   Same as C000-DDFF (ECHO)    (typically not used)
			 * FE00-FE9F   Sprite Attribute Table (OAM)
			 * FEA0-FEFF   Not Usable
			 * FF00-FF7F   I/O Ports
			 * FF80-FFFE   High RAM (HRAM)
			 * FFFF        Interrupt Enable Register
			 */
			//System.out.printf("Writing to IO address $%04x value=$%02x\n",index, value);
			int mm[]=wMemMap[index>>12];
			if (mm!=null) {
				mm[index&0x0FFF] = value;
				return;
			}
			if(index<0) { //Invalid
				System.out.println("ERROR: CPU.write(): No negative addresses in GameBoy memorymap.");
			}
			else if(index < 0x8000) { //cartridge ROM
				cartridge.write(index, value);

				refreshMemMap();
			}
			else if(index < 0xa000) { //8KB Video RAM (VRAM) (switchable bank 0-1 in CGB Mode)
				VC.write(index, value);
			}
			else if(index < 0xc000) { //8KB External RAM     (in cartridge, switchable bank, if any)
				cartridge.write(index, value);
			}
			else if(index < 0xd000) { //4KB Work RAM Bank 0 (WRAM)
				WRAM[0][index-0xc000]=value;
			}
			else if(index < 0xe000) { //4KB Work RAM Bank 1 (WRAM)  (switchable bank 1-7 in CGB Mode)
				WRAM[CurrentWRAMBank][index-0xd000]=value;
			}
			else if(index < 0xfe00) { //Same as C000-DDFF (ECHO)    (typically not used)
				write(index-0x2000, value);
			}
			else if(index < 0xfea0) { //Sprite Attribute Table (OAM)
				VC.write(index, value);
			}
			else if(index < 0xff00) { //Not Usable
				System.out.printf("TODO: CPU.write(): Write to unusable memory (0xfea-0xfeff) index=$%04x, value=$%02x\n",index,value);
			}
			else if(index < 0xff80) { //I/O Ports
				switch(index) {
					case 0xff00: // FF00 - P1/JOYP - Joypad (R/W)
						IOP[index&0xff]=value;
						break;
					case 0xff01: // SB - Serial transfer data (R/W)
						IOP[0x01]=value;
						break;
					case 0xff02: // SC - Serial Transfer Control (R/W)
						IOP[0x02]=value;
						if ((value&(1<<7))!=0) {
							// transfer! (we do it instantly...)
							if ((value&(1<<0))!=0) {
								// internal clock, this 'works' without other GB
								IOP[0x01] = 0xFF; // 'works'
								IOP[0x02] &= ~(1<<7); // 'transfer' finished
								triggerInterrupt(3);
							}
							else {
								// external clock, nothing will happen
							}
						}
						break;
					case 0xff04: // DIV
						IOP[0x04] = 0;
						break;
					case 0xff05: // TIMA
					case 0xff06: // TMA
					case 0xff07: // TAC
						IOP[index-0xff00] = value;
						break;
					case 0xff0f: // FF0F - IF - Interrupt Flag (R/W) (*Request* interrupts, and *shows* interrupts being queed)
						IOP[0x0f] = value;
						break;
					/* AUDIO IO PORTS */
					case 0xff10: case 0xff11: case 0xff12: case 0xff13: case 0xff14: case 0xff15: case 0xff16: case 0xff17:
					case 0xff18: case 0xff19: case 0xff1a: case 0xff1b: case 0xff1c: case 0xff1d: case 0xff1e: case 0xff1f:
					case 0xff20: case 0xff21: case 0xff22: case 0xff23: case 0xff24: case 0xff25: case 0xff26: case 0xff27:
					case 0xff28: case 0xff29: case 0xff2a: case 0xff2b: case 0xff2c: case 0xff2d: case 0xff2e: case 0xff2f:
					case 0xff30: case 0xff31: case 0xff32: case 0xff33: case 0xff34: case 0xff35: case 0xff36: case 0xff37:
					case 0xff38: case 0xff39: case 0xff3a: case 0xff3b: case 0xff3c: case 0xff3d: case 0xff3e: case 0xff3f:
						AC.write(index, value);
						break;
					case 0xff40: // LCDC register
						VC.LCDC = value;
						break;
					case 0xff41: // FF41 - STAT - LCDC Status (R/W)
						VC.STAT = (VC.STAT&7)|(value&~7); //lower 3bits are readonly
						break;
					case 0xff42: // SCY
						VC.SCY = value;
						break;
					case 0xff43: // SCX
						VC.SCX = value;
						break;
					case 0xff44: // LY
						VC.LY = 0; // can only be set to 0
						break;
					case 0xff45: // LYC
						VC.LYC = value;
						break;
					case 0xff46:{ // FF46 - DMA - DMA Transfer and Start Address (W)
						for(int i=0; i<0xa0; ++i){ //TODO : This takes TIME and needs TIMING
							write(0xfe00|i, read(i+(value<<8)));
						}
/*						VC.STAT|=2; //MODE2 or 3
						int cnt=0;
						while(cnt<160) { //Timing :D
						  cnt+=nextinstruction();
						}
						VC.STAT&=~2;*/
						} break;
					case 0xff47: // BGP - BG Palette Data (R/W) - Non CGB Mode Only
					case 0xff48: // OBP0 - Object Palette 0 Data (R/W) - Non CGB Mode Only
					case 0xff49: // OBP1 - Object Palette 1 Data (R/W) - Non CGB Mode Only
						IOP[index-0xff00] = value;
						VC.setMonoColData(index-0xff47, value);
						break;
					case 0xff4a: // WY
						VC.WY = value;
						break;
					case 0xff4b: // WX
						VC.WX = value;
						break;
					case 0xff4d: // KEY1 - CGB Mode Only - Prepare Speed Switch
						speedswitch = ((value&1)!=0);
						break;
					case 0xff4f: // FF4F - VBK - CGB Mode Only - VRAM Bank
						VC.selectVRAMBank(value&1);
						break;
					case 0xff51: // FF51 - HDMA1 - CGB Mode Only - New DMA Source, High
					case 0xff52: // FF52 - HDMA2 - CGB Mode Only - New DMA Source, Low
					case 0xff53: // FF53 - HDMA3 - CGB Mode Only - New DMA Destination, High
					case 0xff54: // FF54 - HDMA4 - CGB Mode Only - New DMA Destination, Low
						IOP[index-0xff00] = value;
						break;
					case 0xff55: // FF55 - HDMA5 - CGB Mode Only - New DMA Length/Mode/Start
						int src = ((IOP[0x51]<<8)|IOP[0x52]) & 0xfff0;
						int dst = (((IOP[0x53]<<8)|IOP[0x54]) & 0x1ff0) | 0x8000;
						int len = ((value & 0x7f)+1)<<4;
						int mode = value >> 7;
						if (mode == 0) {
							// TODO: this should take more than 4-12 cycles :O
							//System.out.printf("DONE: General HDMA transfer src=$%04x dst=$%04x len=$%04x\n", src, dst, len);
							for (int i = 0; i < len; ++i)
								VC.write(dst++, read(src++));
							IOP[0x55] = 0xff; // indicate we have finished
						} else {
							System.out.printf("TODO: HDMA HBlank transfer src=$%04x dst=$%04x len=$%04x\n", src, dst, len);
						}
						break;
					case 0xff68: // BGPI
						VC.BGPI = value;;
						break;
					case 0xff69: // BGPD
						VC.setBGColData(value);
						break;
					case 0xff6a: // OBPI
						VC.OBPI = value;;
						break;
					case 0xff6b: // OBPD
						VC.setOBColData(value);
						break;
					case 0xff70: //FF70 - SVBK - CGB Mode Only - WRAM Bank
						CurrentWRAMBank=Math.max(value&0x07, 1);
						refreshMemMap();
						break;
					default:
						System.out.printf("TODO: CPU.write(): Write to IO port $%04x\n",index);
						break;
				}
			}
			else if(index < 0xffff) { //High RAM (HRAM)
				HRAM[index-0xff80] = value;
			}
			else if(index < 0x10000) { // FFFF - IE - Interrupt Enable (R/W)
				//System.out.println("TODO: CPU.write(): Write to Interrupt Enable Register (0xffff)");
				IE=value; // Interrupt Enable Register
				//System.out.println("IE write: VBlank="+(IE&1)+" STAT="+((IE&2)>>1)+" Timer="+((IE&4)>>2)+" Serial="+((IE&8)>>3)+" Joypad="+((IE&16)>>4 ));
			}
			else {
				System.out.println("ERROR: CPU.write(): Out of range memory access: $"+index);
			}
		}


		static final public void reset() {
			reset(true);
		}

		static final public void reset(boolean bios) {
			BIOS_enabled = bios;
			VC.isCGB = bios ? false : isCGB();
			refreshMemMap();

			if (bios)
				PC=0;

			//AF=$01B0
			A=VC.isCGB?0x11:0x01; // CGB sets this to 0x11 instead of 0x01 for GB
			F=0xb0;
			//BC=$0013
			B=0x00;
			C=0x13;
			//DE=$00D8
			D=0x00;
			E=0xd8;
			//HL=$014D
			H=0x01;
			L=0x4d;
			TotalInstrCount=0;
			TotalCycleCount=0;

			//Stack Pointer=$FFFE
			SP=0xfffe;

			write(0xff05, 0x00); // [$FF05] = $00   ; TIMA
			write(0xff06, 0x00); // [$FF06] = $00   ; TMA
			write(0xff07, 0x00); // [$FF07] = $00   ; TAC
			write(0xff26, 0xf1); // [$FF26] = $F1-GB, $F0-SGB ; NR52
			AC.sound_off(); // Sets FF11-FF25
			write(0xff40, 0x91); // [$FF40] = $91   ; LCDC
			write(0xff42, 0x00); // [$FF42] = $00   ; SCY
			write(0xff43, 0x00); // [$FF43] = $00   ; SCX
			write(0xff45, 0x00); // [$FF45] = $00   ; LYC
			write(0xff47, 0xfc); // [$FF47] = $FC   ; BGP
			write(0xff48, 0xff); // [$FF48] = $FF   ; OBP0
			write(0xff49, 0xff); // [$FF49] = $FF   ; OBP1
			write(0xff4a, 0x00); // [$FF4A] = $00   ; WY
			write(0xff4b, 0x00); // [$FF4B] = $00   ; WX
			write(0xffff, 0x00); // [$FFFF] = $00   ; IE
		}

		static final protected int cycles() {
			return TotalInstrCount;
		}

		static final protected void printCPUstatus() {
			String flags = "";
			flags += (( F & ZF_Mask ) == ZF_Mask )?"Z ":"z ";
			flags += (( F & NF_Mask ) == NF_Mask )?"N ":"n ";
			flags += (( F & HC_Mask ) == HC_Mask )?"H ":"h ";
			flags += (( F & CF_Mask ) == CF_Mask )?"C ":"c ";
			flags += (( F & ( 1 <<3 ) ) == ( 1 <<3 ) )?"1 ":"0 ";
			flags += (( F & ( 1 <<2 ) ) == ( 1 <<2 ) )?"1 ":"0 ";
			flags += (( F & ( 1 <<1 ) ) == ( 1 <<1 ) )?"1 ":"0 ";
			flags += (( F & ( 1 <<0 ) ) == ( 1 <<0 ) )?"1 ":"0 ";
			System.out.println( "---CPU Status for cycle "+TotalCycleCount+" , instruction "+TotalInstrCount+"---" );
			System.out.printf( "   A=$%02x    B=$%02x    C=$%02x    D=$%02x   E=$%02x   F=$%02x   H=$%02x   L=$%02x\n", A, B, C, D, E, F, H,L );
			System.out.printf( "  PC=$%04x SP=$%04x                           flags="+flags+"\n",PC,SP );
			System.out.println( "  "+deasm.simple_disasm( PC ) );
		}

		static final protected int checkInterrupts() { //handle interrupt priorities
			if(IME) { // If interrupts enabled
				int ir = IOP[0x0f]&IE; //First Requested interrupts
				if((ir&(1<<0))!=0) { //VBlANK
					IOP[0x0f] &= ~(1<<0);
					interrupt(0x40);
					return 1;
				}
				else if ((ir&(1<<1))!=0) { //LCD STAT
					IOP[0x0f] &= ~(1<<1);
					interrupt(0x48);
					return 1;
				}
				else if ((ir&(1<<2))!=0) { //Timer
					IOP[0x0f] &= ~(1<<2);
					interrupt(0x50);
					return 1;
				}
				else if ((ir&(1<<3))!=0) { //Serial
					IOP[0x0f] &= ~(1<<3);
					interrupt(0x58);
					return 1;
				}
				else if ((ir&(1<<4))!=0) { //Joypad
					IOP[0x0f] &= ~(1<<4);
					interrupt(0x60);
					return 1;
				}
			}
			return 0; // No interrupts to service
		}

		static final protected void interrupt(int i) { //execute interrupt #i
			//System.out.println("INTERRUPT: " + i);
			IME = false;
			PUSH_OLD(PC);
			PC = i;
		}

		static final protected void triggerInterrupt(int i) { // request interrupt with bit nr #i
			IOP[0x0f] |= (1<<i);
		}

		static final protected int execute() {
			int cycles;
			TVARS;
			if (CHECK_INTS) {
				checkInterrupts();
				halted = false;
				//return 12; // 12 cycles for this?
			}
			if (halted) return 4;
			int op = FETCH;
			cycles = Tables.cycles[op];

#define break return cycles
			switch ( op ) {
				case 0x00: break;                                   // NOP
				case 0xf3: IME=false; break;                        // DI
				case 0xfb: IME=true; break;                         // IE
				case 0xea: WRITE_V(IMM16, A); break;                // LD   (nn), A
				case 0xfa: A = READ_V(IMM16); break;                // LD   A   , (nn)
				case 0xe0: WRITE_S(IMM8 | 0xff00, A); break;        // LDH  (n) , A
				case 0xf0: A = READ_S(IMM8 | 0xff00); break;        // LDH  A   , (n)
				case 0xe2: WRITE_S(C | 0xff00, A); break;           // LDH  (C) , A
				case 0xf2: A = READ_S(C | 0xff00); break;           // LDH  A   , (C)
				case 0xf9: SP = R16RHL; break;                      // LD   SP  , HL
				case 0x22: WRITE_V(R16RHL, A); DO_INC16(HL); break; // LDI  (HL), A
				case 0x2a: A = READ_V(R16RHL); DO_INC16(HL); break; // LDI  A   , (HL)
				case 0x32: WRITE_V(R16RHL, A); DO_DEC16(HL); break; // LDD  (HL), A
				case 0x3a: A = READ_V(R16RHL); DO_DEC16(HL); break; // LDD  A   , (HL)
				case 0xc3: DO_JP_NN; break;                         // JP   (nn)
				case 0xc2: DO_JP_COND((F&FZ)==0); break;            // JP   NZ  , (nn)
				case 0xca: DO_JP_COND((F&FZ)!=0); break;            // JP   Z   , (nn)
				case 0xd2: DO_JP_COND((F&FC)==0); break;            // JP   NC  , (nn)
				case 0xda: DO_JP_COND((F&FC)!=0); break;            // JP   C   , (nn)
				case 0xcd: DO_CALL_NN; break;                       // CALL (nn)
				case 0xc4: DO_CALL_COND((F&FZ)==0); break;          // CALL NZ  , (d)
				case 0xcc: DO_CALL_COND((F&FZ)!=0); break;          // CALL Z   , (d)
				case 0xd4: DO_CALL_COND((F&FC)==0); break;          // CALL NC  , (d)
				case 0xdc: DO_CALL_COND((F&FC)!=0); break;          // CALL C   , (d)
				case 0x18: DO_JR_D; break;                          // JR   (d)
				case 0x20: DO_JR_COND((F&FZ)==0); break;            // JR   NZ  , (d)
				case 0x28: DO_JR_COND((F&FZ)!=0); break;            // JR   Z   , (d)
				case 0x30: DO_JR_COND((F&FC)==0); break;            // JR   NC  , (d)
				case 0x38: DO_JR_COND((F&FC)!=0); break;            // JR   C   , (d)
				case 0xc9: DO_RET; break;                           // RET
				case 0xc0: DO_RET_COND((F&FZ)==0); break;           // RET  NZ
				case 0xc8: DO_RET_COND((F&FZ)!=0); break;           // RET  Z
				case 0xd0: DO_RET_COND((F&FC)==0); break;           // RET  NC
				case 0xd8: DO_RET_COND((F&FC)!=0); break;           // RET  C
				case 0x02: WRITE_V(R16RBC, A); break;               // LD   (BC), A
				case 0x0A: A = READ_V(R16RBC); break;               // LD   A   , (BC)
				case 0x12: WRITE_V(R16RDE, A); break;               // LD   (DE), A
				case 0x1A: A = READ_V(R16RDE); break;               // LD   A   , (DE)
				case 0x70: WRITE_V(R16RHL, B); break;               // LD   (HL), B
				case 0x71: WRITE_V(R16RHL, C); break;               // LD   (HL), C
				case 0x72: WRITE_V(R16RHL, D); break;               // LD   (HL), D
				case 0x73: WRITE_V(R16RHL, E); break;               // LD   (HL), E
				case 0x74: WRITE_V(R16RHL, H); break;               // LD   (HL), H
				case 0x75: WRITE_V(R16RHL, L); break;               // LD   (HL), L
				case 0x77: WRITE_V(R16RHL, A); break;               // LD   (HL), A
				case 0x76: halted = true;	break;                    // HALT
				case 0xd9: IME = true; DO_RET; break;               // RETI
				case 0xc1: R16WBC_V(POP); break;                    // PUSH BC
				case 0xd1: R16WDE_V(POP); break;                    // PUSH DE
				case 0xe1: R16WHL_V(POP); break;                    // PUSH HL
				case 0xf1: R16WAF_V(POP); break;                    // PUSH AF
				case 0xc5: PUSH_V(R16RBC); break;                   // PUSH BC
				case 0xd5: PUSH_V(R16RDE); break;                   // PUSH DE
				case 0xe5: PUSH_V(R16RHL); break;                   // PUSH HL
				case 0xf5: PUSH_V(R16RAF); break;                   // PUSH AF
				case 0x09: DO_ADD_HL(B, C); break;                  // ADD  HL  , BC
				case 0x19: DO_ADD_HL(D, E); break;                  // ADD  HL  , DE
				case 0x29: DO_ADD_HL(H, L); break;                  // ADD  HL  , HL
				case 0x39: DO_ADD_HL((SP>>8), (SP&0xff)); break;    // ADD  HL  , SP
				case 0xe9: PC = R16RHL; break;                      // JP   HL
				case 0x2f: A ^= 0xFF; F |= (FN|FH); break;             // CPL
				case 0x36: WRITE_V(R16RHL, IMM8); break;            // LD   (HL), n
				case 0x07: DO_SHOP_R(RLC, A); F &= FC; break;       // RLA
				case 0x17: DO_SHOP_R(RL, A); F &= FC; break;        // RL
				case 0x0f: DO_SHOP_R(RRC, A); F &= FC; break;       // RRA
				case 0x1f: DO_SHOP_R(RR, A); F &= FC; break;        // RR
				case 0xc7: PUSH(PC); PC = 0x00; break;              // RST  &0
				case 0xcf: PUSH(PC); PC = 0x08; break;              // RST  &8
				case 0xd7: PUSH(PC); PC = 0x10; break;              // RST  &10
				case 0xdf: PUSH(PC); PC = 0x18; break;              // RST  &18
				case 0xe7: PUSH(PC); PC = 0x20; break;              // RST  &20
				case 0xef: PUSH(PC); PC = 0x28; break;              // RST  &28
				case 0xf7: PUSH(PC); PC = 0x30; break;              // RST  &30
				case 0xff: PUSH(PC); PC = 0x38; break;              // RST  &38
				case 0x37: F &= FZ; F |= FC; break;                 // SCF
				case 0x3f: F &= (FZ|FC); F ^= FC; break;            // CCF
				case 0x08: {                                        // LD   (nn), SP
					t_acc = IMM16;
					WRITE_F(t_acc , SP>>8);
					WRITE_V((t_acc+1)&0xffff, SP&0xff);
				}; break;
				case 0xf8:{                                         // LD  HL, SP+dd
					R16WHL(SP);
					L += (((IMM8)^0x80)-0x80);
					F = 0;
					if (L > 0xff) {
						L &= 0xff;
						F |= FH;
						++H;
						if (H > 0xff) {
							H &= 0xff;
							F |= FC;
						}
					}
					else if (L < 0) {
						L &= 0xff;
						F |= FH;
						--H;
						if (H < 0) {
							H &= 0xff;
							F |= FC;
						}
					}
				};break;
				case 0x27:{                                         // DAA
					t_acc = Tables.daa[(((F)&0x70)<<4) | A];
					A += t_acc;
					F = (F & (FN)) | ((A==0)?FZ:0) | Tables.daa_carry[t_acc>>2];
					A &= 0xff;
				};break;
				case 0xe8:{
					t_acc = SP;
					SP += (((IMM8)^0x80)-0x80);
					F = ((SP >> 8) != (t_acc >> 8)) ? FH : 0;
					if ((SP & ~0xffff) != 0) {
						SP &= 0xffff;
						F |= CF_Mask;
					}
				};break;
				case 0x10: if (speedswitch) {                       // STOP
					System.out.println("Speed switch!");
					doublespeed = !doublespeed;
					speedswitch = false;
				}; break;
				CASES_ALU_OP(0xb8, 0xfe, CP)                        // CP   x            x = r, imm8, (HL)
				CASES_ALU_OP(0xa0, 0xe6, AND)                       // AND  x            x = r, imm8, (HL)
				CASES_ALU_OP(0xa8, 0xee, XOR)                       // XOR  x            x = r, imm8, (HL)
				CASES_ALU_OP(0xb0, 0xf6, OR)                        // OR   x            x = r, imm8, (HL)
				CASES_ALU_OP(0x80, 0xC6, ADD)
				CASES_ALU_OP(0x88, 0xCE, ADC)
				CASES_ALU_OP(0x90, 0xD6, SUB)
				CASES_ALU_OP(0x98, 0xDE, SBC)
				CASES_INCDEC8
				CASES_INCDEC16
				CASES_LD_XX
				case 0xcb: // prefix instruction
					op = FETCH;
					cycles = Tables.cb_cycles[op];
					switch ( op ) {
						CASES_CB_BITNUM(0x40, BIT)
						CASES_CB_BITNUM(0x80, RES)
						CASES_CB_BITNUM(0xc0, SET)
						CASES_CB_SHOP(0x00, RLC)
						CASES_CB_SHOP(0x08, RRC)
						CASES_CB_SHOP(0x10, RL)
						CASES_CB_SHOP(0x18, RR)
						CASES_CB_SHOP(0x20, SLA)
						CASES_CB_SHOP(0x28, SRA)
						CASES_CB_SHOP(0x38, SRL)
						CASES_CB_SWAP
 						default:
						System.out.printf( "UNKNOWN PREFIX INSTRUCTION: $%02x\n" , op );
						PC -= 2;
						return 0;
					}
				default:
					System.out.printf( "UNKNOWN INSTRUCTION: $%02x\n" , op );
					PC -= 1; // we failed to execute the instruction, so restore PC
					return 0;
			}
#undef break
//			return cycles;
		}

		static long lastns = 0;
		static long lastuf = 0;
		static int samplesLeft = 0;

		final public int nextinstruction() {
			int res = 4*execute();
			++TotalInstrCount;
			TotalCycleCount += res;
			lastException = (res!=0) ? 0 : 1;
			if (res > 0)  {
				//clockfreq = 4194304hz
				DIVcntdwn -= res;
				if (DIVcntdwn < 0) {
					DIVcntdwn += 256; // == 4194304/16384
					++IOP[0x04];
					IOP[0x04] &= 0xff;
				}
				int tac = IOP[0x07];
				if ((tac&4)!=0) {
					TIMAcntdwn -= res;
					if (TIMAcntdwn < 0) {
						if ((tac&3)==0) TIMAcntdwn += 1024; // == 4194304/4096
						if ((tac&3)==1) TIMAcntdwn +=   16; // == 4194304/262144
						if ((tac&3)==2) TIMAcntdwn +=   64; // == 4194304/65536
						if ((tac&3)==3) TIMAcntdwn +=  256; // == 4194304/16384
						++IOP[0x05];
						if (IOP[0x05] > 0xff) {
							IOP[0x05] = IOP[0x06];
							triggerInterrupt(2);
						}
					}
				}

				if (doublespeed) {
					VBLANKcntdwn -= res/2; // more instrs per vblank int
					AC.render(res>>1); //render enough sound bytes for res Cycles
				}
			 	else {
					VBLANKcntdwn -= res;
					AC.render(res); //render enough sound bytes for res Cycles
				}
				if (VBLANKcntdwn < 0) {
					VBLANKcntdwn += 456;   // 4194304/9198
					VC.renderNextScanline();
				}
				// [0 <= VBLANKcntdwn < 456]
				// [0..80)   [80..252)   [252..456)
				// mode 2    mode 3      mode 0
				// when LY>144 then mode 1

			}

			return res;
		}

		final protected int exception() {
			return lastException;
		}
}
